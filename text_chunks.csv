Index,Text
Lecture1_Chunk1,"MITOCW | watch?v=ytpJdnlu9ug
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high-quality, educational resources for free. To make
a donation, or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
ANA BELL:
All right. Let's begin. As I mentioned before, this lecture will be recorded for OCW. Again, in"
Lecture1_Chunk2,"All right. Let's begin. As I mentioned before, this lecture will be recorded for OCW. Again, in
future lectures, if you don't want to have the back of your head show up, just don't sit in this
front area here.
First of all, wow, what a crowd, you guys. We're finally in 26-100. 6.0001 made it big, huh?
Good afternoon and welcome to the very first class of 6.0001, and also 600, this semester.
My name is Ana Bell. First name, Ana. Last name, Bell. I'm a lecturer in the EECS Department."
Lecture1_Chunk3,"My name is Ana Bell. First name, Ana. Last name, Bell. I'm a lecturer in the EECS Department.
And I'll be giving some of the lectures for today, along with later on in the term, Professor Eric
Grimson, who's sitting right down there, will be giving some of the lectures, as well.
Today we're going to go over some basic administrivia, a little bit of course information. And
then, we're going to talk a little bit about what is computation? We'll discuss at a very high level"
Lecture1_Chunk4,"then, we're going to talk a little bit about what is computation? We'll discuss at a very high level
what computers do just to make sure we're all on the same page.
And then, we're going to dive right into Python basics. We're going to talk a little bit about
mathematical operations you can do with Python. And then, we're going to talk about Python
variables and types.
As I mentioned in my introductory email, all the slides and code that I'll talk about during"
Lecture1_Chunk5,"As I mentioned in my introductory email, all the slides and code that I'll talk about during
lectures will be up before lecture, so I highly encourage you to download them and to have
them open. We're going to go through some in-class exercises which will be available on those
slides. And it's fun to do.
And it's also great if could take notes about the code just for future reference. It's true. This is
a really fast-paced course, and we ramp up really quickly. We do want to position you to"
Lecture1_Chunk6,"a really fast-paced course, and we ramp up really quickly. We do want to position you to
succeed in this course.
As I was writing this, I was trying to think about when I was first starting to program what
helped me get through my very first programming course. And this is really a good list. The
first thing was I just read the psets as soon as they came out, made sure that the terminology
first thing was I just read the psets as soon as they came out, made sure that the terminology"
Lecture1_Chunk7,"first thing was I just read the psets as soon as they came out, made sure that the terminology
just sunk in.
And then, during lectures, if the lecturer was talking about something that suddenly I
remembered, oh, I saw that word in the pset and I didn't know what it was. Well, hey, now I
know what it is. Right? So just give it a read. You don't need to start it.
If you're new to programming, I think the key word is practice. It's like math or reading. The"
Lecture1_Chunk8,"If you're new to programming, I think the key word is practice. It's like math or reading. The
more you practice, the better you get at it. You're not going to absorb programming by
watching me write programs because I already know how to program. You guys need to
practice.
Download the code before lecture. Follow along. Whatever I type, you guys can type. And I
think, also, one of the big things is if you're new to programming, you're kind of afraid that"
Lecture1_Chunk9,"think, also, one of the big things is if you're new to programming, you're kind of afraid that
you're going to break your computer. And you can't really do that just by running Anaconda
and typing in some commands.
So don't be afraid to just type some stuff in and see what it does. Worst case, you just restart
the computer. Yeah. That's probably the big thing right there. I should have probably
highlighted it, but don't be afraid."
Lecture1_Chunk10,"highlighted it, but don't be afraid.
Great. So this is pretty much a roadmap of all of 6.0001 or 600 as I've just explained it.
There's three big things we want to get out of this course. The first thing is the knowledge of
concepts, which is pretty much true of any class that you'll take.
The class will teach you something through lectures. Exams will test how much you know. This
is a class in programming. The other thing we want you to get out of it is programming skills."
Lecture1_Chunk11,"is a class in programming. The other thing we want you to get out of it is programming skills.
And the last thing, and I think this is what makes this class really great, is we teach you how to
solve problems. And we do that through the psets. That's really how I feel the roadmap of this
course looks like.
And underlying all of these is just practice. You have to just type some stuff away and code a
lot. And you'll succeed in this course, I think."
Lecture1_Chunk12,"lot. And you'll succeed in this course, I think.
OK. So what are the things we're going to learn in this class? I feel like the things we're going
learn in this class can be divided into basically three different sections. The first one is related
to these first two items here. It's really about learning how to program.
Learning how to program, part of it is figuring out what objects to create. You'll learn about"
Lecture1_Chunk13,"Learning how to program, part of it is figuring out what objects to create. You'll learn about
these later. How do you represent knowledge with data structures? That's sort of the broad
term for that.
And then, as you're writing programs, you need to-- programs aren't just linear. Sometimes
programs jump around. They make decisions. There's some control flow to programs. That's
what the second line is going to be about."
Lecture1_Chunk14,"what the second line is going to be about.
The second big part of this course is a little bit more abstract, and it deals with how do you
write good code, good style, code that's readable. When you write code, you want to write it
such that-- you're in big company, other people will read it, other people will use it, so it has to
be readable and understandable by others.
To that end, you need to write code that's well organized, modular, easy to understand. And"
Lecture1_Chunk15,"To that end, you need to write code that's well organized, modular, easy to understand. And
not only that, not only will your code be read by other people, but next year, maybe, you'll take
another course, and you'll want to look back at some of the problems that you wrote in this
class.
You want to be able to reread your code. If it's a big mess, you might not be able to
understand-- or reunderstand-- what you were doing. So writing readable code and organizing
code is also a big part."
Lecture1_Chunk16,"code is also a big part.
And the last section is going to deal with-- the first two are actually part of the programming in
Introduction to Programming and Computer Science in Python. And the last one deals mostly
with the computer science part in Introduction to Programming and Computer Science in
Python.
We're going to talk about, once you have learned how to write programs in Python, how do
you compare programs in Python? How do you know that one program is better than the
other?"
Lecture1_Chunk17,"you compare programs in Python? How do you know that one program is better than the
other?
How do you know that one program is more efficient than the other? How do you know that
one algorithm is better than the other? That's what we're going to talk about in the last part of
the course.
OK. That's all for the administrative part of the course. Let's start by talking at a high level what
does a computer do."
Lecture1_Chunk18,"does a computer do.
Fundamentally, it does two things. One, performs calculations. It performs a lot of calculations.
Computers these days are really, really fast, a billion calculations per second is probably not
far off. It performs these calculations and it has to store them somewhere. Right? Stores them
in computer memory.
So a computer also has to remember results. And these days, it's not uncommon to find"
Lecture1_Chunk19,"So a computer also has to remember results. And these days, it's not uncommon to find
computers with hundreds of gigabytes of storage. The kinds of calculations that computers do,
there are two kinds.
One are calculations that are built into the language. These are the very low level types of
calculations, things like addition, subtraction, multiplication, and so on.
And once you have a language that has these primitive calculation types, you, as a"
Lecture1_Chunk20,"And once you have a language that has these primitive calculation types, you, as a
programmer, can put these types together and then define your own calculations. You can
create new types of calculations. And the computer will be able to perform those, as well.
I think, one thing I want to stress-- and we're going to come back to this again during this
entire lecture, actually-- is computers only know what you tell them. Computers only do what"
Lecture1_Chunk21,"entire lecture, actually-- is computers only know what you tell them. Computers only do what
you tell them to do. They're not magical. They don't have a mind.
They just know how to perform calculations really, really quickly. But you have to tell them
what calculations to do. Computers don't know anything. All right. We've come to that.
Let's go into the types of knowledge. The first type of knowledge is declarative knowledge. And"
Lecture1_Chunk22,"Let's go into the types of knowledge. The first type of knowledge is declarative knowledge. And
those are things like statements of fact. And this is where my email came into play. If you read
it all the way to the bottom, you would have entered a raffle.
So a statement of fact for today's lecture is, someone will win a prize before class ends. And
the prize was a Google Cardboard. Google state-of-the-art virtual reality glasses. And I have
them right here. Yea. I delivered on my promise."
Lecture1_Chunk23,"them right here. Yea. I delivered on my promise.
That's a statement of fact. So pretend I'm a machine. OK? I don't know anything except what
you tell me. I don't know. I know that you tell me this statement. I'm like, OK. But how is
someone going to win a Google Cardboard before class ends, right?
That's where imperative knowledge comes in. Imperative knowledge is the recipe, or the how-
to, or the sequence of steps. Sorry. That's just my funny for that one. So the sequence of"
Lecture1_Chunk24,"to, or the sequence of steps. Sorry. That's just my funny for that one. So the sequence of
steps is imperative knowledge.
If I'm a machine, you need to tell me how someone will win a Google Cardboard before class.
If I follow these steps, then technically, I should reach a conclusion.
Step one, I think we've already done that. Whoever wanted to sign up has signed up. Now I'm
going to open my IDE. I'm just basically being a machine and following the steps that you've
told me."
Lecture1_Chunk25,"told me.
The IDE that we're using in this class is called Anaconda. I'm just scrolling down to the bottom.
Hopefully, you've installed it in problem set zero. I've opened my IDE. I'm going to follow the
next set of instructions. I'm going to choose a random number between the first and the nth
responder.
Now, I'm going to actually use Python to do this . And this is also an example of how just a
really simple task in your life, you can use computers or programming to do that. Because if I"
Lecture1_Chunk26,"really simple task in your life, you can use computers or programming to do that. Because if I
chose a random number, I might be biased because, for example, I might like the number 8.
To choose a random number, I'm going to go and say, OK, where's the list of responders? It
starts at 15. Actually, it starts at 16 because that's me. We're going to choose a random
number between 16 and the end person 266. Oh, we just got-- oh. OK."
Lecture1_Chunk27,"number between 16 and the end person 266. Oh, we just got-- oh. OK.
OK. I'm going to cut it off right here. 271. OK. 16 and 271. Perfect. OK. I'm going to choose a
random number. I'm going to go to my IDE. And you don't need to know how to do this yet, but
by the end of this class, you will. I'm just going to use Python.
I'm just going to get the random number package that's going to give me a random number.
I'm going to say random.randint. And I'm going to choose a random number between 16 and"
Lecture1_Chunk28,"I'm going to say random.randint. And I'm going to choose a random number between 16 and
272,
OK. 75. OK. Great. I chose a random number. And I'm going to find the number in the
responder's sheet. What was the number again? Sorry. 75. OK. Up we go. There we go.
Lauren Z-O-V. Yeah. Nice. You're here.
Awesome. All right. That's an example of me being a machine and also, at the same time,
using Python in my everyday life, just lecturing, to find a random number. Try to use Python"
Lecture1_Chunk29,"using Python in my everyday life, just lecturing, to find a random number. Try to use Python
wherever you can. And that just gives you practice.
That was fun. But we're at MIT. We're MIT students. And we love numbers here at MIT. Here's
a numerical example that shows the difference between declarative and imperative
a numerical example that shows the difference between declarative and imperative
knowledge."
Lecture1_Chunk30,"a numerical example that shows the difference between declarative and imperative
knowledge.
An example of declarative knowledge is the square root of a number x is y such that y times y
is equal to x. That's just a statement of fact It's true. Computers don't know what to do with
that. They don't know what to do with that statement. But computers do know how to follow a
recipe.
Here's a well-known algorithm. To find the square root of a number x, let's say x is originally"
Lecture1_Chunk31,"Here's a well-known algorithm. To find the square root of a number x, let's say x is originally
16, if a computer follows this algorithm, it's going to start with a guess, g, let's say, 3. We're
trying to find the square root of 16.
We're going to calculate g times g is 9. And we're going to ask is if g times g is close enough to
x, then stop and say, g is the answer.
I'm not really happy with 9 being really close to 16. So I'm going to say, I'm not stopping here.
I'm going to keep going."
Lecture1_Chunk32,"I'm going to keep going.
If it's not close enough, then I'm going to make a new guess by averaging g and x over g.
That's x over g here. And that's the average over there.
And the new average is going to be my new guess. And that's what it says. And then, the last
step is using the new guess, repeat the process. Then we go back to the beginning and repeat
the whole process over and over again.
And that's what the rest of the rows do. And you keep doing this until you decide that you're"
Lecture1_Chunk33,"And that's what the rest of the rows do. And you keep doing this until you decide that you're
close enough. What we saw for the imperative knowledge in the previous numerical example
was the recipe for how to find the square root of x. What were the three parts of the recipe?
One was a simple sequence of steps. There were four steps. The other was a flow of control,
so there were parts where we made decisions. Are we close enough? There were parts where"
Lecture1_Chunk34,"so there were parts where we made decisions. Are we close enough? There were parts where
we repeated some steps. At the end, we said, repeat steps 1, 2, 3. That's the flow of control.
And the last part of the recipe was a way to stop. You don't want a program that keeps going
and going. Or for a recipe, you don't want to keep baking bread forever. You want to stop at
some point. Like 10 breads is enough, right? So you have to have a way of stopping."
Lecture1_Chunk35,"some point. Like 10 breads is enough, right? So you have to have a way of stopping.
In the previous example, the way of stopping was that we decided we were close enough.
Close enough was maybe being within .01, .001, whatever you pick. This recipe is there for an
algorithm. In computer science speak, it's going to be an algorithm. And that's what we're
going to learn about in this class.
We're dealing with computers. And we actually want to capture a recipe inside a computer, a"
Lecture1_Chunk36,"We're dealing with computers. And we actually want to capture a recipe inside a computer, a
computer being a mechanical process. Historically, there were two different types of
computers. Originally, there were these things called fixed-program computers.
And I'm old enough to have used something like this, where there's just numbers and plus,
minus, multiplication, divide, and equal. But calculators these days are a lot more complicated."
Lecture1_Chunk37,"minus, multiplication, divide, and equal. But calculators these days are a lot more complicated.
But way back then, an example of a fixed-program computer is this calculator. It only knows
how to do addition, multiplication, subtraction, division. If you want to plot something, you can't.
If you want to go on the internet, send email with it, you can't.
It can only do this one thing. And if you wanted to create a machine that did another thing,"
Lecture1_Chunk38,"It can only do this one thing. And if you wanted to create a machine that did another thing,
then you'd have to create another fixed-program computer that did a completely separate test.
That's not very great.
That's when stored-program computers came into play. And these were machines that could
store a sequence of instructions. And these machines could execute the sequence of
instructions. And you could change the sequence of instructions and execute this different
sequence of instructions."
Lecture1_Chunk39,"sequence of instructions.
You could do different tasks in the same machine. And that's the computer as we know it
these days. The central processing unit is where all of these decisions get made. And these
are all the peripherals.
The basic machine architecture-- at the heart of every computer there's just this basic
architecture-- and it contains, I guess, four main parts. The first is the memory. Input and
output is the other one."
Lecture1_Chunk40,"output is the other one.
The ALU is where all of the operations are done. And the operations that the ALU can do are
really primitive operations, addition, subtraction, and so on.
What the memory contains is a bunch of data and your sequence of instructions. Interacting
with the Arithmetic Logic Unit is the Control Unit. And the Control Unit contains one program
counter.
When you load a sequence of instructions, the program counter starts at the first sequence. It"
Lecture1_Chunk41,"When you load a sequence of instructions, the program counter starts at the first sequence. It
starts at the sequence, at the first instruction. It gets what the instruction is, and it sends it to
the ALU.
The ALU asks, what are we doing operations on here? What's happening? It might get some
data. If you're adding two numbers, it might get two numbers from memory. It might do some
operations. And it might store data back into memory."
Lecture1_Chunk42,"operations. And it might store data back into memory.
And after it's done, the ALU is going to go back, and the program counter is going to increase
by 1, which means that we're going to go to the next sequence in the instruction set. And it just
goes linearly, instruction by instruction.
There might be one particular instruction that does some sort of test. It's going to say, is this
particular value greater or equal to or the same as this other particular value? That's a test, an"
Lecture1_Chunk43,"particular value greater or equal to or the same as this other particular value? That's a test, an
example of a test. And the test is going to either return true or false.
And depending on the result of that test, you might either go to the next instruction, or you
might set the program counter to go all the way back to the beginning, and so on. You're not
just linearly stepping through all the instructions. There might be some control flow involved,"
Lecture1_Chunk44,"just linearly stepping through all the instructions. There might be some control flow involved,
where you might skip an instruction, or start from the beginning, or so on.
And after you're done, when you finished executing the last instruction, then you might output
something. That's really the basic way that a computer works. Just to recap, you have the
stored program computer that contains these sequences of instructions."
Lecture1_Chunk45,"stored program computer that contains these sequences of instructions.
The primitive operations that it can do are addition, subtraction, logic operations, tests-- which
are something equal to something else, something less than, and so on-- and moving data, so
storing data, moving data around, and things like that.
And the interpreter goes through every instruction and decides whether you're going to go to
the next instruction, skip instructions, or repeat instructions, and so on."
Lecture1_Chunk46,"the next instruction, skip instructions, or repeat instructions, and so on.
So we've talked about primitives. And in fact, Alan Turing, who was a really great computer
scientist, he showed that you can compute anything using the six primitives. And the six
primitives are move left, move right, read, write, scan, and do nothing.
Using those six instructions and the piece of tape, he showed that you can compute anything."
Lecture1_Chunk47,"Using those six instructions and the piece of tape, he showed that you can compute anything.
And using those six instructions, programming languages came about that created a more
convenient set of primitives. You don't have to program in only these six commands.
And one interesting thing, or one really important thing, that came about from these six
primitives is that if you can compute something in Python, let's say-- if you write a program that"
Lecture1_Chunk48,"primitives is that if you can compute something in Python, let's say-- if you write a program that
computes something in Python, then, in theory, you can write a program that computes the
exact same thing in any other language. And that's a really powerful statement.
Think about that today when you review your slides. Think about that again. That's really
powerful. Once you have your set of primitives for a particular language, you can start creating"
Lecture1_Chunk49,"powerful. Once you have your set of primitives for a particular language, you can start creating
expressions. And these expressions are going to be combinations of the primitives in the
programming language.
And the expressions are going to have some value. And they're going up some meaning in the
programming language. Let's do a little bit of a parallel with English just so you see what I
mean. In English, the primitive constructs are going to be words. There's a lot of words in the"
Lecture1_Chunk50,"mean. In English, the primitive constructs are going to be words. There's a lot of words in the
English language.
Programming languages-- in Python, there are primitives, but there aren't as many of them.
There are floats, Booleans, these are numbers, strings, and simple operators, like addition,
subtraction, and so on. So we have primitive constructs.
Using these primitive constructs, we can start creating, in English, phrases, sentences, and the"
Lecture1_Chunk51,"Using these primitive constructs, we can start creating, in English, phrases, sentences, and the
same in programming languages. In English, we can say something like, ""cat, dog, boy. That,
we say, is not syntactically valid. That's bad syntax. That's noun, noun, noun. That doesn't
make sense.
What does have good syntax in English is noun, verb, noun. So, ""cat, hugs boy"" is syntactically
valid. Similarly, in a programming language, something like this-- in Python, in this case-- a"
Lecture1_Chunk52,"valid. Similarly, in a programming language, something like this-- in Python, in this case-- a
word and then the number five doesn't really make sense. It's not syntactically valid. But
something like operator, operand, operator is OK.
So once you've created these phrases, or these expressions, that are syntactically valid, you
have to think about the static semantics of your phrase, or of your expression. For example, in
English, ""I are hungry"" is good syntax."
Lecture1_Chunk53,"English, ""I are hungry"" is good syntax.
But it's weird to say. We have a pronoun, a verb, and an adjective, which doesn't really make
sense. ""I am hungry"" is better. This does not have good static semantics.
Similarly, in programming languages-- and you'll get the hang of this the more you do it--
something like this, ""3.2 times 5, is OK. But what does it mean? What's the meaning to have a
word added to a number? There's no meaning behind that."
Lecture1_Chunk54,"word added to a number? There's no meaning behind that.
Its syntax is OK, because you have operator, operand, operator. But it doesn't really make
sense to add a number to a word, for example.
Once you have created these expressions that are syntactically correct and static,
semantically correct, in English, for example, you think about the semantics. What's the
meaning of the phrase? In English, you can actually have more than one meaning to an entire
phrase."
Lecture1_Chunk55,"meaning of the phrase? In English, you can actually have more than one meaning to an entire
phrase.
In this case, ""flying planes can be dangerous"" can have two meanings. It's the act of flying a
plane is dangerous, or the plane that is in the air is dangerous.
And this might be a cuter example. ""This reading lamp hasn't uttered a word since I bought it.
What's going on?"" So that has two meanings. It's playing on the word ""reading lamp."""
Lecture1_Chunk56,"What's going on?"" So that has two meanings. It's playing on the word ""reading lamp.""
That's in English. In English, you can have a sentence that has more than one meaning, that's
syntactically correct and static, semantically correct. But in programming languages, the
program that you write, the set of instructions that you write, only has one meaning.
Remember, we're coming back to the fact that the computer only does what you tell it to do."
Lecture1_Chunk57,"Remember, we're coming back to the fact that the computer only does what you tell it to do.
It's not going to suddenly decide to add another variable for some reason. It's just going to
execute whatever statements you've put up. In programming languages, there's only one
meaning.
But the problem that comes into play in programming languages is it's not the meaning that
you might have intended, as the programmer. That's where things can go wrong."
Lecture1_Chunk58,"you might have intended, as the programmer. That's where things can go wrong.
And there's going to be a lecture on debugging a little bit later in the course. But this is here
just to tell you that if you see an error pop up in your program, it's just some text that says,
error. For example, if we do something like this, this is syntactically correct. Incorrect.
Syntactically incorrect. See? There's some angry text right here. What is going on?"
Lecture1_Chunk59,"Syntactically incorrect. See? There's some angry text right here. What is going on?
The more you program, the more you'll get the hang of reading these errors. But this is
basically telling me the line that I wrote is syntactically incorrect. And it's pointing to the exact
line and says, this is wrong, so I can go back and fix it as a programmer.
Syntax errors are actually really easily caught by Python. That was an example of a syntax"
Lecture1_Chunk60,"Syntax errors are actually really easily caught by Python. That was an example of a syntax
error. Static semantic errors can also be caught by Python as long as, if your program has
some decisions to make, as long as you've gone down the branch where the static semantic
error happens.
And this is probably going to be the most frustrating one, especially as you're starting out. The
program might do something different than what you expected it to do. And that's not because"
Lecture1_Chunk61,"program might do something different than what you expected it to do. And that's not because
the program suddenly-- for example, you expected the program to give you an output of 0 for
a certain test case, and the output that you got was 10.
Well, the program didn't suddenly decide to change its answer to 10. It just executed the
program that you wrote. That's the case where the program gave you a different answer than
expected."
Lecture1_Chunk62,"program that you wrote. That's the case where the program gave you a different answer than
expected.
Programs might crash, which means they stop running. That's OK. Just go back to your code
and figure out what was wrong. And another example of a different meaning than what you
intended was maybe the program won't stop. It's also OK. There are ways to stop it besides
restarting the computer.
So then Python programs are going to be sequences of definitions and commands. We're"
Lecture1_Chunk63,"So then Python programs are going to be sequences of definitions and commands. We're
going to have expressions that are going to be evaluated and commands that tell the
interpreter to do something.
If you've done problem set 0, you'll see that you can type commands directly in the shell here,
which is the part on the right where I did some really simple things, 2 plus 4. Or you can type
commands up in here, on the left-hand side, and then run your program."
Lecture1_Chunk64,"commands up in here, on the left-hand side, and then run your program.
Notice that, well, we'll talk about this-- I won't talk about this now. But these are-- on the right-
hand side, typically, you write very simple commands just if you're testing something out. And
on the left-hand side here in the editor, you write more lines and more complicated programs.
Now we're going to start talking about Python. And in Python, we're going to come back to this,"
Lecture1_Chunk65,"Now we're going to start talking about Python. And in Python, we're going to come back to this,
everything is an object. And Python programs manipulate these data objects. All objects in
Python are going to have a type.
And the type is going to tell Python the kinds of operations that you can do on these objects. If
an object is the number five, for example, you can add the number to another number,
subtract the number, take it to the power of something, and so on."
Lecture1_Chunk66,"subtract the number, take it to the power of something, and so on.
As a more general example, for example, I am a human. So that's my type. And I can walk,
speak English, et cetera. Chewbacca is going to be a type Wookie. He can walk, do that sound
that I can't do. He can do that, but I can't. I'm not even going to try, and so on.
Once you have these Python objects, everything is an object in Python. There are actually two"
Lecture1_Chunk67,"Once you have these Python objects, everything is an object in Python. There are actually two
types of objects. One are scalar objects. That means these are very basic objects in Python
from which everything can be made. These are scalar objects. That can't be subdivided.
The other type of object is a non-scalar object. And these are objects that have some internal
structure. For example, the number five is a scalar object because it can't be subdivided."
Lecture1_Chunk68,"structure. For example, the number five is a scalar object because it can't be subdivided.
But a list of numbers, for example, 5, 6, 7,8, is going to be a non-scalar object because you
can subdivide it. You can subdivide it into-- you can find parts to it. It's made up of a sequence
of numbers.
Here's the list of all of the scalar objects in Python. We have integers, for example, all of the
whole numbers. Floats, which are all of the real numbers, anything with a decimal."
Lecture1_Chunk69,"whole numbers. Floats, which are all of the real numbers, anything with a decimal.
Bools are Booleans. There's only two values to Booleans. That's True and False. Note the
capitalization, capital T and capital F. And this other thing called NoneType. It's special. It has
only one value called None. And it represents the absence of a type. And it sometimes comes
in handy for some programs.
If you want to find the type of an object, you can use this special command called type. And"
Lecture1_Chunk70,"If you want to find the type of an object, you can use this special command called type. And
then in the parentheses, you put down what you want to find the type of. You can write into the
shell ""type of 5,"" and the shell will tell you, that's an integer.
If you happen to want to convert between two different types, Python allows you to do that.
And to do that, you put the type that you want to convert to right before the object that you"
Lecture1_Chunk71,"And to do that, you put the type that you want to convert to right before the object that you
want to convert to. So float(3) will convert the integer 3 to the float 3.0.
And similarly, you can convert any float into an integer. And converting to an integer just
truncates. It just takes away the decimal and whatever's after it-- it does not round-- and keeps
just the integer part.
For this slide, I'm going to talk about it. But if you'd like if you have the slides up, go to go to"
Lecture1_Chunk72,"For this slide, I'm going to talk about it. But if you'd like if you have the slides up, go to go to
this exercise. And after I'm done talking about the slide, we'll see what people think for that
exercise.
One of the most important things that you can do in basically any programming, in Python
also, is to print things out. Printing out is how you interact with the user.
To print things out, you use the print command. If you're in the shell, if you simply type ""3 plus"
Lecture1_Chunk73,"To print things out, you use the print command. If you're in the shell, if you simply type ""3 plus
2,"" you do see a value here. Five, right? But that's not actually printing something out.
And that becomes apparent when you actually type things into the editor. If you just do ""3 plus
2,"" and you run the program-- that's the green button here-- you see on the right-hand side
here, it ran my program. But it didn't actually print anything."
Lecture1_Chunk74,"here, it ran my program. But it didn't actually print anything.
If you type this into the console, it does show you this value, but that's just like peeking into the
value for you as a programmer. It's not actually printing it out to anyone. If you want to print
something out, you have to use the print statement like that. In this case, this is actually going
to print this number five to the console."
Lecture1_Chunk75,"to print this number five to the console.
That's basically what it says. It just tells you it's an interaction within the shell only. It's not
interacting with anyone else. And if you don't have any ""Out,"" that means it got printed out to
the console.
All right. We talked a little bit about objects. Once you have objects, you can combine objects
and operators to form these expressions. And each expression is going to have a value. So an"
Lecture1_Chunk76,"and operators to form these expressions. And each expression is going to have a value. So an
expression evaluates to a value. The syntax for an expression is going to be object, operator,
object, like that.
And these are some operators you can do on ints and floats. There's the typical ones,
addition, subtraction, multiplication, and division. If, for the first three, the answer that you get--
the type of the answer that you get-- is going to depend on the type of your variables. If both"
Lecture1_Chunk77,"the type of the answer that you get-- is going to depend on the type of your variables. If both
of the variables of the operands are integers, then the result you're going to get is of type
integer.
But if at least one of them is a float, then the result you're going to get is a float. Division is a
little bit special in that no matter what the operands are, the result is always going to be a float.
The other operations you can do, and these are also useful, are the remainder, so the percent"
Lecture1_Chunk78,"The other operations you can do, and these are also useful, are the remainder, so the percent
sign. If you use the percent sign between two operands, that's going to give you the remainder
when you divide i by j.
And raising something to the power of something else is using the star star operator. And i star
stars j is going to take i to the power of j.
These operations have the typical precedence that you might expect in math, for example."
Lecture1_Chunk79,"These operations have the typical precedence that you might expect in math, for example.
And if you'd like to put precedence toward some other operations, you can use parentheses to
do that.
All right. So we have ways of creating expressions. And we have operations we can do on
objects. But what's going to be useful is to be able to save values to some name. And the
name is going to be something that you pick."
Lecture1_Chunk80,"name is going to be something that you pick.
And it should be a descriptive name. And when you save the value to a name, you're going to
be able to access that value later on in your program. And that's very useful.
To save a value to a variable name, you use the equal sign. And the equal sign is an
assignment. It assigns the right-hand side, which is a value, to the left-hand side, which is
going to be a variable name. In this case, I assigned the float 3.14159 to the variable pi."
Lecture1_Chunk81,"going to be a variable name. In this case, I assigned the float 3.14159 to the variable pi.
And in the second line, I'm going to take this expression, 22 divided by 7, I'm going to evaluate
it. It's going to come up with some decimal number. And I'm going to save it into the variable
pi_approx. values are stored in memory. And this assignment in Python, we say the
assignment binds the name to the value.
When you use that name later on in your program, you're going to be referring to the value in"
Lecture1_Chunk82,"When you use that name later on in your program, you're going to be referring to the value in
memory. And if you ever want to refer to the value later on in your code, you just simply type
the name of the variable that you've assigned it to.
So why do we want to give names to expressions? Well, you want to reuse the names instead
of the values. And it makes your code look a lot nicer. This is a piece of code that calculates"
Lecture1_Chunk83,"of the values. And it makes your code look a lot nicer. This is a piece of code that calculates
the area of a circle. And notice, I've assigned a variable pi to 3.14159. I've assigned another
variable called radius to be 2.2.
And then, later on in my code, I have another line that says area-- this is another variable-- is
equal to-- this is an assignment-- to this expression. And this expression is referring to these
variable names, pi and radius."
Lecture1_Chunk84,"variable names, pi and radius.
And it's going look up their values in memory. And it's going to replace these variable names
with those values. And it's going to do the calculation for me. And in the end, this whole
expression is going to be replaced by one number. And it's going to be the float.
Here's another exercise, while I'm talking about the slide. I do want to make a note about
programming versus math."
Lecture1_Chunk85,"programming versus math.
In math, you're often presented with a problem that says, solve for x. x plus y is equal to
something something. Solve for x, for example. That's coming back to the fact that computers
don't know what to do with that. Computers need to be told what to do.
In programming, if you want to solve for x, you need to tell the computer exactly how to solve
for x. You need to figure out what formula you need to give the computer in order to be able to
solve for x."
Lecture1_Chunk86,"solve for x.
That means always in programming the right-hand side is going to be an expression. It's
something that's going to be evaluated to a value. And the left-hand side is always a variable.
It's going to be an assignment.
The equal sign is not like in math where you can have a lot of things to the left and a lot of
things to the right of the equal sign. There's only one thing to the left of the equal sign. And
that's going to be a variable. An equal sign stands for an assignment."
Lecture1_Chunk87,"that's going to be a variable. An equal sign stands for an assignment.
Once we've created expressions, and we have these assignments, you can rebind variable
names using new assignment statements. Let's look at an example for that. Let's say this is
our memory. Let's type back in the example with finding the radius.
Let's say, pi is equal to 3.14. In memory, we're going to create this value 3.14. We're going to"
Lecture1_Chunk88,"Let's say, pi is equal to 3.14. In memory, we're going to create this value 3.14. We're going to
bind it to the variable named pi. Next line, radius is equal to 2.2. In memory, we're creating this
value 2.2. And we're going to bind it to the variable named radius.
Then we have this expression here. It's going to substitute the values for pi from memory and
the value for radius from memory. It's going to calculate the value that this expression
evaluates to."
Lecture1_Chunk89,"evaluates to.
It's going to pop that into the memory. And it's going to assign-- because we're using the equal
sign-- it's going to assign that value to that variable area.
Now, let's say we rebind radius to be something else. Radius i is bound to the value 2.2. But
when we do this line, radius is equal to radius plus 1, we're going to take away the binding to
2.2. We're going to do this calculation. The new value is 3.2."
Lecture1_Chunk90,"2.2. We're going to do this calculation. The new value is 3.2.
And we're going to rebind that value to that same variable. In memory, notice we're still going
to have this value, 2.2, floating around. But we've lost the handle for it. There's no way to get it
back. It's just in memory sitting there. At some point, it might get collected by what we call the
garbage collector. In Python, And it'll retrieve these lost values, and it'll reuse them for new
values, and things like that."
Lecture1_Chunk91,"values, and things like that.
But radius now points to the new value. We can never get back 2.2. And that's it. The value of
area-- notice, this is very important. The value of area did not change. And it did not change
because these are all the instructions we told the computer to do.
We just told it to change radius to be radius plus 1. We never told it to recalculate the value of
area. If I copied that line down here, then the value of area would change. But we never told it"
Lecture1_Chunk92,"area. If I copied that line down here, then the value of area would change. But we never told it
to do that. The computer only does what we tell it to do.
That's the last thing. Next lecture, we're going to talk about adding control flow to our
programs, so how do you tell the computer to do one thing or another? All right."
Lecture2_Chunk1,"MITOCW | watch?v=0jljZRnHwOI
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
PROFESSOR:
All right. Let's get started, everyone. So, good afternoon. Welcome to the second lecture of"
Lecture2_Chunk2,"All right. Let's get started, everyone. So, good afternoon. Welcome to the second lecture of
60001 and also of 600. So as always, if you'd like to follow along with the lectures, please go
ahead and download the slides and the code that I'll provide at least an hour before class
every day. All right.
So a quick recap of what we did last time. So last time, we talked a little bit about what a
computer is. And I think the main takeaway from the last lecture is really that a computer only"
Lecture2_Chunk3,"computer is. And I think the main takeaway from the last lecture is really that a computer only
does what it is told, right? So it's not going to spontaneously make decisions on its own. You,
as the programmer, have to tell it what you want it to do by writing programs. OK. So we talked
about simple objects. And these objects were of different types. So we saw integers, floats,
and Booleans. And then we did a couple of simple operations with them."
Lecture2_Chunk4,"and Booleans. And then we did a couple of simple operations with them.
Today, we're going to look at a different-- a new type of object called a string. And then we're
going to introduce some more powerful things in our programming toolbox. So we're going to
look at how to branch within a program, and how to make things-- how to make the computer
repeat certain tasks within our program.
All right. So let's begin by looking at strings. So strings are a new object type. We've seen so"
Lecture2_Chunk5,"All right. So let's begin by looking at strings. So strings are a new object type. We've seen so
far integers, which were whole numbers, floats, which were decimal numbers, and we have
seen Booleans, which were true and false. So strings are going to be sequences of
characters. And these characters can be anything. They can be letters, digits, special
characters, and also spaces. And you tell Python that you're talking about a string object by"
Lecture2_Chunk6,"characters, and also spaces. And you tell Python that you're talking about a string object by
enclosing it in quotation marks. So in this case, I'm creating an object whose value is h-e-l-l-o
space t-h-e-r-e.
And Python knows it's a string object, because we're enclosing it in quotations. They can be
either double quotes or single quotes, but as long as you're consistent, it doesn't matter. And
this object, we're binding it to this variable named hi. And we're using that using the equals"
Lecture2_Chunk7,"this object, we're binding it to this variable named hi. And we're using that using the equals
sign, which is the assignment operator. So from now on, whenever we refer to this variable hi,
Python is going to say, oh, I know what the value is, and it's that string of characters.
So we're going to learn about two things that you can do on strings today, two operations. One
is to concatenate them. And concatenation is really just a fancy word for using this plus"
Lecture2_Chunk8,"is to concatenate them. And concatenation is really just a fancy word for using this plus
operator, which means put the strings together. So I have this original variable named hi, and I
create a new variable called name. And in it, I'm going to assign the string a-n-a to the variable
name. And when I use the plus operator in between hi and name, those two variables, Python
is going to look at the values of those two, and it's going to just put them together."
Lecture2_Chunk9,"is going to look at the values of those two, and it's going to just put them together.
OK. I'm going to switch to Spider. And this is just that example from the slides. So let's see
what happens. So I have the variable hi, the variable name, and I'm just concatenating those
two together. And then I'm going to print that out. So if I run the code, notice it prints out ""hello
thereana."" There's no space. And there's no space because the concatenation operator, the"
Lecture2_Chunk10,"thereana."" There's no space. And there's no space because the concatenation operator, the
plus, doesn't add any spaces implicitly. So again, another example of just computer just doing
what it's told. If we want to add a space, we'd have to actually insert the space manually. So
that's this line here, line 8. And in this line, we're concatenating the value of the variable hi with
a space. Notice we're putting it in quotation marks. Just a space. And then with name."
Lecture2_Chunk11,"a space. Notice we're putting it in quotation marks. Just a space. And then with name.
So if we'll go ahead and print that value, notice this was that garbage greeting there. And now
we have a proper greeting, right? So that's the concatenation between strings.
And then the other thing we're going to look at related to strings is the star operator. So that's
this one here on line 10. So Python allows you to use the star operator, which stands for"
Lecture2_Chunk12,"this one here on line 10. So Python allows you to use the star operator, which stands for
multiplication, between a string and a number. And when you do that, Python interprets it as
repeat that string that many number of times. So in this case, I'm creating a silly greeting, and
I'm concatenating the value of hi, which is ""hello there"" with the space plus the name. So
notice here, I'm using parentheses to tell Python, do this operation first, and then multiply"
Lecture2_Chunk13,"notice here, I'm using parentheses to tell Python, do this operation first, and then multiply
whatever the result of this is by 3. So if I print that out, it's going to multiply the space with my
name three times, and it's going to concatenate that with ""hello there."" So that's exactly what it
printed out there.
Last lecture, we talked a little bit about print. Today, I'm going to talk about some nuances"
Lecture2_Chunk14,"Last lecture, we talked a little bit about print. Today, I'm going to talk about some nuances
related to print. So you use print to interact with the user. It's cool to write programs that print
things out to the user. So the key word here being print. And then you put parentheses after
print. And in the parentheses, you put in whatever you want to show the user.
So in this little program, I have-- I created a variable named x. I assigned it the value 1, and"
Lecture2_Chunk15,"So in this little program, I have-- I created a variable named x. I assigned it the value 1, and
then I print 1. Here, I'm casting. So I'm taking the number one, the integer 1, and I'm casting it
to a string. And you'll see why in a moment.
So I want to bring to your attention a couple of things here. So in the first print, I'm using
commas everywhere here. And in the second print, I'm using plus. So by definition, if you-- you"
Lecture2_Chunk16,"commas everywhere here. And in the second print, I'm using plus. So by definition, if you-- you
can use commas inside a print-- inside the parentheses of print. And if you use a comma,
Python is going to automatically add a space in between the two things that the comma is in
between, the values. So ""my fav num is"" is the first thing. And the second thing is whatever's
after the comma. Let's take x. So if you use a comma, Python is going to automatically insert a
space for you."
Lecture2_Chunk17,"space for you.
Sometimes, you might want that, sometimes you might not. If you don't want that, you can use
the concatenation operation, the plus. And you can add all of your little bits together to create
one big string. If you're using commas, the items, the objects in between the commas, do not
all have to be strings. That's the plus side of using commas. But the downside is you get
spaces everywhere. If you use plus operator, the plus side is Python does exactly what you tell"
Lecture2_Chunk18,"spaces everywhere. If you use plus operator, the plus side is Python does exactly what you tell
it to do, but everything has to be a string object. So ""my fav num is"" is a string object. You
have to convert all of your numbers to string objects, and so on.
So if we look at Spider-- This is the same-- almost the same code. So here, I don't have
spaces anywhere. So you can see that the first line here has commas everywhere. So I'm"
Lecture2_Chunk19,"spaces anywhere. So you can see that the first line here has commas everywhere. So I'm
going to have spaces in between every one of the things that I'm printing out. This line here is
sort of a combination between commas and concatenation. So depending on where I used the
comma, I'm going to have an extra space. And this line here just has concatenation
everywhere. So if I run this, notice this very first line added spaces everywhere in between all"
Lecture2_Chunk20,"everywhere. So if I run this, notice this very first line added spaces everywhere in between all
my objects. The second one added spaces somewhere. And you can sort of trace through and
see exactly where the spaces were added. And the last line here didn't add spaces anywhere.
So printing things out to the console is nice, but the second part of sort of writing an interactive
program is getting input from the user. And that's the more interesting part. So if you've done"
Lecture2_Chunk21,"program is getting input from the user. And that's the more interesting part. So if you've done
problem set 0, you might have sort of already tried to understand this on your own. But here
we are. So the way you get input from the user is using this command function called input.
And inside the parentheses, you type in whatever you'd like to prompt the user with. So in this
case, in my example here, I have input, and then here I said ""type anything."" So the user is"
Lecture2_Chunk22,"case, in my example here, I have input, and then here I said ""type anything."" So the user is
going to see this text here, and then the program is just going to stop. And it's going to wait for
the user to type in something and hit Enter. As soon as the user types in Enter, whatever the
user types in becomes a string. If a user types in a number, for example, that becomes the
string of that number. So everything the user types in is going to be made as a string."
Lecture2_Chunk23,"string of that number. So everything the user types in is going to be made as a string.
In this line right here, whatever these the user types in becomes a string. And we're going to
bind that string object to this variable named text. So now, further in my program, I could do
whatever I want with this variable text. In this case, I'm going to print 5*text. OK. So if the user,
for example, gave me ""ha,"" I'm going to print ""ha"" 5 times. If the user gave me 5, what do you"
Lecture2_Chunk24,"for example, gave me ""ha,"" I'm going to print ""ha"" 5 times. If the user gave me 5, what do you
think the user is-- what do you think is going to be printed out? 25 or 5 five times? Great. Yes.
Exactly. 5 five times.
Oftentimes, you don't want to work with numbers as strings, right? You want to work with
numbers as numbers, right? So you have to cast. And we learned that last lecture. You cast by
just putting in this little bit right in front of the input. And you can cast it to whatever type you"
Lecture2_Chunk25,"want. Here I cast it to an int, but you can also cast to a float if you want to work with floats. And
that converts whatever the user typed in, as long as it's some number that Python knows how
to convert, into the number itself. So in this case, if the user gives me 5, I'm going to print out 5
times 5 instead of 5 five times. So that's the code here.
So the first bit is I'm going to get the user to type in anything, and I'm going to put 555. And"
Lecture2_Chunk26,"So the first bit is I'm going to get the user to type in anything, and I'm going to put 555. And
then when I type in the number, since I'm casting it, I'm going to do operations with the
number. Yeah, question.
AUDIENCE:
[INAUDIBLE]
PROFESSOR:
Why do you want to cast to-- oh. The question is why do you want to cast to a string? Why do
you want to cast a string to a number?
AUDIENCE:
[INAUDIBLE]
PROFESSOR:
Oh, so Python always-- whatever you type in, just by default, by definition of the input"
Lecture2_Chunk27,"PROFESSOR:
Oh, so Python always-- whatever you type in, just by default, by definition of the input
command, Python always makes it a string. So if you want to work with numbers, you have to
explicitly tell it, I'm going to work with a number. So even if you give it the number 5, it's going
to think it's the string 5. Yeah. That's just how input works.
The next thing we're going to look at is ways that you can start adding tests in your code. And"
Lecture2_Chunk28,"The next thing we're going to look at is ways that you can start adding tests in your code. And
before you can start adding tests in your code, you need to be able to do the actual tests. So
this is where comparison operators come in. So here, let's assume that i and j are variables.
The following comparisons are going to give you a Boolean. So it's either going to say, this is
true or this is false. So that's going to be your test."
Lecture2_Chunk29,"true or this is false. So that's going to be your test.
So if i and j are variables, you're allowed to compare ints with ints, floats with floats, strings
with strings. And you're allowed to compare ints and floats between themselves, but you're not
allowed to compare a string with a number. In fact, if you even try to do that in Python-- in
Spider here, if I try to say, is the letter a greater than 5? I get some angry text right here. And"
Lecture2_Chunk30,"Spider here, if I try to say, is the letter a greater than 5? I get some angry text right here. And
this just tells me Python doesn't understand the meaning of-- how do I compare a string with a
number?
OK. So just like in math, we can do these usual comparisons. We can say if something is
greater than something, greater or equal to, less than, less than or equal to. I'd like to bring to
your attention the equality. So the single equals sign is an assignment. So you're taking a"
Lecture2_Chunk31,"your attention the equality. So the single equals sign is an assignment. So you're taking a
value, and you're assigning it to a variable. But when you're doing the double equals sign, this
is the test for equality. Is the value of variable i the same as the value of the variable j? And
that's, again, also going to give you a Boolean either true or false. And you can also test for
inequality with the exclamation equal. So that means, is the value of the variable i not equal to"
Lecture2_Chunk32,"inequality with the exclamation equal. So that means, is the value of the variable i not equal to
the value of the variable j? True if yes, false if no.
OK. So those are comparison operators on integer, floats, and strings. On Booleans, you can
do some logic operators. And the simplest is just inverting. So if a is a variable that has a
Boolean value, not a is just going to invert it. So if a is true, then not a is false, and vice versa."
Lecture2_Chunk33,"This is a table that sort of represents what I've said here. So you can do-- you can use and
and or. These are key words in Python. You can use those two key words on variables, on
Boolean variables. And you get the result a and b is only true if both a and b are true. And a or
b is only false if a and b are false. And this is the complete table just in case you need to
reference it.
All right. So now that we have ways to do logical-- question right there.
AUDIENCE:
[INAUDIBLE]
PROFESSOR:"
Lecture2_Chunk34,"AUDIENCE:
[INAUDIBLE]
PROFESSOR:
Yeah, great question. So what does it mean to compare a string with a string with the greater
than? So that's just going to compare them, lexicographically. So does it come first in the
alphabet? So we can even test that out. We can say, is a greater than b? And it's false. So b
comes later in the alphabet than a.
OK. So now we have ways to do the tests. So we can add some branching to our"
Lecture2_Chunk35,"OK. So now we have ways to do the tests. So we can add some branching to our
programming toolbox now that we have ways to do tests. This is a map of MIT. I'm going to go
through sort of a little example to motivate why we would want to do branching in our code.
And I think after this lecture, you'll be able to sort of code up this algorithm that I'm going to
explain. So most of us see MIT as a maze. I first did when I came here. When I first came"
Lecture2_Chunk36,"explain. So most of us see MIT as a maze. I first did when I came here. When I first came
here, obviously, I signed up for the free food mailing list. And MIT, being a maze, I had no idea
where to go, what the shortest path was to free food. So one way to think about it is all I
wanted to do was get to the free food.
A very simple algorithm to get there would be to say, OK, I'm going take my right hand, and
I'm going to make sure that my right hand is always on a wall. And I'm going to go around"
Lecture2_Chunk37,"I'm going to make sure that my right hand is always on a wall. And I'm going to go around
campus with my right hand always being at a wall. And eventually, I'll get to where the free
food is. There might not be any left, right? But I'll be there. So the algorithm is as follows. If my
right hand always has to be on a wall, then I'm going to say, if there's no wall to my right side,
then I'm going to go right until I get to a wall. Then if there's a wall to my right, and I can go"
Lecture2_Chunk38,"then I'm going to go right until I get to a wall. Then if there's a wall to my right, and I can go
forward, I'm just going to keep going forward. If I keep going forward, and there's a wall to my
right and in front of me, I'm going to turn around and go left. And then if there's a wall to my
right, in front of me, and to the left, then I'm going to turn around and go back.
So with this fairly simple algorithm, I just follow the path always keeping the wall to my right."
Lecture2_Chunk39,"So with this fairly simple algorithm, I just follow the path always keeping the wall to my right.
And eventually, I would end up where I need to be. So notice, I used, just in plain English, a
few key words. If, otherwise, things like that. So in programming, we have those same
constructs. And those same sort of intuitive words can be used to tell Python to do something
or to do something else or to choose from a different set of possibilities. And this way, we can"
Lecture2_Chunk40,"or to do something else or to choose from a different set of possibilities. And this way, we can
get the computer to make decisions for us. And you might be thinking, well, you said that
computers can't make decisions on their own. It's not. You, as programmers, are going to
build these decisions into the program, and all the computer is going to do is going to reach
the decision point and say, OK, this is a decision point, should I go left or should I go right? Or"
Lecture2_Chunk41,"the decision point and say, OK, this is a decision point, should I go left or should I go right? Or
which one do I pick? And these sort of decisions are created by you as a programmer. And the
computer just has to make the decision and choose a path.
OK. So in programming, there's three sort of simple ways that you can add control flow to your
programs. And that's making one decision and choosing whether to execute something or"
Lecture2_Chunk42,"programs. And that's making one decision and choosing whether to execute something or
execute something else. The first is a simple if. And given a program that just linearly has
statements that get executed, whenever I reach an if statement, you're going to check the
condition. The condition is going to be something that's going to get evaluated to either true or
false.
So I've reached the condition here. And if the condition is true, then I'm going to additionally"
Lecture2_Chunk43,"So I've reached the condition here. And if the condition is true, then I'm going to additionally
execute this extra set of expressions. But if the condition is false, then I'm just going to keep
going through the program and not execute that extra set of instructions. How does Python
know which instructions to execute? They're going to be inside this what we call code block.
And the code block is denoted by indentation. So it's going to be everything that's indented is"
Lecture2_Chunk44,"And the code block is denoted by indentation. So it's going to be everything that's indented is
part of that if code block. Typically, four spaces is indentation.
OK. So that's how you write code that decides whether to execute this extra thing or not. Now
let's say I don't just want to execute an extra thing, I want to reach a point where I say, I'll
either go down this path or I'll do something else. That's this right here. So this if else construct"
Lecture2_Chunk45,"says this is my code, I've reached my decision point here, if the condition inside the if is true,
then I'm going to execute maybe this set of statements here. But if the condition is not true,
then I'm not going to execute that set of statements, and instead I'm going to execute under
whatever else is. So using this construct, I'm either going to do one set of expressions or the
other, but never both. And after I've executed one or the other, I'm going to continue on with"
Lecture2_Chunk46,"other, but never both. And after I've executed one or the other, I'm going to continue on with
just the regular execution of the program.
OK. So we're able to either choose one thing, choose one thing or another, but what if we
want to have more than one choice? So if some number is equal to zero, I want to do this. If
it's equal to 1, I want to do this. If it's equal to 2, I want to do this, and so on. That's where this"
Lecture2_Chunk47,"last one comes in. And we introduced this other key word here called elif. So that stands for
short form for else if. So first we check if this condition is true. So we're going through our
program, we've reached our decision point, if the condition is true, we're going to execute
maybe this set of instructions. If the condition is not true, maybe we'll check-- if the condition is
not true, we will check this next condition. That's part of the elif right here. And if that one's"
Lecture2_Chunk48,"not true, we will check this next condition. That's part of the elif right here. And if that one's
true, we're going to execute a different set of instructions. You can have more than one elif.
And depending on which one's true, you're going to execute a different set of instructions. And
then this last else is sort of a catch all where if none of the previous conditions were true, then
just do this last set of expressions."
Lecture2_Chunk49,"just do this last set of expressions.
So in this case, you're going to choose between one of these three-- one of these four roots,
or however many you have. And then when you're done making your choice, you're going to
execute the remaining set of instructions. So the way this works is if more than one condition is
true, you're actually just going to enter one of them. And you're going to enter the very first"
Lecture2_Chunk50,"true, you're actually just going to enter one of them. And you're going to enter the very first
one that's true. So you're never going to enter more than one of these code blocks. You
always enter one, and you enter the first one that evaluates to true.
So notice that we denoted code blocks using indentation. And that's actually one of the things
that I really like about Python. It sort of forces you to write pretty code and nice looking code"
Lecture2_Chunk51,"that I really like about Python. It sort of forces you to write pretty code and nice looking code
and just code that's very readable. And that forces you to indent everything that's a code
block. So you can easily see sort of where the flow of control is and where decision making
points are and things like that. So in this particular example, we have one if statement here,
and it checks if two variables are equal. And we have an if, elif, else. And in this example,"
Lecture2_Chunk52,"and it checks if two variables are equal. And we have an if, elif, else. And in this example,
we're going to enter either this code block or this one or this one, depending on the variables
of x and y. And we're only going into one code block. And we'll enter the first one that's true.
Notice you can have nested conditionals. So inside this first if, we have another if here. And
this inner if is only going to be checked when we enter the first-- this outter if. I do want to"
Lecture2_Chunk53,"this inner if is only going to be checked when we enter the first-- this outter if. I do want to
make one point, though. So sometimes, you might forget to do the double equals sign when
you are checking for equality, and that's OK. If you just use one equals sign, Python's going to
give you an error. And it's going to say syntax error, and it's going to highlight this line. And
then you're going to know that there's a mistake there. And you should be using equality,"
Lecture2_Chunk54,"then you're going to know that there's a mistake there. And you should be using equality,
because it doesn't make sense to be using-- to assign-- to be making an assignment inside
the if.
So we've learned about branching. And we know about conditionals. Let's try to apply this to a
little game. And spoiler, we won't be able to. We'll have to learn about a new thing. But back in
the 1980s, there was the Legend of Zelda-- cool graphics-- where there was a scene with the"
Lecture2_Chunk55,"the 1980s, there was the Legend of Zelda-- cool graphics-- where there was a scene with the
lost woods. Oversimplification if anyone's a Zelda die hard fan. But the basic idea was if you
entered the woods, you entered from the left to the right. And then as long as you kept going
right, it would show you the same screen over and over again. And the trick was you just had
to go backward, and then you'd exit the woods. So very simple."
Lecture2_Chunk56,"to go backward, and then you'd exit the woods. So very simple.
Using what we know so far, we could sort of code this up. And we'd say something like this. If
the user exits right, then set the background to the woods background. Otherwise, set the
background to the exit background. Now let's say the user-- and then in the else, we're done.
Let's say the user went right. Well, you'd show them the woods background, and now ask"
Lecture2_Chunk57,"Let's say the user went right. Well, you'd show them the woods background, and now ask
them again, where do they want to go? If they exit right, set the background to the woods
background. Otherwise, set the background to the exit background, and so on.
So you notice that there's sort of no end to this, right? How many times-- do you know how
many times the user might keep going right? They might be really persistent, right? And they'll"
Lecture2_Chunk58,"many times the user might keep going right? They might be really persistent, right? And they'll
be like maybe if I go 1,000 times, I'll get out of the woods. Maybe 1,001? Maybe. So this would
probably be-- who knows how deep? These nested ifs. So we don't know. So with what we
know so far, we can't really code this cute little game.
But enter loops. And specifically, a while loop. So this code here that could be infinitely number"
Lecture2_Chunk59,"But enter loops. And specifically, a while loop. So this code here that could be infinitely number
of nested if statements deep can be rewritten using these three lines. So we say while the user
exits right, set the background to the woods background. And with a while loop, it's going to do
what we tell it to do inside the loop, and then it's going to check the condition again, and then
it's going to do what we say it should do inside the code block, and it's going to check the"
Lecture2_Chunk60,"it's going to do what we say it should do inside the code block, and it's going to check the
condition again. And then when the condition-- as long as a condition is true, it's going to keep
doing that little loop there. And as soon as the condition becomes false, it's going to stop doing
the loop and do whatever's right after the while.
OK. So that's basically how a while loop works. We have while. That's the key word. The"
Lecture2_Chunk61,"OK. So that's basically how a while loop works. We have while. That's the key word. The
condition is something that gets evaluated to true or false. And once again, we have a code
block that's indented, and it tells Python, these are the expressions I want to do as long as the
condition is true. So the condition is true, you evaluate every expression in the code block.
When you reach the end of the expression-- end of the code block, you check the condition"
Lecture2_Chunk62,"When you reach the end of the expression-- end of the code block, you check the condition
again. If it's true still, you keep doing the expressions. Check it again, and so on.
So here's a little game. And with these lines of code, we were able-- we can code up the lost
woods of Zelda. Even worse graphics, by the way than the original Zelda is this one that I
coded up here. So I print out the following things. ""You're in the Lost Forest. Go left or right."""
Lecture2_Chunk63,"coded up here. So I print out the following things. ""You're in the Lost Forest. Go left or right.""
And my program's going to say, ""You're in the Lost Forest. Go left or right."" It's going to get
user input. It's going to say while the user keeps typing in right, show them this text, and ask
them again. So I'm asking them again by just saying input here again. And that's it. That's
going to just keep getting input from the user. And if the user doesn't type in right, and maybe"
Lecture2_Chunk64,"going to just keep getting input from the user. And if the user doesn't type in right, and maybe
types in left, you're going to exit out of this loop, and print out, ""You've got out of the Lost
Forest.""
So I have to show you this, because I spent too much time on it. But I decided to improve on
the code that's in the slides. And I've written here ways that you guys can also improve it. So if
I run my code-- ""You're in the Lost Forest. Go left or right."" So if I say left, then yay, I got out of"
Lecture2_Chunk65,"the Lost Forest. But if I go right, then I'm stuck, right? I took down some trees. You can see
there's no more trees here. I made a table, and then I flipped it over.
So the expansion to this if you want to try it out-- I put this in the comments here-- is try to use
a counter. If the user types in right the first two times, just make that a sad face. But if the user
types in more than two times, make them cut down some trees and build a table and flip it."
Lecture2_Chunk66,"types in more than two times, make them cut down some trees and build a table and flip it.
That's a cute little expansion if you want to test yourself to make sure you are getting loops.
OK. So so far, we've used while loops to ask for user input. And that's actually somewhere
where it makes sense to use while loops, because you don't actually know how many times
the user is going to type in something. You can use while loops to keep sort of a counter and"
Lecture2_Chunk67,"the user is going to type in something. You can use while loops to keep sort of a counter and
to write code that counts something. If you do that, though, there's two things you need to take
care of. The first is the first line here, which is sort of an initialization of this loop counter. And
the second is this line here, which is incrementing your loop counter.
The reason why the second one is important is because-- let's look at our condition here. So"
Lecture2_Chunk68,"The reason why the second one is important is because-- let's look at our condition here. So
while n is less than five. If you didn't have this line here, you would never increment n. So
every time through the loop, you just keep printing zeros. And you would have an infinite loop.
I do want to show, though, what-- if you do have an infinite loop, it's not the end of the world.
So I can say something like-- so while true, print zero. So this is going to give me an infinite"
Lecture2_Chunk69,"So I can say something like-- so while true, print zero. So this is going to give me an infinite
loop in my program. And-- whoop. OK. So notice it's just printing the letter p over and over
again. And if I let it go any longer, it's going to slow down the computer. So I'm going to hit
Control-C or Command-C maybe. And it's going to stop the program from printing. So just in
case you ever enter infinite loops in your programs, just go to the console and hit Control-C,"
Lecture2_Chunk70,"case you ever enter infinite loops in your programs, just go to the console and hit Control-C,
and that's going to stop it from sort of slowing down the computer.
OK. So going back to this example, I was saying that if you're using counters-- variables in
order to sort of count up inside the while loop, you have to take care to initialize a counter
variable first. And then to increment it, otherwise you'll enter an infinite loop. That feels a little"
Lecture2_Chunk71,"bit tedious. And so there's a shortcut for doing that exact same thing.
So these four lines, you can rewrite those into these two lines right here using this new type of
loop called a for loop. So the for loop says, for some loop variable-- in this case, I named it n.
You can name it whatever you want. In range 5-- we're going to come back to what range
means in a little bit-- print n. So every time through the loop, you're going to print out what the"
Lecture2_Chunk72,"means in a little bit-- print n. So every time through the loop, you're going to print out what the
value of n is. Range 5 actually creates internally a sequence of numbers starting from 0 and
going to that number 5 minus 1.
So the sequence is going to be 0, 1, 2, 3, and 4. The first time through the loop, you're going
to say n is equal to 0. Or internally, this is what happens. N gets the value of 0. You're going to"
Lecture2_Chunk73,"to say n is equal to 0. Or internally, this is what happens. N gets the value of 0. You're going to
print n. Then you're going to go back to the top. N gets the value 1. Then you're going to go
execute whatever is inside. So you're going to print 1. Then you're going to increment that to
the next value in the sequence. You're going to print out 2, and so on.
So this is the general look of a for loop. So we have for some loop variable-- again, can be"
Lecture2_Chunk74,"So this is the general look of a for loop. So we have for some loop variable-- again, can be
named whatever you want-- in range some number. Do a bunch of stuff. And again, these are
part of this for loop code block. So you should indent them to tell Python that these are the
things that you should do. So when you're using range some number, you start out with
variable getting the value 0. With variable having value 0, you're going to execute all of these"
Lecture2_Chunk75,"variable getting the value 0. With variable having value 0, you're going to execute all of these
expressions. After all the expressions in the code block are done, you're going to go on to the
next value. So 1. You're going to execute all these expressions with the variable being value 1,
and then so on and so on until you go to some num minus 1.
That-- so using range in that way is a little bit constraining, because you're always going to get"
Lecture2_Chunk76,"That-- so using range in that way is a little bit constraining, because you're always going to get
values starting from 0 and ending at some num minus 1, whatever is in the parentheses in
range. Sometimes you might want to write programs that maybe start at a custom value. Don't
start at 0. Maybe they start at 5. Maybe they start at minus 10. And sometimes you might want
to write programs that don't go with-- don't expect the numbers by 1, but maybe skip every"
Lecture2_Chunk77,"to write programs that don't go with-- don't expect the numbers by 1, but maybe skip every
other number, go every two numbers, or every three numbers, and so on.
So you can customize range to your needs. The one thing you do need to give it is the stop.
So if you give it only one value in the parentheses that stands for stop. And by default, start is
going to have the value 0, and step is going to have the value 1. If you give it two things in the"
Lecture2_Chunk78,"going to have the value 0, and step is going to have the value 1. If you give it two things in the
parentheses, you're giving it start and stop. So the first being start, the second being stop. And
step gets this value of 1 by default. And if you give it three things in the parentheses, you're
giving it start, stop, and step in that order. And you're always going to start at the start value
and stop at-- or so you're going to start at the start value, and you're going to go until stop"
Lecture2_Chunk79,"and stop at-- or so you're going to start at the start value, and you're going to go until stop
minus 1. So those are the sequences of numbers.
So in this first code right here, my sum is going to get the value 0. And you're going to have a
for loop. We're going to start from 7, because we're giving it two numbers. And when you give
it two numbers, it represents start and stop with step being 1. So we're starting at 7. If step is"
Lecture2_Chunk80,"it two numbers, it represents start and stop with step being 1. So we're starting at 7. If step is
1, the next value is 8. What's the value after that? If we're incrementing by 1? 9. And since
we're going until stop minus 1, we're not actually going to pick up on 10. So this loop variable,
i, the very first time through the loop is going to have the value 7. So my sum is going to be 0
plus 7. That's everything that's inside the code block."
Lecture2_Chunk81,"plus 7. That's everything that's inside the code block.
The next time through the loop, i gets the value 8. So inside the for loop, my sum gets
whatever the previous value was, which was 7, plus 8. OK. The next time through the loop, my
sum get the value 7 plus 8 plus 9. Obviously, replacing that with the previous value. So 15.
Since we're not going through 10, that's where we stop. And we're going to print out my sum,
which is going to be the value of 7 plus 8 plus 9. Yeah? OK. Yeah.
AUDIENCE:"
Lecture2_Chunk82,"which is going to be the value of 7 plus 8 plus 9. Yeah? OK. Yeah.
AUDIENCE:
[INAUDIBLE]
PROFESSOR:
Do they have to be integers? That's a great question. We can try that out. I'm not actually sure
right off the top of my head. So you can go on Spider and say-- let's say in this example here.
So we can say 7.1, 10.3-- yeah. So they have to be integers. OK. So that's that example. And
let's erase that. In this particular example, we have start, stop, and step. And here, we're going"
Lecture2_Chunk83,"let's erase that. In this particular example, we have start, stop, and step. And here, we're going
every other value. So we're starting at 5. Tell me what the next value is supposed to be. If
we're taking every other one. 7, and then 9, and then-- are we doing 11 or not? Excellent.
Nice. Yeah. So we're going to the end minus 1. OK.
So it's possible that sometimes you write code where you might want to exit out of the loop"
Lecture2_Chunk84,"So it's possible that sometimes you write code where you might want to exit out of the loop
early. You don't want to go through all of the sequences of your numbers. Maybe there's a
condition inside there where you just want to exit the loop early. Inside the while loop, maybe
you want to exit the loop before the condition becomes false. So that's where the break
statement comes in. So the break works like this. It's going to-- as soon as Python sees this"
Lecture2_Chunk85,"statement comes in. So the break works like this. It's going to-- as soon as Python sees this
break statement, it's going to say, OK, I'm going to look at whatever loop I'm currently in. I'm
not evaluating any expression after it that comes within my loop. And I'm going to immediately
exit the loop. So I'm going inside this while, this while, I'm evaluating this one expression, and I
suddenly see a break.
Expression b does not get evaluated. And break is going to immediately exit out of the"
Lecture2_Chunk86,"Expression b does not get evaluated. And break is going to immediately exit out of the
innermost loop that it's in. So this while loop that has condition 2, that's the innermost loop that
the break is found in. So we're going to exit out of this inner most loop here. And we're
evaluating expression c. And notice, we're evaluating expression c, because it's-- expression c
is part of the outer while loop. It's at the same level as this one. And these ones are part of the
inner while loop."
Lecture2_Chunk87,"inner while loop.
OK. Last thing I want to say is just a little bit of a comparison between for and while loops. So
when would you use one or the other. This might be useful in your problem sets. So for loops
you usually use when you know the number of iterations. While loops are very useful when, for
example, you're getting user input, and user input is unpredictable. You don't know how many
times they're going to do a certain task. For both for and while loops, you can end out of the"
Lecture2_Chunk88,"times they're going to do a certain task. For both for and while loops, you can end out of the
loop early using the break. The for loop uses this counter. It's inherent inside the for loop. A
while loop you can use a counter in order-- you can use a while loop to count things. But you
must initialize the counter before the while loop. And you have to remember to increment it
within the loop. Otherwise, you maybe lead to an infinite loop. We've seen as the very first"
Lecture2_Chunk89,"within the loop. Otherwise, you maybe lead to an infinite loop. We've seen as the very first
example of a for loop that the while-- the for loop could be rewritten as a while loop, but the
vice versa is not necessarily true. And the counterexample to that is just user input. So you
might not know how many times you might do a certain task. All right. Great. That's all for
today."
Lecture3_Chunk1,"MITOCW | watch?v=SE4P7IVCunE
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
ANA BELL:
All right everyone, let's get started. So good afternoon. So this is the 3rd lecture of 6.0001 and
600. As always, please download slides and code to follow along."
Lecture3_Chunk2,"600. As always, please download slides and code to follow along.
So a quick recap of what we did last time. Last time, we talked about strings as a new object
type, as sequences of characters. And then we introduced two new concepts that allowed us
to write slightly more complicated programs.
So we introduced branching, with these keywords, if, elif, else. And branching allowed us to
write programs that, us, as programmers, could introduce decisions into our programs. And"
Lecture3_Chunk3,"write programs that, us, as programmers, could introduce decisions into our programs. And
then we introduced two different kinds of loops, while loops and for loops. And those also
added a little bit of complexity to our programs.
Today, we're going to talk a little bit more about strings. So we're going to see a couple of
more operations that you can do on strings and string objects. And then we're going to talk"
Lecture3_Chunk4,"more operations that you can do on strings and string objects. And then we're going to talk
about three different algorithms, a guess and check algorithm, an approximate solution
algorithm, and a bisection method algorithm.
So let's dive right in. We'll talk a little bit about strings, first. So strings, we thought of them as
sequences of characters, case sensitive, as we saw in programs we wrote last lecture. And"
Lecture3_Chunk5,"sequences of characters, case sensitive, as we saw in programs we wrote last lecture. And
strings are objects. And we can do all of these operations on string objects, like test if they're
equal, less than, greater than, and so on.
It turns out, we can do more than just concatenate two strings together or do these little tests
on them. So we're going to start introducing the idea of a function or a procedure. And we're"
Lecture3_Chunk6,"on them. So we're going to start introducing the idea of a function or a procedure. And we're
going to see more about functions and how you can write your own functions next lecture.
But for today, you can think of a function as sort of a procedure that does something for you.
Someone already wrote this. So the first one we're going to look at is a pretty popular function.
And when applied on a string, this function, called len, will tell you the length of a string. So"
Lecture3_Chunk7,"And when applied on a string, this function, called len, will tell you the length of a string. So
that's going to tell you how many characters are in the string. And characters are going to be
that's going to tell you how many characters are in the string. And characters are going to be
letters, digits, special characters, spaces, and so on. So it's just going to count how many
characters are in a string."
Lecture3_Chunk8,"characters are in a string.
So if I have the string s is equal to ""abc""-- remember a string is in quotation marks-- then, if I
do this, if I write this expression, len s, here, since it's an expression, it has a value. So it
evaluates to a certain value. And by definition, it's going to tell me what the length of the string,
which is 3 characters long.
Another thing that we can do on strings is, since they're a sequence of characters, I might"
Lecture3_Chunk9,"Another thing that we can do on strings is, since they're a sequence of characters, I might
want to get what character is at a certain position. So we do this using this fancy word called
indexing. But pretty much what indexing into a string means is you're going to tell Python, I
want to know the character, at this certain position or at this certain index, inside my sting.
So once again, let's use this string, s is equal to ""abc."" And let's index into it. So in computer"
Lecture3_Chunk10,"So once again, let's use this string, s is equal to ""abc."" And let's index into it. So in computer
science, we start from 0, counting by convention. Notice, we had a problem set 0 in this class.
Python is no different.
So in Python, you start indexing at position 0. Or you start indexing at 0. So the first character,
in your string, we say is at position 0 or at index 0. The next character in the string is at index
1. And the next character in the string is at index 2."
Lecture3_Chunk11,"1. And the next character in the string is at index 2.
In Python, it turns out, you can also use negative numbers to index. And if you index into the
string with negative 1, for example, that means that you want the last character in the string.
So the last character in your string is always going to be at position negative 1, the second-to-
last character is at negative 2, third-to-last character is at negative 3, and so on and so on."
Lecture3_Chunk12,"last character is at negative 2, third-to-last character is at negative 3, and so on and so on.
So the way you index into a string is with these square brackets, here. And this is the notation.
So if I want the character at position 0 or at index 0, I say s, which is the string I want to index
into. And then, inside the square brackets, I say what index I want.
So s at index 0 is going to be the value ""a."" s at index 1 is going to be the value ""b,"" and so on"
Lecture3_Chunk13,"So s at index 0 is going to be the value ""a."" s at index 1 is going to be the value ""b,"" and so on
and so on. And we can also do negative indexing, as well.
I added this in here. If you do try to index into a string beyond the limits of the string-- and we
can even try this out, just to show you that it's not the end of the world if we do that. If we have
s is equal to ""abc,"" and we have s at position 20, for example, obviously, my string is only
length 3, so what's at position 20?"
Lecture3_Chunk14,"length 3, so what's at position 20?
I get an error. I call this angry text, here, in Python. But really, the most relevant thing to note
is these last couple of lines here. This tells you what line is problematic. So s at position 20 has
an issue. And this last line here tells me what actual error I have. So it's an index error, which
means I'm trying to index too far into the string, because it only has three characters."
Lecture3_Chunk15,"means I'm trying to index too far into the string, because it only has three characters.
So it's nice to be able to get a single character out of my string. But sometimes, I might want to
get a substring. So I want to start at the first character and go halfway into the string, or I want
to take a few characters in between, or I want to skip every other letter or something like that
in my string.
So if I want to do this slightly more complicated interaction with strings, we call that slicing,"
Lecture3_Chunk16,"So if I want to do this slightly more complicated interaction with strings, we call that slicing,
slicing into a string. And this notation here should seem a little bit familiar, because we saw it
last lecture when we did it with range.
We had a start, stop, and a step. The notation was a little bit different, because, in range, we
had open-close parentheses and commas in between. But except for that, this sort of works
the same."
Lecture3_Chunk17,"had open-close parentheses and commas in between. But except for that, this sort of works
the same.
The start is the index, starting from 0, from where you want to slice into this string. The stop is
the stop index. So you're going to go up until stop minus 1 and take that index. And then the
step is how many letters you wish to take.
So this is the full notation here. But sometimes, you can not give it a third sort of number in"
Lecture3_Chunk18,"So this is the full notation here. But sometimes, you can not give it a third sort of number in
here. So if you only give it two numbers, then, to Python, that represents just the start and the
stop. And by default, step is going to be 1.
And there's a lot of other things you can do with strings. You can omit numbers and just leave
colons in Python. By definition, the way that whoever wrote slicing had decided, if you omit
numbers, then it's going to be equivalent to these things here."
Lecture3_Chunk19,"numbers, then it's going to be equivalent to these things here.
So we slice using square brackets, just like indexing. Except now, we can give it two numbers.
So with this string, s, if we slice into the string s, we start from index 3 and go up until index 6.
So if we have abcdefgh, this is position 0, 1, 2, 3, 4, 5, 6, 7.
And you just count. So s, starting from 3 and going till 6, is going to start here, 3. So it's going"
Lecture3_Chunk20,"And you just count. So s, starting from 3 and going till 6, is going to start here, 3. So it's going
to come up with-- sorry d. And then we're going to take e. And then we're going to take f. And
since we're going until stop minus 1, we're not going to take g. Because this is position 6, and
we're going until 6 minus 1.
The next one here, 3, 6, 2 is going every other one. So we start at 3, and then we skip every
other one, so we go d but not e, and then f, and then stop."
Lecture3_Chunk21,"other one, so we go d but not e, and then f, and then stop.
If you do s and then nothing inside except colons, notice that you're going to have s, and then
nothing, and then colon, nothing, colon, nothing. So nothing for start, nothing for stop, nothing
for step. And that's just going to value it to the string, itself. It's the same as 0 to the length s
going every step.
This one might actually be useful. It reverses the string automatically for you. So with this one"
Lecture3_Chunk22,"This one might actually be useful. It reverses the string automatically for you. So with this one
little line here, you can get the inverse of your string. And that's equivalent to that. So the
minus 1 represents starting from the end and going back every letter. And then this one's a
little bit more complicated but also not too bad.
So as we're doing these string slices, again, if you're unsure what something does, just type it"
Lecture3_Chunk23,"So as we're doing these string slices, again, if you're unsure what something does, just type it
into Spider. And you might be surprised. You might not be. But it's a good way to check
yourself, to make sure you're understanding what's happening.
One thing I want to mention, and it's good to keep this in the back of your mind. We're going to
come back to this as we start talking about slightly more complicated object types. But strings"
Lecture3_Chunk24,"come back to this as we start talking about slightly more complicated object types. But strings
are immutable. So just keep this word in the back of your mind as we go through this class.
And what I mean by this is that an actual string object, once it's created, cannot be modified.
This might not mean anything right now. But let me just draw a little something. Let's say I
have this string, s is equal to hello."
Lecture3_Chunk25,"have this string, s is equal to hello.
Remember, in the first lecture, we drew a diagram sort of like this. This is my memory. I have
this object ""hello."" And this object, ""hello"" is bound to this variable s. So now I can access the
object ""hello"" using this variable s.
Now you might think, well, since I could index into a string, I might be able to just say
something like, s at position 0 is equal to y. And that will just change the little h into a y, and I'll
have a new object."
Lecture3_Chunk26,"have a new object.
Well strings are immutable, which means, in Python, you're not actually allowed to do this. And
it gives you an error if you do try to do that. If you want the variable s to point to the string, Y-
E-L-L-O, you could just say s is equal to Y-E-L-L-O.
Or you could do string operations like this. And this takes the y and it concatenates it to the
string s, all of the elements starting from position 1, which is e, l, l, o. So this makes Y-E-L-L-O."
Lecture3_Chunk27,"Now internally, what happens when I write this line is Python says, OK, I'm going to break my
bond with this original object ""hello."" I'm going to bind my string variable s to the new object
""yello."" and this other, old object still is in memory somewhere. But it's an entirely different
object that I've created here.
Again, it might not mean anything right now, but just keep this in the back of your mind, strings
are immutable."
Lecture3_Chunk28,"are immutable.
So the next thing I want to talk about is a little bit of recap on for loops. And we're going to see
how we can apply for loops, very easily, to write very nice, readable code when dealing with
strings.
So remember that for loops had a loop variable. My loop variable being this var, here, in this
particular case. It can be anything you want. And this variable, in this particular case, iterates
over this sequence of numbers, 0, 1, 2, 3, 4."
Lecture3_Chunk29,"over this sequence of numbers, 0, 1, 2, 3, 4.
So the very first time through the loop, var has a value of 0. It does the expressions in the
loop. As soon as they're done, var takes the value 1. It does all the expressions in the loop.
And then var takes the value 2, and it does that all the way up until 0, 1, 2. And the last time it
goes around is with var is equal to 3.
And remember, we said that we can customize our range in order to start from a custom value"
Lecture3_Chunk30,"And remember, we said that we can customize our range in order to start from a custom value
to end at a different value and to skip certain numbers.
So, so far, we've only been using for loops over a sequence of numbers. But actually, for loops
are a lot more powerful than that. You can use them to iterate over any sequence of values
not just numbers but also strings.
So here are two pieces of code, this one and this one here. These two pieces of code both do"
Lecture3_Chunk31,"So here are two pieces of code, this one and this one here. These two pieces of code both do
the exact same thing. To me, possibly to you, this one looks a lot more readable than this one,
just at a first glance.
If I were to read this one, just using the keywords and variables here, it would sound like
broken English. But you could decipher what I'm trying to say. For a char in a string s, if the
char is equal to ""i"" or a char is equal to ""u,"" print ""There is an i or a u."""
Lecture3_Chunk32,"char is equal to ""i"" or a char is equal to ""u,"" print ""There is an i or a u.""
char is equal to ""i"" or a char is equal to ""u,"" print ""There is an i or a u.""
It sounds weird, but you could probably tell what I was trying to do here. Whereas up here, it's
a little more complicated to tell what I'm doing. You have to sort of think about it a little bit.
For some index in this range of numbers, 0 through the length of the string s, if s, at position"
Lecture3_Chunk33,"For some index in this range of numbers, 0 through the length of the string s, if s, at position
index, is an ""i"" or s at position index is a ""u"" print, ""There is an i or a u."" Both of these codes
just go through the string s. And if it encounters a letter that's an i or a u, it's just going to print
out this string here.
But this bottom one is a lot more pythonic. It's an actual word created by the Python
community. And it just looks pretty, right? You can tell what this code's supposed to do."
Lecture3_Chunk34,"community. And it just looks pretty, right? You can tell what this code's supposed to do.
Whereas this one is a little bit harder to decipher.
So that's sort of an illustration of a for loop over a sequence of characters. So char is going to
be a loop variable, still. And the loop variable, instead of iterating over a set of numbers, it's
going to iterate over every character in s, directly. And char is going to be a character. It's
going to be a letter."
Lecture3_Chunk35,"going to be a letter.
So here's a more complicated example. I wrote this code a couple of years ago. And it was my
attempt at creating robot cheerleaders , because I needed some motivation. And then I
googled, last night, ""robot cheerleaders,"" and was not disappointed. Created this GIF. It looks
pretty cool. And it looks like they kind of stole my idea. But that's fine.
So let's look at what this code's supposed to do. I'm going to run it. I'm going to run it, and"
Lecture3_Chunk36,"So let's look at what this code's supposed to do. I'm going to run it. I'm going to run it, and
then we'll go through it. All right, it prints out, ""I will cheer for you! Enter a word.""
You know what, I like robots, so I'll put in ""ROBOTS."" How enthusiastic am I about robots?
Let's say 6. So what this is going to print is-- it's a cheerleader, right? ""Give me an r, r."" ""Give
me an o, o."" ""Give me a b, b,"" and so on and so on."
Lecture3_Chunk37,"me an o, o."" ""Give me a b, b,"" and so on and so on.
""What does that spell? ROBOTS."" And it's going to print it 6 times, because I'm 6 out of 10
enthusiastic about robots. So that's pretty much what that code's supposed to do. And you can
write it using what we've learned so far.
Now let's go through it a little bit. And I'm going to show you just how easy it is to convert this
code using a for loop over characters. Right now, what it does is it asks the user for input, so a
word and a number."
Lecture3_Chunk38,"word and a number.
And then it does this thing, here, right? First, it uses a while loop. And second, it uses indexing.
And what tips you off that it's using indexing is it's using the square bracket, here, into the
word.
And obviously, it's using a while loop. And it has to first create a counter, initialize it. And then,
down here, it's going to increment it inside the while loop. If you remember, that's sort of what
we need to do for while loops."
Lecture3_Chunk39,"we need to do for while loops.
So it's going to start at 0, and it's just basically going to go through index i is equal to 0, 1, 2, 3
4, which is going to go all the way to the end of the word, whatever the user typed in, in this
case ""ROBOTS."" It's going to get the character at that position. word at position i is going to be
a character.
This line here is just for the cheerleading to make sense. It's just to take care of letters that"
Lecture3_Chunk40,"This line here is just for the cheerleading to make sense. It's just to take care of letters that
make sense to use an, right? So give me a b, give me an b. So give me an b does not make
sense, right? So that's just taking care of that.
And I'm using this in keyword to check whether the character-- so the character, r, for
example, in robots-- is inside an letters. And an letters I've defined up here, which is these are"
Lecture3_Chunk41,"example, in robots-- is inside an letters. And an letters I've defined up here, which is these are
all the letters that make sense to put an an before the letter. So give me an r for example,
here, on the right.
And so if it makes sense to use an before the letter, use that, and otherwise use just an a. And
after I'm done, I say, ""What does that spell?"" And then it's just a for loop that goes times many
times and prints out the word and the exclamation mark."
Lecture3_Chunk42,"times and prints out the word and the exclamation mark.
So this code might have been a little bit more intuitive if I rewrote it or if I'd originally written it
with a for loop. So this part here, the while loop and indexing and creating my original counter,
we can get rid of that.
And we can replace it with this, for char in word. I'm originally using char, so I can use char as
my loop variable again. And simply, I'm just going to iterate over the word, itself."
Lecture3_Chunk43,"my loop variable again. And simply, I'm just going to iterate over the word, itself.
So now, instead of having this mess here, I have a one-liner that says, for every character in
my word, do all this stuff here. So that remains the same. And then I don't even need to
increment a counter variable, because I'm not using while loops anymore. I'm just using a for
loop.
So the code becomes-- delete that-- for char in word. And then delete that. And that does the"
Lecture3_Chunk44,"loop.
So the code becomes-- delete that-- for char in word. And then delete that. And that does the
exact same thing. And it's a lot more readable.
So this was our toolbox at the beginning of this course. We are two and half, I guess, lectures
in. These are the things we've added to it. We know integer, floats, Booleans. We know a bit of
string manipulation, math operations. We added, recently, these conditionals and branching to
write slightly more interesting programs."
Lecture3_Chunk45,"write slightly more interesting programs.
And now we have loops, for and while loops to add interesting and more complicated
programs. So with these, the second part of this lecture is going to be looking at three different
algorithms. That's the sort of computer science part of this class, Introduction to Computer
Science and Programming using Python.
Don't let the word algorithm scare you. They're not that complicated. You just have to sort of"
Lecture3_Chunk46,"Don't let the word algorithm scare you. They're not that complicated. You just have to sort of
think a little bit about them. And you'll be able to get them.
So we're going to look at three algorithms, all in the context of solving one problem, which is
finding the cube root. The first algorithm is guess and check, then we're going to look at an
approximation algorithm, and then a bisection search.
So the first is the guess and check method. You might have done this, in math, in high school."
Lecture3_Chunk47,"So the first is the guess and check method. You might have done this, in math, in high school.
The guess and check method is also sometimes called exhaustive enumeration. And you'll see
why.
So given a problem, let's say, find the cube root of a number, let's say you can guess a
starting value for a solution. The guess and check method works if you're able to check if your
solution is correct.
So if your guess is originally 0, you can say, is 0 cubed equal to the cube of whatever I'm"
Lecture3_Chunk48,"So if your guess is originally 0, you can say, is 0 cubed equal to the cube of whatever I'm
trying to find the cube root of? So if I'm trying to find the cube root of 8, is 0 cubed equal to 8?
No. So the solution is not correct.
If it's not correct, guess another value. Do it systematically until you find a solution or you've
guessed all the possible values, you've exhausted all of your search space.
So here's a very simple guess and check code that finds the cube root of a number. So I'm"
Lecture3_Chunk49,"So here's a very simple guess and check code that finds the cube root of a number. So I'm
trying to find the cube root of 8. So my cube is 8. I'm going to have a for loop that says, I'm
going to start from 0. And I'm going to go all the way up to--
So I'm going to start from 0 and go all the way up to 8. For every one of these numbers, I'm
going to say, is my guess to the power of 3 equal to the cube 8? And if it is, I'm going to print
out this message."
Lecture3_Chunk50,"out this message.
Pretty simple, however, this code is not very user friendly, right? If the user wants to find the
cube root of 9, they're not going to get any output, because we never print anything in the
case of the guess not being a perfect cube. or the cube not being a perfect cube.
So we can modify the code a little bit to add two extra features. The first is we're going to be
able to deal with negative cubes, which is kind of cool."
Lecture3_Chunk51,"able to deal with negative cubes, which is kind of cool.
And the second is we're going to tell the user, if the cube is not a perfect cube, hey, this cube
is not a perfect cube. So we're not going to silently just fail, because then the user has some
sort of feedback on their input.
So let's step through this code. We have, first of all, a for loop just like before. And we're going
to go through 0 to 8 in this case. We're using the absolute value, because we might want to"
Lecture3_Chunk52,"to go through 0 to 8 in this case. We're using the absolute value, because we might want to
find the cube root of negative numbers.
First thing we're doing is doing this check here. Instead of guessing whether the guess to the
power of 3 is equal to the cube, we're going to check if it's greater or equal to, and we're going
to do that for the following reason.
So if we're trying to find the cube root of 8, for example, versus a cube root of 9-- this is 8 and"
Lecture3_Chunk53,"So if we're trying to find the cube root of 8, for example, versus a cube root of 9-- this is 8 and
this is 9-- what is this code going to do? It's going to first guess 0. 0 cubed is not greater or
equal to 8. 1 cubed is not greater or equal to 8.
2 cubed is greater or equal to 8, so here, once we've guessed 2, we're going to break.
Because we found a number that works. And there's no need to keep looking. Once we've"
Lecture3_Chunk54,"Because we found a number that works. And there's no need to keep looking. Once we've
found the cubed root of this number 8, there's no need to keep searching the remainder, 3, 4,
5, 6, 7, 8.
Sort of the same idea when we're trying to find the cube root of 9. We're going to start with 0.
0 to the power of 3 is less than 9. 1 to the power of 3 is less 9. 2 to the power of 3 is less than
9.
When we get to 3 to the power of 3, that's going to be greater than 9. So this code tells us,"
Lecture3_Chunk55,"9.
When we get to 3 to the power of 3, that's going to be greater than 9. So this code tells us,
once we've picked a number that's beyond the reasonable number of our cubed root, of our
once we've picked a number that's beyond the reasonable number of our cubed root, of our
cube, the cubed root of our cube, then we should stop.
Because, again, it doesn't make sense to keep searching. Because if 3 to the power of 3 is"
Lecture3_Chunk56,"Because, again, it doesn't make sense to keep searching. Because if 3 to the power of 3 is
already greater than 9, 4 to the power of 3 is also going to be greater than 9 and so on. So
once we break here, we either have guess being 2 or guess being 3 depending on what cube
we're trying to find.
And if the guess to the power or 3 is not equal to the cube, then, obviously, the cube was not a
perfect cube. So that's this case here, if we were looking at at the cube root of 9. And"
Lecture3_Chunk57,"perfect cube. So that's this case here, if we were looking at at the cube root of 9. And
otherwise, this part here just looks at whether we should make it a positive or a negative cube.
So if our original cube was less than 0, then, obviously, the cube root of a negative number is
going to be a negative number, and, otherwise, it's just our guess.
So that's the guess and check method, slightly more feature-rich program for guessing the"
Lecture3_Chunk58,"So that's the guess and check method, slightly more feature-rich program for guessing the
cube root. But that only tells us the cube root of perfect cubes and doesn't really give us
anything else, any more information.
So sometimes, you might want to say, well, I don't care that 9 is not a perfect cube, just give
me a close enough answer. So that's where approximate solutions come in. So this is where
we're OK with having a good enough solution."
Lecture3_Chunk59,"we're OK with having a good enough solution.
So in order to do that, we're going to start with a guess and then increment that guess by
some small value. Start from 0 and start incrementing by 0.001 and just go upwards from
there. And at some point, you might find a good enough solution.
In this program, we're going to keep guessing as long as we're not close enough. And close
enough is going to be given by this epsilon value in the program. So as long as the guess"
Lecture3_Chunk60,"enough is going to be given by this epsilon value in the program. So as long as the guess
cubed minus the cube-- so how far away are we from the actual answer-- is greater than some
epsilon, keep guessing, because the solution is not good enough.
But once this is less than epsilon, then we've reached a good enough solution. So two things
to note with approximate solutions. So you can get more accurate answers if your step size is"
Lecture3_Chunk61,"to note with approximate solutions. So you can get more accurate answers if your step size is
really, really small. If you're incrementing by 0.0001, you're going to get a really good
approximate solution, but your program will be a lot slower.
Same sort of idea with epsilon, you can change epsilon. If you change epsilon to be a bigger
epsilon, you're sacrificing accuracy, but you're going to reach a solution a lot faster."
Lecture3_Chunk62,"epsilon, you're sacrificing accuracy, but you're going to reach a solution a lot faster.
So here's the code for the approximate solution of a cube root. It might look intimidating, but,
look, almost half this code is just initializing variables. So we're initializing, this is the cube we
want to find the cube root of. We pick an epsilon of this. We start with a guess of 0. We start
with an increment of 0.0001. And just for fun, let's keep track of the number of guesses that it"
Lecture3_Chunk63,"with an increment of 0.0001. And just for fun, let's keep track of the number of guesses that it
takes us to get to the answer.
This is similar to the guess and check from before. It's not similar. Well this part is similar to
the guess and check from before. So we're going to take the guess to the power of 3 minus
the cube, right? So that's how far away are we from the actual answer?
And we're going to say, if that's not good enough-- so if we're still greater than or equal to the"
Lecture3_Chunk64,"And we're going to say, if that's not good enough-- so if we're still greater than or equal to the
epsilon-- then keep guessing. So we're going to be stuck in this loop, where we keep guessing
values, until we've reached a guess that's good enough, so until we're less than epsilon.
And way we keep guessing is just with this line, right here, which says, increment my guess by
increment, and increment being this really small value. That make sense?"
Lecture3_Chunk65,"increment, and increment being this really small value. That make sense?
So I'm going to keep incrementing my guess by that small value. Before I go on, I'm going to
run the code. And we're going to discover a small issue with it.
So with 27, we're going to run it. Perfect, it took me 300 guesses. But 2.99999 is close to the
cube root of 27. We can find the cube root of this guy here. And it took me 20,000 guesses,"
Lecture3_Chunk66,"cube root of 27. We can find the cube root of this guy here. And it took me 20,000 guesses,
but I figured out that 200.99999, so 201, is close to the cube root of that large number.
I should have done this. This is going to be a giveaway, you guys. Sorry. Then we're going to
have-- let's say I want to try cube of 10,000. So 10,000 is not a perfect cube. So we can run
the code. And with 8,120,601 I had already gotten an answer. But with 10,000, I'm not getting
an answer yet, right?"
Lecture3_Chunk67,"an answer yet, right?
So I'm thinking that there might be something wrong. So I'm going to stop my code. So I just
hit Control C, because I feel like I've entered an infinite loop. And, in fact, I have. So what
ended up happening is this problem here.
So I'm going to draw something. According to the code, I'm going to start from 0, and I'm
going to increment my guesses, like that. With every little increment, I'm going to make a new"
Lecture3_Chunk68,"going to increment my guesses, like that. With every little increment, I'm going to make a new
guess. I'm going to take that guess to the power of 3. I'm going to subtract the cube, and I'm
going to figure out if I'm less than epsilon.
This is the epsilon that I want to be in, this little bit here. So with every new guess, I might be,
maybe-- so this is where I want to be, within this little boundary here. With every new guess, I
might be here."
Lecture3_Chunk69,"might be here.
With the next guess, over here, I might be here. When I make another guess, I might be here.
So I'm getting close to being within epsilon. But maybe with my next guess, I'm going to hop
over my epsilon and have made too big of a guess.
So just because of the way the numbers were chosen in this example, just to illustrate this,
using an increment of 0.01, a with finding the cube of 10,000 and epsilon of 0.1, it turns out"
Lecture3_Chunk70,"using an increment of 0.01, a with finding the cube of 10,000 and epsilon of 0.1, it turns out
that, as I'm doing all these calculations, I'm going to skip over this perfect sort of epsilon
difference.
So first, I'm going to be too small. And then I'm going to be too large. And once I've become
too large or too far away from epsilon, the guesses I continue to make are just going to be
even farther away from epsilon. And I'm not going to get to my answer."
Lecture3_Chunk71,"even farther away from epsilon. And I'm not going to get to my answer.
And that's why I've reached an infinite loop in this code. All I'm doing in this code is checking
whether my guess cube minus cube is less than epsilon. The only thing I need to do here is
sort of add this little clause, here, that says, oh, by the way, also check that I'm less than cube.
Because this is just like we did in the very first program, when I'm checking 0, 1, 2, 3, 4, 5, 6,"
Lecture3_Chunk72,"Because this is just like we did in the very first program, when I'm checking 0, 1, 2, 3, 4, 5, 6,
7, 8, when I'm trying to find the cube root of 8. Once I've reached 8, I'm going to stop. And it's
the same thing here.
So I just added this little clause that says, well, while I'm greater than or equal to epsilon and
I'm still less than the actual cube, just keep searching. But once I've reached the cube, then
stop searching."
Lecture3_Chunk73,"stop searching.
And with 10,000, you can see that I failed to actually find-- so that's what this part, here, does.
It tells me I've failed to find the cube root with those particular parameters.
The last thing we're going to look at is bisection search. And to illustrate this, I'm going to need
one volunteer. And you're going to play a game with me in front of the whole class. And there
will be a prize. There go the hands. In the blue shirt, right there. Cool."
Lecture3_Chunk74,"will be a prize. There go the hands. In the blue shirt, right there. Cool.
So the prize is going to be, once again, this. I promise I don't have millions of these, Google
glasses. I also don't work for Google. I just happened to get a couple.
So the game is this. I'm going to ask you to pick a number, a whole number, between 0 and
100. And I'm going to try to guess it. And you need to make it hard for me. And you need to
make it so hard for me that I cannot guess it within 10 guesses."
Lecture3_Chunk75,"make it so hard for me that I cannot guess it within 10 guesses.
And if you can do that, if I cannot guess it within 10 guesses, you get this. And I'm going to
draw out what I do as we go along. So do you have your number? Yes?
AUDIENCE:
Yeah.
ANA BELL:
Perfect. Let me erase that. Actually, I should've probably kept that, because I'll still use it.
There's the numbers, 0 to 100. Is your number 50?
AUDIENCE:
No.
ANA BELL:"
Lecture3_Chunk76,"There's the numbers, 0 to 100. Is your number 50?
AUDIENCE:
No.
ANA BELL:
50 Was my guess. So I've made one guess. Is your number higher or lower than 50?
AUDIENCE:
Higher.
ANA BELL:
Higher. Is your number-- my next guess is going to be 75. And the reason I'm guessing 75 is
because-- what's your name?
AUDIENCE:
Sophie.
ANA BELL:
What's that?
AUDIENCE:
Sophie.
ANA BELL:
Sophie. Sophie said, 50 was too low. So I immediately know that it cannot be any less than 50."
Lecture3_Chunk77,"Sophie. Sophie said, 50 was too low. So I immediately know that it cannot be any less than 50.
So I've already eliminated half of the numbers. So my next guess is 75. Is your number 75? Is
your number lower or higher?
AUDIENCE:
Higher.
ANA BELL:
Since it's higher, I'm eliminating this half here. Is your number-- so between 75 and 100. Oh,
boy, you're putting me on the spot. What's that?
AUDIENCE:
87.
ANA BELL:
87, thank you. 87?
AUDIENCE:
No.
ANA BELL:
Higher or lower?
AUDIENCE:
Lower.
ANA BELL:"
Lecture3_Chunk78,"87.
ANA BELL:
87, thank you. 87?
AUDIENCE:
No.
ANA BELL:
Higher or lower?
AUDIENCE:
Lower.
ANA BELL:
Lower. So since it's lower, I'm eliminating that half. Is your number 81? Higher or lower?
AUDIENCE:
Lower.
ANA BELL:
So she said, lower, so I'm eliminating that half. Is your number 78? Oh, boy, that's really hard.
78, OK. Higher or lower?
AUDIENCE:
Lower.
ANA BELL:
Is your number 76?
AUDIENCE:
Yeah.
ANA BELL:
Yay. All right, perfect, 76 was the number. So how many guesses have I made? One, two,"
Lecture3_Chunk79,"ANA BELL:
Yay. All right, perfect, 76 was the number. So how many guesses have I made? One, two,
three, four, five, six-- I made six guesses. So I did get it under 10. But you know what? The
game was rigged. So you get the prize anyway, just because I rigged the game. Here you go.
Pass it down.
AUDIENCE:
Thank you.
ANA BELL:
Thank you. So notice, in bisection search, what I did was I eliminated half the search space"
Lecture3_Chunk80,"Thank you. So notice, in bisection search, what I did was I eliminated half the search space
with every guess. I said, well, she said it's higher or lower, so I definitely cannot be in the other
search space, right? If I was doing approximate solution or, in this case, guess and check, I
would be asking Sophie, is your number 0, 1, 2, 3, 4, and so on?
So with guess and check, it would have taken me 76 guesses to get to the number, whereas,"
Lecture3_Chunk81,"So with guess and check, it would have taken me 76 guesses to get to the number, whereas,
with this bisection search, that I just did, it only took me 6. Isn't that cool?
So that means that the larger the space actually is, that I need to search, the better it is to use
bisection search, this bisection search method. So that's basically what I'm illustrating here. So
we have our original search space. We're going to choose a guess halfway, eliminate half of"
Lecture3_Chunk82,"we have our original search space. We're going to choose a guess halfway, eliminate half of
the guesses. Then we're going look in the remaining interval, eliminate half the guesses, and
so on and so on.
So then this is the code for bisection search. Also looks intimidating, but it's not so bad. So
we're initializing a bunch of stuff up here. The most important couple of things we're initializing
are, first of all, this high and this low boundaries."
Lecture3_Chunk83,"are, first of all, this high and this low boundaries.
So with the guessing game, the low boundary was 0, and the high boundary was 100. When
we're looking at the cube root, the low boundary is going to be 0, and the high boundary is
going to be just my cube, because a guess to the power of 3 cannot be any greater than cube.
And then, I'm just going to do the same procedure that I did with the guessing game, which is"
Lecture3_Chunk84,"And then, I'm just going to do the same procedure that I did with the guessing game, which is
I'm going to make my guess, be halfway in between. So with this guessing game, I had to sort
of choose, if there were four numbers in between, should I go higher or lower?
Well, when we're doing by bisection search, here, we don't care about that. We're just going to
do floating point division, because we want decimal numbers. So I have a low boundary and a"
Lecture3_Chunk85,"do floating point division, because we want decimal numbers. So I have a low boundary and a
high boundary. And I figured out my halfway point.
Then I have this while loop here. A while loop is similar to the approximation method, where,
as long as I don't have a guest that's good enough-- so this, depicted by this greater or equal
to epsilon-- as long as my guess is not good enough, I'm going to keep guessing. That's what
this while loop is saying."
Lecture3_Chunk86,"this while loop is saying.
So if the guess to the power of 3 minus cube is not good enough, keep guessing. And the way
I keep guessing is this part, here, says, my guess was too low. So if my guess was too low, set
the low boundary to be the guess. Because I don't care about all of the other numbers that are
much lower than me.
So set the low to be the guess. That's what that line is doing. And otherwise, my guess was"
Lecture3_Chunk87,"So set the low to be the guess. That's what that line is doing. And otherwise, my guess was
too high. That's what this else is doing. So set the high to be the guess, because I don't care
about numbers any higher than my guess.
Once I have these new boundaries, I make another guess, again, halfway in between the new
boundary points. So essentially, I'm just halving my interval with every single guess. And that's
what the while loop is doing. And then I print out the remaining part."
Lecture3_Chunk88,"what the while loop is doing. And then I print out the remaining part.
So notice the search space originally being N, we're halving it with each guess. So the first
guess divides it by 2, the second guess divides it by 4, and so on. So by the time we get to the
k-th guess, N/2k, the k-th guess, let's say that's the actual answer we're interested in. There's
only one value in that little interval. And that's the answer we want."
Lecture3_Chunk89,"only one value in that little interval. And that's the answer we want.
So 2 to the k is equal to N. And then how many guesses did we make? k is equal to log base 2
of N. So when we are playing the guessing game of 100, my end was 100. Log base 2 of 100
is 6.-something, I think.
So in fact, I could have said, if I don't guess it within seven guesses, you would have won as
well. So that's why the game was rigged. So the guess, notice, it converges on the order of log"
Lecture3_Chunk90,"well. So that's why the game was rigged. So the guess, notice, it converges on the order of log
base N instead of just linearly in terms of N. So that's why it's so powerful.
One last thing I want to mention is the code I showed only works for positive cubes. And that's
because of the following. So I have this 0 and 1. Let's say I'm trying to find the cube root of
0.5.
When I first set my initial boundaries, my low is this one, and my high is this one. But what's"
Lecture3_Chunk91,"0.5.
When I first set my initial boundaries, my low is this one, and my high is this one. But what's
the cube root of 0.5? Is it within this boundary or is it outside this boundary?
AUDIENCE:
Outside the boundary.
ANA BELL:
I heard, outside. It's like 0.7 something. So it's out here. So with this particular code, I'm going
to be halving my interval in between those numbers, but I'll never get to an answer. Because"
Lecture3_Chunk92,"to be halving my interval in between those numbers, but I'll never get to an answer. Because
the actual cube root of 0.5, or numbers less than 1, is going to be outside that boundary.
So there's a small change you can make to the program, which will fix that. And that's in the
code. I didn't put it in, but it's a very small change, a small if statement. So that's it. All right,
thank you.
[APPLAUSE]"
Lecture4_Chunk1,"MITOCW | watch?v=MjbuarJ7SE0
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
PROFESSOR:
All right everyone let's get started. All right good afternoon on this rainy, rainy sad afternoon."
Lecture4_Chunk2,"All right everyone let's get started. All right good afternoon on this rainy, rainy sad afternoon.
So-- I'm glad we're inside though-- all right so Lecture 4 of 6.0001 in 600. Quick, quick recap
of what we did last time. So last time we did a little bit more string manipulations, and then we
saw how you can use for loops over strings directly. So instead of having for loops that iterate
over range-- so 0, 1, 2, 3, 4, and so on-- you saw that it was more powerful to sometimes use"
Lecture4_Chunk3,"over range-- so 0, 1, 2, 3, 4, and so on-- you saw that it was more powerful to sometimes use
for loops that iterate over string objects directly.
So that was the first half of the lecture. In the second half, we started looking at different ways
that you can implement the different implementations to the same problem. So we saw the
problem of finding the cube root, and we saw some implementations. We saw the Guess and
Check method, and the approximation method."
Lecture4_Chunk4,"Check method, and the approximation method.
And then we looked at what I thought was the most powerful method, which was the bisection
method. And this one, if you remember, I played a game with someone in the audience where
I guessed a number between 0 and 100. And we saw that I was able to guess that number
really, really quickly using the bisection method. And that's the method that you're going to
implement-- that you are currently implementing-- in your problem set."
Lecture4_Chunk5,"implement-- that you are currently implementing-- in your problem set.
OK so today-- so that sort of finishes introduction to some of the more basic mechanisms in
Python. And today we're going to talk about how to structure your programs such that you
write nice, coherent code-- reusable code-- by hiding away some of the details in your code.
And to do that we're going to look at these things called functions."
Lecture4_Chunk6,"And to do that we're going to look at these things called functions.
All right so just stepping back and sort of getting a high-level view of how we write the code so
far. So so far the way that you've been writing code for your programs is you open a file, you
type some code to solve a particular problem given, like in your problem sets, each file
contains some piece of code, you have sequences of instructions that contain maybe"
Lecture4_Chunk7,"contains some piece of code, you have sequences of instructions that contain maybe
assignments, loops, conditionals, and so on and so on. But really you have one file that
contains each code and you write everything in that particular file.
But this is OK for smaller problems that we've been seeing so far, but when you're starting to
write large pieces of code it's going to get really messy, really quickly. So think about if you"
Lecture4_Chunk8,"write large pieces of code it's going to get really messy, really quickly. So think about if you
want to use a for loop in one part of your code, and you find it useful to use that same for loop
in another part of your code.
Some point in the future as you're debugging your code, you might want to change your
original for loop, you have to figure out all the other places where you've used that type of for"
Lecture4_Chunk9,"original for loop, you have to figure out all the other places where you've used that type of for
loop for example. So as you're scaling your code, you'll find it harder to keep track of these
details. So this is where functions will come into play in today's lecture-- will help you out.
So if you want to be considered a good programmer, a good programming style would be to
not necessarily add lots and lots of lines of code, but really to add more functionality to your"
Lecture4_Chunk10,"not necessarily add lots and lots of lines of code, but really to add more functionality to your
programs. So how many different things-- how many different features-- can your program do,
rather than how long can your code be. And that'll help you later on look at your code if you
need it for a future class, and it'll help others if they want to look at your code later on if they
find it useful.
So today we're introducing this idea of functions. And functions are mechanisms to achieve"
Lecture4_Chunk11,"So today we're introducing this idea of functions. And functions are mechanisms to achieve
decomposition and abstraction. So these are two key words here that are going to pop up in
today's lecture and also in future lectures. So before I introduce decomposition and
abstraction in the context of functions, let's first take a look at just sort of a real-life example.
So let's take a projector. I'm using one right now. Quick show of hands. If I give you all of the"
Lecture4_Chunk12,"So let's take a projector. I'm using one right now. Quick show of hands. If I give you all of the
electronic components that are part of a projector-- resistors, a fan, a light bulb, a lens, the
casing, all of the different parts in it. Who here would be able to build a projector? Do I see a
hand? No? Ooh oh yeah nice! You can also lie. I won't know the difference. But if you can do
that, I'd be very impressed."
Lecture4_Chunk13,"that, I'd be very impressed.
All right so you can't really put together a projector right? Another show of hands. If I gave you
a projector that's fully assembled and I gave you a computer, for example, who would be able
to maybe figure out within let's say an hour how to make them work together? Good, a fair bit
of the class. That's perfect. That's exactly the answers I was trying to get at here.
So none of us really know how a projector works-- the internals-- but a lot more of us know"
Lecture4_Chunk14,"So none of us really know how a projector works-- the internals-- but a lot more of us know
how to work a projector, just given maybe a set of basic instructions or just intuitively speaking.
So you see the projector as sort of a black box. You don't need to know how it works in order
to use it.
You know maybe what inputs it might take, what's it supposed to do at a high level. Take
whatever's on my screen and put it up on the large screen there, just magnify it, but you don't"
Lecture4_Chunk15,"whatever's on my screen and put it up on the large screen there, just magnify it, but you don't
know how it does it-- how the components work together. So that's the idea of abstraction. You
don't need to know how the projector works in order to use it.
OK that's abstraction. The other half of that was decomposition. So let's say that now, given a
projector, I want to project a very, very large image down on a very large stage. For example,"
Lecture4_Chunk16,"projector, I want to project a very, very large image down on a very large stage. For example,
this is from one of the Olympics. It's a stage of what, like 10 football fields, something like that?
Something massive. You could build one projector that's able to project a very large image,
but that would be really expensive and you'd have to build this one projector that's used for
this one time.
So instead what you could do is you can take a bunch of smaller projectors and feed different"
Lecture4_Chunk17,"So instead what you could do is you can take a bunch of smaller projectors and feed different
inputs to each one of them. And as you're feeding different inputs, each one's going to show a
different output. And then you're going to be able to have all of these different projectors
working together to solve this larger problem of projecting this really cool image on a very
large stage.
So that's the idea of decomposition. You take the same projector, feed it different inputs, it"
Lecture4_Chunk18,"So that's the idea of decomposition. You take the same projector, feed it different inputs, it
does the exact same thing behind the scenes, but it will produce a different output for each
one of these different inputs. So these different devices are going to work together to achieve
the same common goal, and that's the idea of decomposition.
So these is where I apply to the problem of projecting large image, or a projector in general,"
Lecture4_Chunk19,"So these is where I apply to the problem of projecting large image, or a projector in general,
but we can apply these exact same concepts to programming. So decomposition is really just
the problem of creating structure in your code. In the projector example, we have separate
devices working together. In programming, to achieve decomposition you're dividing your code
into smaller modules.
These are going to be self-contained, and you can think of them as sort of little mini-programs."
Lecture4_Chunk20,"These are going to be self-contained, and you can think of them as sort of little mini-programs.
You feed in some input to them, they do a little task, and then they give you something back.
They go off and do their thing and then they give back a result.
These modules can be used to break up your code, and the important thing is that they're
reusable. So you write a module once-- a little piece of code that does something once-- you"
Lecture4_Chunk21,"reusable. So you write a module once-- a little piece of code that does something once-- you
debug it once, and then you can reuse it many, many times in your code with different inputs.
Benefit of this is it keeps your code organized and it keeps your code coherent.
So functions are going to be used to achieve decomposition and to create structure in our
code. We're going to see functions today in this lecture, and in a few weeks, you're going to"
Lecture4_Chunk22,"code. We're going to see functions today in this lecture, and in a few weeks, you're going to
actually see-- when we talk about object oriented programming-- how you can achieve
decomposition with classes. And with classes you can create your own object types like adding
some floats. You can create your own object types for whatever you want, but that's later.
OK so decomposition is creating structure in your code. And abstraction is the idea of"
Lecture4_Chunk23,"OK so decomposition is creating structure in your code. And abstraction is the idea of
suppressing details. So in the projector example, remember, abstraction was you didn't need
to know exactly how the projector worked in order to use it. And it's going to be the same idea
in programming.
So once you write a piece of code that does a little task, you don't need to rewrite that piece of
code many times. You've written it once, and you write this thing called a function specification"
Lecture4_Chunk24,"code many times. You've written it once, and you write this thing called a function specification
for it, or a docstring. And this is a piece of text that tells anyone else who would want to use it
in the future-- other people, maybe yourself-- it tells them how to use this function.
What inputs does it take? What's the type of the inputs? What is the function supposed to do?
And what is the output that you're going to get out of it? So they don't need to know exactly"
Lecture4_Chunk25,"And what is the output that you're going to get out of it? So they don't need to know exactly
how you implemented the function. They just need to know inputs, what it does, what's the
output. Those three things.
OK so these functions are then reusable chunks of code. And we'll see in a few examples in
today's lecture how to write some and how to call functions. And as we're going through
today's code, I want you to sort of think about functions with two different hats on."
Lecture4_Chunk26,"today's code, I want you to sort of think about functions with two different hats on.
The first hat is from someone who's writing the function. So in the projector example, someone
had to build the first projector. Someone had to know how to put all these components
together. So that's going to be you writing a function, so you need to know how to make the
function work. And then the other hat is you as someone-- as a programmer-- who is just"
Lecture4_Chunk27,"function work. And then the other hat is you as someone-- as a programmer-- who is just
using the function. You're assuming it's already been implemented correctly, and now you're
just using it to do something.
So these are some of the function characteristics and we'll see an example on the next slide.
So a function's going to have a name. You have to call it something. It's going to have some
parameters. These are the inputs to the function. You can have 0 inputs or as many as you'd
like."
Lecture4_Chunk28,"parameters. These are the inputs to the function. You can have 0 inputs or as many as you'd
like.
Function should have a docstring. This is how you achieve abstraction. So it's optional, but
highly recommended, and this is how you tell other people how to use your function. Function
has a body, which is the meat and potatoes of the function-- what it does. And a function's
going to return something. It computes its thing and then it gives back-- spits back some
answer."
Lecture4_Chunk29,"going to return something. It computes its thing and then it gives back-- spits back some
answer.
OK here's an example of a function definition and a function call. Function definition is up here.
I'll just draw it here. This is the function definition up here. And this is the function call down
here.
So remember, someone has to write the function that does something to begin with. So this is
how you write the function. The first is whoops-- the first is going to be this def keyword. And"
Lecture4_Chunk30,"how you write the function. The first is whoops-- the first is going to be this def keyword. And
def stands for-- it tells Python I'm going to define a function. Next is the name of the function.
In this case, I'm calling the function is_even. And the function name should really be
something descriptive.
Whereas someone who is just using this function or looking at it can pretty much tell what it's
supposed to do without going a lot farther than that. They're just looking at the name. And"
Lecture4_Chunk31,"supposed to do without going a lot farther than that. They're just looking at the name. And
then in parentheses you give it any parameters, also known as arguments. And these
parameters are the inputs to the function. And then you do colon.
OK so this is the first line of the function definition. And after this, everything that's going to be
part of the function is going to be indented. The next part is going to be the docstring, or the"
Lecture4_Chunk32,"part of the function is going to be indented. The next part is going to be the docstring, or the
specification, and this is how we achieve abstraction using functions.
Specification, or the docstring, starts with triple quotes and ends with triple quotes, and you
can sort of think about this as a multi-line comment. It's just going to be text that's going to be
visible to whoever uses the function, and it should tell them the following things: What are the"
Lecture4_Chunk33,"visible to whoever uses the function, and it should tell them the following things: What are the
inputs to the function? What is the function supposed to do generally? And what is the function
going to give back to whoever called it?
The next part is going to be the body of the function. We'll talk about what's inside it in the next
slide. And that's it. That's all for the function definition. def blah, blah, blah, indented,"
Lecture4_Chunk34,"slide. And that's it. That's all for the function definition. def blah, blah, blah, indented,
everything inside the function. So this is you writing the function definition.
Once the function definition's written, you can call the function. And that's this part down here.
And here, when you call function, you just say its name, and then you give it parameters. And
you give it as many parameters as the function is expecting-- in this case, only one parameter."
Lecture4_Chunk35,"you give it as many parameters as the function is expecting-- in this case, only one parameter.
So what's inside the function body? You can put anything inside the function body. You
remember, think of a function as sort of a small procedure or a little mini-program that does
something. So you can do anything inside the function that you can do in the regular program-
- print things, do mathematical operations, and so on."
Lecture4_Chunk36,"- print things, do mathematical operations, and so on.
The last line is the most important part of the function though. And it's this return statement--
that's what we call it. So it's a line of code that starts with return, which is a keyword. And then
it's going to be some value. Notice this is an expression here-- i%2 == 0 is an expression that's
going to evaluate to some value. And as long as this part is something that evaluates some
value, it can be anything you want."
Lecture4_Chunk37,"value, it can be anything you want.
And this line here return something tells Python, OK after you have finished executing
everything inside the function, what value should I return? And whoever called the function is
going to get back that value, and the function call itself will be replaced by that value.
OK so let's look at an example. I'm going to introduce the idea of scope now. And scope just
means-- is another word for environment. So if I told you that you could think of functions as"
Lecture4_Chunk38,"means-- is another word for environment. So if I told you that you could think of functions as
little mini-programs, the scope of a function is going to be a completely separate environment
than the environment of the main program.
So as soon as you make a function call, behind the scenes what Python says is, OK I'm in the
main program but I see a function call. I'm going to step out of this main program. I'm going to"
Lecture4_Chunk39,"main program but I see a function call. I'm going to step out of this main program. I'm going to
go off into this new environment. I'm going to create entirely new set of variables that just exist
within this environment. I'm going to do some computations. When I see the return, I'm going
to take this one return value. I'm going to exit that environment, and then I'm going to come
back to the main program."
Lecture4_Chunk40,"back to the main program.
So as you're entering from one scope to another, you're sort of passing these values back and
forth. So when you're entering a scope, you're passing a variable back into the function. And
when the function's finished, you're passing a value back to whoever called it.
So once again, this top part is the function definition. And any arguments for the function
definition are called formal parameters. And they're called formal parameters because notice"
Lecture4_Chunk41,"definition are called formal parameters. And they're called formal parameters because notice
they don't actually have a value yet. In the function definition, you're sort of writing the function
assuming that, in this case, x is going to have some value. But you don't know what it is yet.
You only know what value x takes when you make a function call down here.
So this is your function definition, and then later on in your main program, you might define"
Lecture4_Chunk42,"So this is your function definition, and then later on in your main program, you might define
some variable x is equal to 3. And then you make a function call. f of x here is your function
call. And it says, OK I'm calling f with the value 3, because x takes the value 3, and then I'm
going to map 3 into the function. The values that are passed into the function call are called
actual parameters, because they're going actually have a value."
Lecture4_Chunk43,"actual parameters, because they're going actually have a value.
So let's step through this program-- this small program-- and see what exactly happens behind
the scenes in the scope. And if you're just starting to program, I think it would be highly
valuable if you take a piece of paper as you're doing some of these exercises and you write
down something similar to what I'm going to go through here. I think it'll help a lot, and you'll"
Lecture4_Chunk44,"down something similar to what I'm going to go through here. I think it'll help a lot, and you'll
be able to see exactly step-by-step what variables take what values and which scope you're in.
So here we go. When the program first starts, we're creating this global scope. It's the main
program scope. In the main program scope, the first thing that Python is going to see is this
part here-- def f of x and then some stuff inside. This tells Python I have a function named x,"
Lecture4_Chunk45,"part here-- def f of x and then some stuff inside. This tells Python I have a function named x,
but I don't care what's inside the code yet. I don't care what's inside the function definition yet,
because I haven't called the function yet.
So to Python it's just some code just sitting in the global scope. So whenever you see def,
you're just putting some code in there. Then you go onto the next line-- x is equal to 3. So in"
Lecture4_Chunk46,"you're just putting some code in there. Then you go onto the next line-- x is equal to 3. So in
the global scope, you now have also a variable x is 3. And then the next line-- z is equal to f of
x is a function call. As soon as you hit a function call, you create a new scope-- a new
environment.
So we're temporarily leaving the global scope and sort of portaling into a new scope, where
we're going to try to figure out what this function's going to do and what it's going to return. So"
Lecture4_Chunk47,"we're going to try to figure out what this function's going to do and what it's going to return. So
the first thing you do is you map the parameters. So x here-- I'm calling f of x with 3-- so first
thing I'm doing is I'm mapping every one of the parameters in the definition to their values. So
first thing I'm doing is x gets the value 3.
Next line here is x is equal to x plus 1. So we're still inside the function call f, so x gets the"
Lecture4_Chunk48,"Next line here is x is equal to x plus 1. So we're still inside the function call f, so x gets the
value 4. We're printing this and then we're returning x. So in the scope of f, x is equal to 4, so
we're returning that value back to whoever called it, which was this function call within the
global scope. So this part right here-- f of x, which was the function call-- gets replaced with 4.
So inside the main program, z is equal to 4."
Lecture4_Chunk49,"So inside the main program, z is equal to 4.
And that's how we pass parameters into the function, and we got a parameter back from the
function. As soon as the function returns something, the scope that you were in for the
function gets erased. You forget about every variable that was created in there, delete that
scope, and you're back to wherever you started calling it.
One warning though. So what happens if there's no return statement? I said that every"
Lecture4_Chunk50,"One warning though. So what happens if there's no return statement? I said that every
function has to return something. If you don't explicitly put a return statement, Python is going
to add one for you. You don't have to do this. And it's going to actually have return None-- N-
o-n-e. And None is the special type-- None is the value for a special type called NoneType,
and it represents the absence of a value. What's that?
Not a string.
Not a--
None is not a string."
Lecture4_Chunk51,"and it represents the absence of a value. What's that?
Not a string.
Not a--
None is not a string.
None is not a string, exactly. It's a special type.
OK so before we go on, I wanted to go through a small exercise in Spyder just to show you the
difference that None and printing and returning makes. So here are two functions that I wrote.
One is is_even_with_return. That's its name, so pretty descriptive. It's pretty much the same"
Lecture4_Chunk52,"One is is_even_with_return. That's its name, so pretty descriptive. It's pretty much the same
code we saw in the slides. It just has this extra little print thing. It gets the remainder when i is
divided by 2. And it returns whether the remainder is equal to 0. So it'll either return a true or a
false-- a Boolean.
OK so my function call is this: I'm saying is_even_with_return with a value 3. When I make this"
Lecture4_Chunk53,"OK so my function call is this: I'm saying is_even_with_return with a value 3. When I make this
function call, this 3 gets mapped into here-- this variable here-- so i is equal to 3. I'm going to
print with return, and then I'm going to say remainder is equal to 3 percent 2, which comes out
to value 1, because there's a remainder 1. And I'm going to return whether 1 is equal to 0,
which is false."
Lecture4_Chunk54,"which is false.
So this line here returns false, but am I doing anything with the false? Not really. It's just sort of
sitting in the code here. So this gets evaluated to false. I'm not printing it. I'm not doing any
operations with it. It's just sitting there. So it won't show up anywhere. If I want the result to
show up somewhere, then I have to print it. So that's what this next line is doing. So that one
should be straightforward."
Lecture4_Chunk55,"should be straightforward.
is_even_without_return's a little bit trickier, but not too bad. I have print, without_return inside
here, and then I'm going to get a remainder is equal to i percent 2. And notice that I'm not-- I
don't have any return. So implicitly, Python's going to add a return None for me, like that. You
don't have to add it.
So when I make the function call here, it's going to do the same thing, except that return in this"
Lecture4_Chunk56,"So when I make the function call here, it's going to do the same thing, except that return in this
case is not going to be a Boolean. It's going to be this special None. So this is going to get
evaluated to None.
Again I'm not printing it out. It's just sitting there. If I were to print out the result of that, you'd
be printing out this value None, which if I run it, you'll see here it just prints it out right there."
Lecture4_Chunk57,"So as you're doing your next p set, it's about functions and you're seeing these Nones popping
out in some places. Check to make sure that you've actually returned something, as opposed
to just printed something inside the function like we did here. All right so that's the difference.
And the last thing I want to mention about this is_even function is how useful it can be. So
notice this is the function as in the slides, and once you write the function once, you can use it"
Lecture4_Chunk58,"notice this is the function as in the slides, and once you write the function once, you can use it
many, many times in your code. So here I'm using the function is_even to print the numbers
between 0 and 19, including and whether the number is even or odd.
So notice this piece of code here, once I've written this function is_even, looks really, really
nice right? I have for all the numbers in this range if the number i is even, this is going to"
Lecture4_Chunk59,"nice right? I have for all the numbers in this range if the number i is even, this is going to
return a true or false for all the numbers 0, 1, 2, 3, 4. If it's true, then I'm going to print out
even, and otherwise I'm going to print out odd.
So if I run this, it's going to do this. 0 even, 1 odd, 2 even, and so on. So notice using functions
makes my code really nice looking. If I wasn't using functions, I'd have to put these two lines"
Lecture4_Chunk60,"makes my code really nice looking. If I wasn't using functions, I'd have to put these two lines
somewhere inside here and it would look a little bit messier.
So I've said this maybe once or twice before: in Python everything is an object. Might not have
meant anything back then, but I think you're going to see what I mean using this particular
example. So if in Python everything's an object-- integers are objects, floats are objects, even"
Lecture4_Chunk61,"example. So if in Python everything's an object-- integers are objects, floats are objects, even
functions are objects. So as you can pass objects as parameters back and forth as function
parameters, you can also pass other functions as parameters.
Let's see what this means. So we have three function definitions here-- func_a, func_b, and
func_c. And then I have three lines of code here in my main program. So I have one called a"
Lecture4_Chunk62,"func_c. And then I have three lines of code here in my main program. So I have one called a
func_a, one called a func_b, and one call to func_c. Let's trace through, just like in the
previous example, and see what exactly happens.
First thing I create is my global scope. And I have three function definitions. Again I don't care
what's in the code yet, because I haven't called the functions yet. Python just knows there's
these functions with these names that contain some code."
Lecture4_Chunk63,"these functions with these names that contain some code.
After these definitions, I come to this line here-- print func_a. As soon as I make a function call,
I'm going to create a new scope and I'm going to hop into there. Inside func_a, I'm going to go
and look at what func_a does. It doesn't take in the parameters, it just prints out this message
here. And then it leaves; it's done. There's no return, so we return None. So func_a returns"
Lecture4_Chunk64,"here. And then it leaves; it's done. There's no return, so we return None. So func_a returns
None to whoever called it, which was that line there, so that is going to be None.
Next line. This one right here-- print 5 plus some function call. Again I'm going to hop into
func_b's scope and see what to do there. So first I'm going to map my parameters. So 2--
whoops-- 2 gets mapped to y. So inside func_b's scope, y is going to get the value 2."
Lecture4_Chunk65,"whoops-- 2 gets mapped to y. So inside func_b's scope, y is going to get the value 2.
That's the very first thing I'm doing-- mapping all the parameters. Then I'm going to print this
thing here, and then I'm going to return y. So inside func_b, y has the value 2, and I'm
returning 2 back to whoever called me. So this is the value 2 and I'm going to print 5 plus 2,
which is 7.
Last one. This is the trickiest. Oop, that popped up. If you think you've got it, try that exercise."
Lecture4_Chunk66,"Last one. This is the trickiest. Oop, that popped up. If you think you've got it, try that exercise.
But otherwise follow along. print func_c func_a. So I see that I am going to enter func_c's
scope. So I'm going to look at what func_c does.
First thing I do is I'm mapping all the parameters. Don't even worry about the fact that this is a
function right now. Just pretend it's x or something. So you say func_a is going to get mapped"
Lecture4_Chunk67,"function right now. Just pretend it's x or something. So you say func_a is going to get mapped
to the variable z inside func_c. So z is func_c. Just mapping parameters from actual to formal.
Then what do we do inside func_c? We print out inside func_c, and then we return z. This is
the cool part. Inside func_c, z is func_a. So if you replace z with func_a, this here becomes
return func_a open close parentheses. Look familiar? We did that function call right there"
Lecture4_Chunk68,"return func_a open close parentheses. Look familiar? We did that function call right there
right? So that's just another function call.
So with that being another function call, you're going to create another scope, and you're
going to pop into that one. So we're one, two, I guess two scopes deep, and we're trying to
figure out where we're going. So func_a's scope is going to be up here.
So what does func_a do? It just prints out this, and it returns None. So we're going to return"
Lecture4_Chunk69,"So what does func_a do? It just prints out this, and it returns None. So we're going to return
None to whoever called us, which was func_c. So this line here becomes return None. And so
this line here is going to return None to whoever called it, which was this line down here. Oops,
I didn't mean to cross that out. So that line here is going to print None.
So if you just go step-by-step, it shouldn't be too bad to try to map what happens with variable"
Lecture4_Chunk70,"So if you just go step-by-step, it shouldn't be too bad to try to map what happens with variable
names and formal parameters and actual parameters. That's why I highly recommend pieces
of paper and pens.
One last thing I want to mention about scope before we do another example. So there are
three sort of situations you might find yourself in. The first one is probably the most typical,
and this is when you define a function. And it's using a variable named x in this case that's also"
Lecture4_Chunk71,"and this is when you define a function. And it's using a variable named x in this case that's also
defined outside of the function. And that doesn't matter because of the idea of scopes.
So inside the global scope, you can have variables x. When you're inside a different scope,
you can have whatever variable names you want. And when you're inside that scope, Python's
going to use those variable names, so they don't interfere with each other at all. So in this"
Lecture4_Chunk72,"going to use those variable names, so they don't interfere with each other at all. So in this
example, I've defined a variable x is equal to 1, and then I incremented, and that doesn't
interfere with the fact that we have a variable x outside.
This one's a little bit trickier. I define this function g, and all g does is access a variable x. But
notice inside g, I've never actually declared or initialized a variable x. In this f, I said x is equal"
Lecture4_Chunk73,"to 1. But in here, I'm just sort of using x. So this does not give you an error. In fact it's OK for
you to do this in Python.
Python says, OK I'm in this scope, but I don't have a variable named x, so let me just go into
the scope of whoever called me. So I'm going to just temporarily hop out of the scope and see
is there variable x outside of me? And it'll find this variable x here, and it's going to print out its
values. So that's OK."
Lecture4_Chunk74,"values. So that's OK.
This last example here is actually not allowed in Python-- similar to this one-- except that I'm
trying to increment a value of x, but then I'm also trying to reassign it to the same value of x.
The problem with that is I never actually initialized x inside h. So if I said-- if inside h, I said x is
equal to 1, and then I did x plus equals to 1, then it would be this example here-- f of y. But I"
Lecture4_Chunk75,"equal to 1, and then I did x plus equals to 1, then it would be this example here-- f of y. But I
didn't do that. I just tried to access x and then incremented and then tried to reassign it. And
that's actually not allowed in Python.
There is a way around it using global variables. But it's actually frowned upon to use global
variables, though global variables are part of the readings for this lecture. And the reason why"
Lecture4_Chunk76,"variables, though global variables are part of the readings for this lecture. And the reason why
it's not a great idea to use global variables is because global variables sort of give you this
loophole around scopes, so it allows you to write code that can become very messy.
So using global variables, you can be inside a function and then modify a variable that's
defined outside of your function. And that sort of defeats the purpose of functions and using"
Lecture4_Chunk77,"defined outside of your function. And that sort of defeats the purpose of functions and using
them in writing these coherent modules that are separate. That said, it might sometimes be
useful to use global variables, as you'll see in a couple lectures from now.
OK cool. So let's go on to the last scope example. OK this slide is here, and notice I've bolded,
underlined, and italicized the Python Tutor, because I find it extremely helpful. So the Python"
Lecture4_Chunk78,"underlined, and italicized the Python Tutor, because I find it extremely helpful. So the Python
Tutor-- as I've mentioned in one of the assignments-- it was actually developed by a grad
student here, or post-grad student slash post-doc here.
And it allows you to go through Python, paste a code, go through it step-by-step. Like with
each iteration, it'll show you exactly what values each variable has, what scope you're in, when"
Lecture4_Chunk79,"each iteration, it'll show you exactly what values each variable has, what scope you're in, when
scopes get created, when scopes get destroyed, variables within each scope. So pretty much
every single detail you need to sort of understand functions.
As we're starting to-- you can see we've had couple questions, and these were great
questions. So if you're still trying to understand what's going on, I would highly suggest you"
Lecture4_Chunk80,"questions. So if you're still trying to understand what's going on, I would highly suggest you
take a piece of code and just run it in the Python Tutor and you should be able to see exactly
what happens, in sort of a similar way that I've drawn my diagrams.
In all of the codes for this particular lecture, I've put links to the Python Tutor for each one of
those exercises. So you can just copy and paste those, and it'll automatically populate it with"
Lecture4_Chunk81,"those exercises. So you can just copy and paste those, and it'll automatically populate it with
that particular example, so you just have to click, step, step, step. OK so having made my plug
for Python Tutor, let's go on.
OK so here's an example. It's going to show couple things. One is print versus return, and also
this idea of you can nest functions. So just like you could have nested loops, nested
conditionals-- you can also nest functions within functions. So let's draw some diagrams just"
Lecture4_Chunk82,"conditionals-- you can also nest functions within functions. So let's draw some diagrams just
like before of the scopes.
First thing we're going to do is when we have a program, we're going to create the global
scope and we're going to add every variable that we have. And then when we reach a function
call, we're going to do something about that. So the first thing in the global scope is this
function definition. Again in my global scope, I just have g as some code because I have not"
Lecture4_Chunk83,"function definition. Again in my global scope, I just have g as some code because I have not
called it yet. I only go inside a function when I make a function call.
So g contains some code. So we're done with 75% of that code. Next line is x is equal to 3. So
I'm making x be a variable inside my global scope with value 3. And then I have this z is equal
to g of x. This is a function call. When I see a function call, I'm going to create a new scope. So
here is the scope of g."
Lecture4_Chunk84,"here is the scope of g.
With the scope of g, I'm mapping variables to actual parameters to formal parameters. So the
first thing I'm doing is I'm saying inside g what is the value of actual parameter x? And x is
going to be the value 3, because I've called g of x with x is equal to 3.
Next, what I see inside this function-- so this is the inside of the function-- is this bit here. It's
another function definition. Again since I'm just defining the function and I'm not calling it, all"
Lecture4_Chunk85,"another function definition. Again since I'm just defining the function and I'm not calling it, all
Python sees is h is some code. I haven't called the function h yet, because I'm just defining it
here with def. So that finishes this part here.
The next line is x is equal to x plus 1. So inside the scope of g, I'm incrementing x to be 4.
Then I'm printing out this line. And then I've reached here-- h. This is actually a function call,"
Lecture4_Chunk86,"Then I'm printing out this line. And then I've reached here-- h. This is actually a function call,
and I'm calling h. As soon as I make a function call, I'm creating another scope. So I'm
temporarily going out of the scope of g and going into the scope of h.
So Python knows that h contains some code, and now I can go inside h and do whatever I
need to do. So the first-- so h doesn't have any parameters, so I don't need to populate"
Lecture4_Chunk87,"need to do. So the first-- so h doesn't have any parameters, so I don't need to populate
anything like that in there. h does define a variable called x, which is abc; it's a string. And then
that's all h does. What does it return? None.
I heard murmuring, but I think None was what you guys were saying. So since there's no
return statement, h is going to return None. So h returns None. Back to whoever called it,"
Lecture4_Chunk88,"return statement, h is going to return None. So h returns None. Back to whoever called it,
which was this code inside g. So that gets replaced with None-- the thing that I've-- this circled
red h here. As soon as h returns, we're going to get rid of that scope-- all the variables created
within it-- and we're done with h.
So now we're back into g. And we just finished executing this and this got replaced with None."
Lecture4_Chunk89,"So now we're back into g. And we just finished executing this and this got replaced with None.
We're not printing it out, so this doesn't show up anywhere; it's just there. So we're finished
with that line.
And the next line is return x. So x inside g is 4, so 4 gets returned back to whoever called it,
which was in the global scope here. So this gets replaced with 4. So once we've returned x,
we've completely exited out of the scope of g, and we've come back to whoever called us,"
Lecture4_Chunk90,"we've completely exited out of the scope of g, and we've come back to whoever called us,
which was global scope and we've replaced z is equal to g of x and that completely got
replaced with 4-- the returned value.
So that's sort of showing nested functions. All right just circling back to decomposition-
abstraction. This is the last slide. You can see if you look at the code associated with today's
lecture, there are some other examples where you can see just how powerful it is to use"
Lecture4_Chunk91,"lecture, there are some other examples where you can see just how powerful it is to use
functions. And you can write really clean and simple code if you define your own functions and
then just use them later.
And the beauty of defining your own functions that you can use multiple times later is you only
have to debug the function once right? I know debugging is not your favorite thing, but you
only have to debug this one thing once, and then you can know that it's right and it works well,"
Lecture4_Chunk92,"only have to debug this one thing once, and then you can know that it's right and it works well,
and you can just use it multiple times. All right thanks everyone."
Lecture5_Chunk1,"MITOCW | watch?v=RvRKT-jXvko
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
PROFESSOR:
Quick, quick recap of what we did last time. So last time we introduced this idea of"
Lecture5_Chunk2,"PROFESSOR:
Quick, quick recap of what we did last time. So last time we introduced this idea of
decomposition and abstraction. And we started putting that into our programs. And these were
sort of high level concepts, and we achieved them using these concrete things called functions
in our programs. And functions allowed us to create code that was coherent, that had some
structure to it, and was reusable. OK."
Lecture5_Chunk3,"structure to it, and was reusable. OK.
And from now on in problem sets and in lectures, I'm going to be using functions a lot. So
make sure that you understand how they work and all of those details. So today, we're going
to introduce two new data types. And they're called compound data types, because they're
actually data types that are made up of other data types, particularly ints, floats, Booleans, and"
Lecture5_Chunk4,"actually data types that are made up of other data types, particularly ints, floats, Booleans, and
strings. And actually not just these, but other data types as well. So that's why they're called
compound data types.
So we're going to look at a new data type called a tuple and a new data type called a list. And
then we're going to talk about these ideas that come about with-- specifically with lists.
All right. So let's go right into tuples. So if you recall strings, strings were sequences of"
Lecture5_Chunk5,"All right. So let's go right into tuples. So if you recall strings, strings were sequences of
characters. Tuples are going to be similar to strings in that they're going to be sequences of
something, except that tuples aren't just sequences of characters, they can be sequences of
anything. They're a collection of data where that data can be of any type.
So a tuple can contain elements that are integers, floats, strings, and so on. Tuples are"
Lecture5_Chunk6,"So a tuple can contain elements that are integers, floats, strings, and so on. Tuples are
immutable. And if you recall, we talked about this word a little bit when we talked about strings.
So that means once you create a tuple object, you can't modify it. So when you created a
string object, you were not allowed to modify it.
So the way we create tuples are with these open and close parentheses. This shouldn't be"
Lecture5_Chunk7,"So the way we create tuples are with these open and close parentheses. This shouldn't be
confused with a function, because there's nothing-- there's no-- this isn't a function call. It's just
how you represent a tuple. For a function call, you'd have something right before the
parentheses. This is just how we chose to represent a tuple. And just a plain open and close
parentheses represents an empty tuple. So it's of length 0. There's nothing in it."
Lecture5_Chunk8,"parentheses represents an empty tuple. So it's of length 0. There's nothing in it.
You can create a tuple that contains some elements by separating each element with a
comma. So in this case, this is a tuple that can be accessed with a variable t that contains
three elements. The first is an integer, the second is a string, and the third is another integer.
Much like strings, we can index into tuples to find out values at particular indices. So you read"
Lecture5_Chunk9,"Much like strings, we can index into tuples to find out values at particular indices. So you read
this as t at position 0. So the tuple represented by a variable t at position 0 will evaluate to 2,
because again, we start counting from 0 in computer science. So that brings us-- gives us the
first element.
Just like strings, we can concatenate tuples together. That just means add them together. So if
we add these two tuples together, we just get back one larger tuple that's just those two-- the"
Lecture5_Chunk10,"we add these two tuples together, we just get back one larger tuple that's just those two-- the
elements of those tuples just put together in one larger tuple. Again, much like strings, we can
slice into tuples. So t sliced from index 1 until index 2. Remember, we go until this stop minus
1. So this only gives us one element inside the tuple.
And this is not a mistake. This extra comma here actually represents a tuple object. If I didn't"
Lecture5_Chunk11,"And this is not a mistake. This extra comma here actually represents a tuple object. If I didn't
have this comma here, then this would just be a string. The parentheses would just-- wouldn't
really make any difference. But the comma here makes it clear to Python that this is a tuple
with only one element in it.
We can slice even further to get a tuple with two elements. And we can do the usual
operations like get the length of a tuple, which says, how many elements are in my tuple? And"
Lecture5_Chunk12,"operations like get the length of a tuple, which says, how many elements are in my tuple? And
len of this t would evaluate to 3, because there are three elements inside the tuple. Each
element, again, separated by the comma.
And just like strings, if we try to change a value inside the tuple-- in this case, I wanted to try to
change the value of the second element to 4-- Python doesn't allow that, because tuples are
immutable."
Lecture5_Chunk13,"immutable.
So why would we want to use tuples? Tuples are actually useful in a couple of different
scenarios. So recall a few years ago, we looked at this code where we tried to swap the values
of variables x and y. And this first code actually didn't work, because you're overwriting the
value for x. So instead, what we ended up doing was creating this temporary variable where
we stored the value of x, and then we overwrote it, and then we used the temporary variable."
Lecture5_Chunk14,"we stored the value of x, and then we overwrote it, and then we used the temporary variable.
Well, turns out this three liner code right here can actually be written in one line using tuples.
So you say x comma y is equal to y comma x. And Python goes in and says, what's the value
of y? And assigns it to x. And then what's the value of x? And assigns it to y.
Extending on that, we can actually use tuples to return more than one value from a function."
Lecture5_Chunk15,"Extending on that, we can actually use tuples to return more than one value from a function.
So functions, you're only allowed to return one object. So you're not allowed to return more
than one object. However, if we use a tuple object, and if that's the thing that we return, we
can actually get around this sort of rule by putting in as many values as we want inside the
tuple object. And then we can return as many values as we'd like."
Lecture5_Chunk16,"tuple object. And then we can return as many values as we'd like.
So in this specific example, I'm trying to calculate the quotient and remainder when we divide x
by a y. So this is a function definition here. And down here I'm calling the function with 4 and 5.
So when I make the function call, 4 gets assigned to x and 5 gets assigned to y. So then q is
going to be the integer division when x is divided by y. And this double slash just means-- it's"
Lecture5_Chunk17,"going to be the integer division when x is divided by y. And this double slash just means-- it's
like casting the result to an integer. It says divide it, keep the whole number part, and just
delete everything else beyond the decimal point.
So when you divide 4 by 5, this q is actually going to be 0, because it's 0 point something, and
I don't care about the point something. And then the remainder is just using the percent"
Lecture5_Chunk18,"I don't care about the point something. And then the remainder is just using the percent
operator. So I divide 4 by 5, the remainder is going to be 4. And notice that I'm going to be
returning q and r, which are these two values that I calculated inside my function. And I'm
returning them in the context of this tuple. So I'm only returning one object, which is a tuple. It
just so happens that I'm populating that object with a few different values."
Lecture5_Chunk19,"just so happens that I'm populating that object with a few different values.
So when the function returns here, this is going to say 0 comma 4. That's the tuple it's going to
return. Q is going to be 0 and r is going to be 4. So then this line here-- quot, rem equals 0, 4--
is basically this-- it's sort of like what we did up here. So it assigns quot to 4-- sorry. Quot to 0
and rem to 4. So we can use tuples. This is very useful. We can use them to return more than
one value from a function."
Lecture5_Chunk20,"one value from a function.
So tuples are great. Might seem a little bit confusing at first, but they're actually pretty useful,
because they hold collections of data. So here, I wrote a function which I can apply to any set
of data. And I'll explain what this function does, and then we can apply it to some data. And
you can see that you can extract some very basic information from whatever set of data that
you happen to collect."
Lecture5_Chunk21,"you happen to collect.
So here's a function called get_data, and it does all of this stuff in here. And in the actual code
associated with the lecture, I actually said what the condition on a tuple was. So it has to be a
tuple of a certain-- that looks a certain way. And this is the way it has to look.
So it's one tuple. The outer parentheses out here represent the fact that it's a tuple. And the
elements of this tuple are actually other tuples. So the first element is a tuple object, the"
Lecture5_Chunk22,"elements of this tuple are actually other tuples. So the first element is a tuple object, the
second element is a tuple object, and third one is a tuple object, and so on. And each one of
these inner tuple objects are actually going to contain two elements, the first being an integer
and the second being a string.
So that's sort of the precondition that this function assumes on a tuple before it can-- before it"
Lecture5_Chunk23,"So that's sort of the precondition that this function assumes on a tuple before it can-- before it
actually can work. All right. So given a tuple that looks like that, what's the function going to
do? It's first creating two empty tuple. One is called nums and one is called words. And then
there's a for loop. And notice here the for loop is going to iterate over every element inside the
tuple. Remember in strings when we were able to use for loops that iterated over the"
Lecture5_Chunk24,"tuple. Remember in strings when we were able to use for loops that iterated over the
characters directly as opposed to over the indices? Well, we're doing the same sort of thing
here. Instead of iterating over the indices, we're going to iterate over the tuple object at each
position.
So first time through the loop, t here is going to be this first tuple. The second time through the
loop, t is going to be this tuple. And the third time, it's going to be this exact tuple object."
Lecture5_Chunk25,"loop, t is going to be this tuple. And the third time, it's going to be this exact tuple object.
So each time through the loop, what I'm doing is I'm going to have this nums tuple that I'm
going to keep adding to. And each time I'm going to create a new object and reassign it to this
variable nums. And each time through the loop, I'm looking at what the previous value of nums
was. So what was my previous tuple? And I'm going to add it with this singleton tuple. So it's a"
Lecture5_Chunk26,"was. So what was my previous tuple? And I'm going to add it with this singleton tuple. So it's a
tuple of one character or one element. This element being t at position zero.
So you have to sort of wrap your mind around how this is working. So if t is going to be this
tuple element right here, then t at position zero is going to be this blue bar here. So it
represents the integer portion of the tuple."
Lecture5_Chunk27,"represents the integer portion of the tuple.
So as we're going through the loop, this nums is going to get populated with all of the integers
from every one of my tuple-- inside tuple objects. So that's basically what this line here is
doing. At the same time, I'm also populating this words tuple. And the words tuple is a little bit
different, because I'm not adding every single one of these string objects. So t at position one"
Lecture5_Chunk28,"different, because I'm not adding every single one of these string objects. So t at position one
being the string part of the inner tuple. I'm actually adding the string part only if it's not already
in my words list. So here, I'm essentially grabbing all of the unique strings from my list.
These last sort of three lines-- three, four lines here just do a little bit of arithmetic on it saying,
OK, now I have all of the numbers here, what's the minimum out of all of these, and then"
Lecture5_Chunk29,"OK, now I have all of the numbers here, what's the minimum out of all of these, and then
what's the maximum amount of all these? And then this unique words variable tells me how
many unique words do I have in my original tuple.
So this feels sort of generic, so let's run it on some data. So here I have it-- I tested it on some
test data. And then I got some actual data. And this actual data that I wanted to analyze was"
Lecture5_Chunk30,"test data. And then I got some actual data. And this actual data that I wanted to analyze was
Taylor Swift data. And representing the integer portion of the tuple representing a year and the
string portion of the tuple representing the person who she wrote a song about that year.
So some real world data that we're working with here. Very important that we know this
information. OK. So with this data, I can run it-- I can plug it into this function that I wrote up"
Lecture5_Chunk31,"information. OK. So with this data, I can run it-- I can plug it into this function that I wrote up
here. And I'm going to actually comment this out, so it doesn't get cluttered. And if I run it-- this
is the part where I'm calling my function. I'm calling it with this data here. tswift being this tuple
of tuples. And what I get back is-- up here, line 38-- is the return from the function being a
large tuple. And that large tuple, I'm then assigning it to my own tuple in my program. And then"
Lecture5_Chunk32,"large tuple. And that large tuple, I'm then assigning it to my own tuple in my program. And then
I'm just writing out-- printing out some statement here.
So I'm getting the minimum year, the maximum year, and then the number of people. So I can
show you that it works if I replace one of these names with another one that I already have in
here. So instead of writing a song about five people, she would have wrote a song about four
people. Yay, it worked."
Lecture5_Chunk33,"people. Yay, it worked.
So that's tuples. And remeber or recall-- keep in mind, tuples were immutable. Now we're
going to look at a very, very similar data structure to tuples called lists, except that instead of
lists being immutable, lists are going to be mutable objects. So much like lists, they're going to
contain elements of any type or objects of any type. You denote them with-- you denote a list
with square brackets instead of parentheses. And the difference being that they're going to be"
Lecture5_Chunk34,"with square brackets instead of parentheses. And the difference being that they're going to be
immutable objects instead of immutable.
So creating an empty list, you just do open close square brackets. You can have a list of
elements of different types, even a list of lists. So one of the elements being a list. As usual,
you can apply length on a list, and that tells you how many elements are in it. This is going to"
Lecture5_Chunk35,"you can apply length on a list, and that tells you how many elements are in it. This is going to
tell you how many elements are in your list l. So it's not going to look any further than that. So
it's going to say, this is an integer, this is a string, this is an integer, this is a list. It's not going
to say how many elements are in this list. It's just going to look at the outer-- the shell of
elements.
Indexing and slicing works the same way. So l at position 0 gives you the value 2. You can"
Lecture5_Chunk36,"elements.
Indexing and slicing works the same way. So l at position 0 gives you the value 2. You can
index into a list, and then do something with the value that you get back. So l at position 2
says-- that's this value there and add one to it. L at position 3, that's going to be this list here.
Notice it evaluates to another list.
You're not allowed to index outside of the length of the list. So that's going to give you an"
Lecture5_Chunk37,"You're not allowed to index outside of the length of the list. So that's going to give you an
error, because we only have four elements. And you can also have expressions for your index.
So this-- Python just replaces i with 2 here and says, what's l at position 1? And then grabs
that from in there.
OK. So very, very similar to the kinds of operations we've seen on strings and tuples. The one
difference, and that's what we're going to focus on for the rest of this class, is that lists are"
Lecture5_Chunk38,"difference, and that's what we're going to focus on for the rest of this class, is that lists are
mutable objects. So what does that mean internally? Internally, that means let's say we have a
list l, and we assign it-- sorry. Let's say we have a variable l that's going to point to a list with
three elements, 2, 1, and 3.
OK. They're all-- each element is an integer. When we were dealing with tuples or with strings,"
Lecture5_Chunk39,"OK. They're all-- each element is an integer. When we were dealing with tuples or with strings,
if we re-assign-- if we try to do this line right here, we've had an error. But this is actually
allowed with lists. So when you execute that line, Python is going to look at that middle
element, and it's going to change its value from a 1 to a 5. And that's just due to the mutability
nature of the list."
Lecture5_Chunk40,"nature of the list.
So notice that this list variable, this variable l, which originally pointed to this list, points to the
exact same list. We haven't created a new object in memory. We're just modifying the same
object in memory. And you're going to see why this is important as we look at a few side
effects that can happen when you have this.
So I've said this a couple of times before, but it'll make your life a lot easier if you try to think"
Lecture5_Chunk41,"of-- when you want to iterate through a list if you try to think about iterating through the
elements directly. It's a lot more Pythonic. I've used that word before.
So this is sort of a common pattern that you're going to see where you're iterating over the list
elements directly. We've done it over tuples. We've done it over strings. So these are identical
codes. They do the exact same thing, except on the left, you're going from-- you're going"
Lecture5_Chunk42,"codes. They do the exact same thing, except on the left, you're going from-- you're going
through 0, 1, 2, 3, and so on. And then you're indexing into each one of these numbers to get
the element value. Whereas on the right, this loop variable i is going to have the element value
itself. So this code on the right is a lot cleaner.
OK. So now let's look at some operations that we can do on lists. So there's a lot more"
Lecture5_Chunk43,"OK. So now let's look at some operations that we can do on lists. So there's a lot more
operations that we can do on lists, because of their mutability aspect than we can do on tuples
or strings, for example. So here's a few of them. And they're going to take advantage of this
mutability concept. So we can add elements directly to the end of the list using this funky
looking notation L.append. And then the element we want to add to the end. And this
operation mutates the list."
Lecture5_Chunk44,"operation mutates the list.
So if I have L is equal to 2, 1, 3, and I append the element 5 to the end, then L-- the same L is
going to point to the same object, except it's going to have an extra number at the end. 5. But
now what's this dot? We haven't really seen this before. And it's going to become apparent
what it means in a few lectures from now. But for the moment, you can think of this dot as an"
Lecture5_Chunk45,"what it means in a few lectures from now. But for the moment, you can think of this dot as an
operation. It's like applying a function, except that the function that you're applying can only
work on certain types of objects.
So in this case, append, for example, is the function we're trying to apply. And we want to
apply it to whatever is before the dot, which is the object. And append has only been defined"
Lecture5_Chunk46,"apply it to whatever is before the dot, which is the object. And append has only been defined
to work with a list object, for example, which is why we're using the dot in this case. We
wouldn't be able to use append on an integer, for example, because that sort of function is not
defined on the integer.
So for now, you'll sort of have to remember-- which are functions that work with a dot and
which are functions like [? ln, ?] that aren't with a dot. But in a couple of lectures, I promise it'll"
Lecture5_Chunk47,"be a lot clearer. So for now, just think of it as whatever is before the dot is the object you're
applying a function to, and whatever is after the dot is the function you're applying on the
object.
So we can add things to the end of our list. We can also combine lists together using the plus
operator. The plus operator does not mutate the list. Instead, it gives you a new list that's the
sum of those two lists combined. So in this case, if L1 is 2,1,3 and L2 is 4, 5, 6, when we add"
Lecture5_Chunk48,"sum of those two lists combined. So in this case, if L1 is 2,1,3 and L2 is 4, 5, 6, when we add
those two lists together, that's going to give us an entirely new list leaving L1 and L2 the same.
And that's why we have to assign the result of the addition to a new list. Otherwise, the result
is lost.
If you want to mutate a list directly and make it longer by the elements within another list, then
you can use this extend function or extent method. And this is going to mutate L1 directly. So if"
Lecture5_Chunk49,"you can use this extend function or extent method. And this is going to mutate L1 directly. So if
L1 was 2,1,3, if you extend it by the list 0,6, it's just going to tack on 0,6 to L1 directly. So
notice L1 has been mutated.
So that's adding things to lists. We can also delete things from lists. We don't just want to keep
adding to our lists, because then they become very, very big. So let's see how we can delete"
Lecture5_Chunk50,"adding to our lists, because then they become very, very big. So let's see how we can delete
some items from our list. There's a few ways. First one being can use this del function. And
this says delete from the list L the element at this index. So you give it the index 0, 1, 2, or
whatever you want to-- whatever index you want to delete the element at.
If you just want to delete the element at the end of the list, that's the farthest right, you do"
Lecture5_Chunk51,"If you just want to delete the element at the end of the list, that's the farthest right, you do
L.pop. If you want to remove a specific element-- so you know there's somewhere in your list
there's the number 5, and you want to delete it from the list-- then you say L.remove and you
say what element you want to remove. And that only removes the very first occurrence of it.
So if there's two fives in your list, then it's only going to remove the very first one."
Lecture5_Chunk52,"So if there's two fives in your list, then it's only going to remove the very first one.
So let's take a look at this sort of sequence of commands. So we have first L is equl to this
long list here. And I want to mention that all of these operations are going to mutate our list,
which is why I wrote this comment here that says assume that you're doing these in order. So
as you're doing these in order, you're going to be mutating your list. And if you're mutating"
Lecture5_Chunk53,"as you're doing these in order, you're going to be mutating your list. And if you're mutating
your list, you have to remember that you're working with this new mutated list.
So the first thing we're doing is we're removing 2 from our list. So when you remove 2, this
says look for an element with the value 2 and take it away from the list. So that's the very first
one here. So the list we're left with is just everything after it. Then I want to remove 3 from the"
Lecture5_Chunk54,"one here. So the list we're left with is just everything after it. Then I want to remove 3 from the
list and notice there's two of them. There's this 3 here and there's this 3 here. So we're going
to remove only the first one, which is this one here. So the list we're left with is 1,6,3,7,0.
Then we're going to delete from the list L the element at position 1. So starting counting from
0, the element at position 1 is this one here. So we've removed that, and we're left with 1, 3, 7,"
Lecture5_Chunk55,"0, the element at position 1 is this one here. So we've removed that, and we're left with 1, 3, 7,
0. And then when we do L.pop, that's going to delete the element furthest to the right. So at
the end of the list, which is that 0. So then we're left with only 1, 3, and 7. And L.pop is often
useful, because it tells you the return value from L.pop is going to be the value that it removed.
So in this case, it's going to return 0."
Lecture5_Chunk56,"So in this case, it's going to return 0.
I want to mention, though, that some of the-- so these functions all mutate the list. You have to
be careful with return values. So these are all-- you can think of all of these as functions that
be careful with return values. So these are all-- you can think of all of these as functions that
operate on the list. Except that what these functions do is they take in the list, and they modify"
Lecture5_Chunk57,"operate on the list. Except that what these functions do is they take in the list, and they modify
it. But as functions, they obviously return something back to whoever called them. And
oftentimes, they're going to return the value none.
So for example, if you are going to do L.remove 2, and you print that out, that might print out
none for you. So you can't just assign the value of this to a variable and expect it to be the"
Lecture5_Chunk58,"none for you. So you can't just assign the value of this to a variable and expect it to be the
mutated list. The list got mutated. The list that got mutated is the list that was passed into to
here. We're going look at one example in a few slides that's going to show this.
OK. Another thing that we can do, and this is often useful when you're working with data, is to
convert lists to strings and then strings to lists. Sometimes it might be useful to work with"
Lecture5_Chunk59,"convert lists to strings and then strings to lists. Sometimes it might be useful to work with
strings as opposed to a list and vice versa. So this first line here, list s takes in a string and
casts it to a list. So much like when we cast a float to an integer, for example. You're just
casting a string to a list here. And when you do that up this line-- so if this is your s here--
when you do list s, this is going to give you a list-- looks like this-- where every single character"
Lecture5_Chunk60,"in s is going to be its own element. So that means every character is going to be a string, and
it's going to be separated by a comma, so including spaces.
Sometimes you don't want each character in the list to be its own element. Sometimes you
want, for example, if you're given a sentence, you might want to have everything in between
spaces being its own element. So that will give you every word in the sentence, for example."
Lecture5_Chunk61,"spaces being its own element. So that will give you every word in the sentence, for example.
In that case, you're going to use split. In this case, I've split over the less than sign. But again,
if you're doing the sentence example, you might want to split on the space. So this is going to
take everything in between the sign that you're interested in-- in this case, the less than sign--
and it's going to set it as a separate element in the list. So that's how you convert strings to
lists."
Lecture5_Chunk62,"lists.
And sometimes you're given a list, and you might want to convert it to a string. So that's where
this join method or function is useful. So this is an empty string. So it's just open close quote
right away. No space. So this just joins every one of the elements in the list together. So it'll
return the string abc. And then you can join on any character that you would want. So in this
case, you can join on the underscore. So it'll put whatever characters in here in between every"
Lecture5_Chunk63,"case, you can join on the underscore. So it'll put whatever characters in here in between every
one of the elements in your list. So pretty useful functions.
OK. Couple other operations we can do on lists-- and these are also pretty useful-- is to sort
lists and to reverse lists and many, many others in the Python documentation. So sort and
sorted both sort lists, but one of them mutates the list and the other one does not. And"
Lecture5_Chunk64,"sorted both sort lists, but one of them mutates the list and the other one does not. And
sometimes it's useful to use one, and sometimes it's useful to use the other.
So if I have this list L is equal to 9,6,0,3, sorted-- you can think of it as giving me the sorted
version of L-- gives you back the sorted version of L. So it returns a new list that's the sorted
version of the input list and does not mutate L. So it keeps L the exact same way."
Lecture5_Chunk65,"version of the input list and does not mutate L. So it keeps L the exact same way.
So this will be replaced by the sorted version of the list, which you can assign to a variable,
and then do whatever you want with it. Like L2 is equal to sorted L, for example. And it keeps
L the same.
On the other hand, if you just want to mutate L, and you don't care about getting another copy
that's sorted, you just do L.sort. And that's going to automatically sort L for you, and L now-- L"
Lecture5_Chunk66,"that's sorted, you just do L.sort. And that's going to automatically sort L for you, and L now-- L
is now the sorted version of L. Similarly, reverse is going to take L and reverse all the
character-- all the elements in it. So the last one is the first one, the second to last one is the
second one, and so on.
So lists are mutable. We've said that so many times this lecture. But what exactly does that
mean? What implications does that have? Once again, this next part of the lecture, Python"
Lecture5_Chunk67,"mean? What implications does that have? Once again, this next part of the lecture, Python
tutor. Just paste all the code in and go step by step to see exactly what's happening.
So lists are mutable. As you have variable names-- so for example, L is equal to some list--
that L is going to be pointing to the list in memory. And since it's a mutable object, this list, you
can have more than one variable that points to the exact same object in memory. And if you"
Lecture5_Chunk68,"can have more than one variable that points to the exact same object in memory. And if you
have more than one variable that points to the same object in memory, if that object in
memory is changed, then when you access it through any one of these variables, they're all
going to give you the changed object value.
So the key phrase to keep in mind when you're dealing with lists is what side effects could"
Lecture5_Chunk69,"So the key phrase to keep in mind when you're dealing with lists is what side effects could
happen? If you're mutating a list, if you're doing operations on lists, what side effects-- what
variables might be affected by this change? Let's come back down to earth for a second. This
will wake a lot of people up.
So let's do an analogy with people. Let's say we have a person. A person-- this case, Justin"
Lecture5_Chunk70,"So let's do an analogy with people. Let's say we have a person. A person-- this case, Justin
Bieber-- is going to be an object. I'm an object. I'm like the number three. Bieber's an object.
He's like number five. Different objects. Were both of type people.
OK. Let's say a person has different attributes. Let's say we can-- let's say he gets two
attributes to begin with. He's a singer and he's rich. I can refer to this person object by many"
Lecture5_Chunk71,"attributes to begin with. He's a singer and he's rich. I can refer to this person object by many
different names. His full name, his stage name, all of the fan girls call him by these names,
people who dislike him call him by other names that they didn't put up here. But he's known by
all these different names. They're all aliases or nicknames that point to this same person
object.
OK. So originally, let's say I say Justin Bieber is a singer and rich. Those are the two attributes"
Lecture5_Chunk72,"OK. So originally, let's say I say Justin Bieber is a singer and rich. Those are the two attributes
I've originally assigned to him. And then let's say I want to assign a different attribute to him
and say Justin Bieber's a singer, rich, and a troublemaker. I'm being kind here.
OK. So if I say Justin Bieber has these three attributes-- so it's the same person I'm referring
to-- then all of his nicknames are going to refer to this exact same person. So all of his"
Lecture5_Chunk73,"to-- then all of his nicknames are going to refer to this exact same person. So all of his
nicknames or aliases will refer to the same person object with these changed attributes. Does
that makes sense? OK.
So that sort of idea arises in lists. So a list is like a person object whose value-- whose
attributes can change, for example. And as they change, all of the different aliases for this
object will point to this changed object."
Lecture5_Chunk74,"object will point to this changed object.
So let's see a few examples. I apologize if this is a little small, but this I basically copied and
pasted from the Python tutor, which is just from the code from today's lecture. So I have these
lines of code here. The first couple of lines really just show what happens when you're dealing
with non-mutable objects. So with non-mutable objects, you have two separate objects that get
their own values, and that's it. End of story."
Lecture5_Chunk75,"their own values, and that's it. End of story.
With lists, however, there's something different that happens. So I have warm is a variable.
And it's going to be equal to this list. So warm is going to point to this list here. Red, yellow,
orange. It contains three elements.
Hot is equal to warm. It means I'm creating an alias for this list. And the alias is going to be
with this variable hot. So notice warm and hot point to the exact same object. So on line 8"
Lecture5_Chunk76,"with this variable hot. So notice warm and hot point to the exact same object. So on line 8
when I append this string pink to my object, since both of these two variables point to the exact
same object, if I'm trying to access this object through either variable, they're both going to
print out the same thing. And that's the side effect. That's the side effect of lists mutable.
If you want to create an entirely new copy of the list, then you can clone it, which sounds really"
Lecture5_Chunk77,"If you want to create an entirely new copy of the list, then you can clone it, which sounds really
cool. But really, it's just making a copy of the list. And you clone it using this little notation here,
which is open close square brackets with a colon. And we've sort of seen this notation here.
And this tells Python this is 0-- sorry. This is 0 and this is length. Cool.
But it basically says take every element, create a new list with those exact same elements, and"
Lecture5_Chunk78,"But it basically says take every element, create a new list with those exact same elements, and
assign it to the variable chill. So here, if I originally have cool is equal to blue, green, gray right
here, when I clone it on line 2 with that funky notation, I'm creating a new copy of it. And then
on the next line when I'm appending another element to the copy, notice I'm just altering the
copy. The original stayed the same, because I've cloned it. So if you don't want to have the"
Lecture5_Chunk79,"copy. The original stayed the same, because I've cloned it. So if you don't want to have the
side effects-- side effect issue, then you should clone your variable-- your list.
So let's see a slightly more complicated example where you're going to see the difference
between sort and sorted in the context of this mutability and side effects issue. OK. So once
again, let's create this warm is equal to red, yellow, orange. So that's what warm is going to"
Lecture5_Chunk80,"again, let's create this warm is equal to red, yellow, orange. So that's what warm is going to
point to, this list. And then sorted warm is equal to warm.sort. So .sort mutates. So as soon as
I do that, that list warm is now the sorted version of it. And notice that I've assigned the return
of this to sorted warm. And the return is none, because L.sort or .sort mutated the list. It didn't
return a sorted version of the list. It mutated the list itself."
Lecture5_Chunk81,"return a sorted version of the list. It mutated the list itself.
OK. So when I print warm and I print sorted warm, I'm printing the mutated version and then
this one here. Sorted, on the other hand, returns-- it doesn't-- sorted does not sort the list
that's given to it. And instead, it returns a sorted version of the list.
So in this case, if cool is equal to these three colors-- gray, green, blue-- if I do sorted cool, it's"
Lecture5_Chunk82,"going to return the sorted version of that list, which is blue, green, gray. And it's assigned to
the variable sorted cool. So when I print them, it's going to show me the two separate lists.
One being the original unsorted one, and one being the sorted version.
Last ones a little bit more complicated, but it shows that even though you have nested-- even
though you can have nested lists, you still-- you're not-- you don't escape this idea of side"
Lecture5_Chunk83,"though you can have nested lists, you still-- you're not-- you don't escape this idea of side
effects. So first, I'm going to create warm is equal to these two colors, yellow, orange. So
warm points to these two colors. Hot is equal to this one list-- a list with one element. Bright
colors is going to be a list. And the element inside the list is a list itself.
So since it's a list-- this is your list, and the element inside here, which is a list itself, is actually"
Lecture5_Chunk84,"just pointing to whatever warm is. That object. Then I do-- then I append hot to my bright
colors. So the next element here is going to be another list, which means it's just pointing to
this other list here. It's not creating a copy of it.
So each one of these elements here is actually just pointing to these two lists here. So if I
modified either one of these, then bright colors would also be modified. So let's say I add pink"
Lecture5_Chunk85,"modified either one of these, then bright colors would also be modified. So let's say I add pink
here to my hot list. We have red and pink. Then notice that bright colors-- the first element
points to this list, and the second element points to this list, which I've just modified.
Last thing is-- I'll let you try this as an exercise in Python Tutor-- but the idea here being you
should be careful as you're writing a for loop that iterates over a list that you're modifying"
Lecture5_Chunk86,"should be careful as you're writing a for loop that iterates over a list that you're modifying
inside the list. In this case, I'm trying to go through the list L1. And if I find an item that's in L1
and L2, I want to delete it from L1.
So 1 and 2 are also in L2. So I want to delete them from L1 and be left with 3, 4. However, the
code on the left here doesn't actually do what I think it's doing, because here I'm modifying a"
Lecture5_Chunk87,"code on the left here doesn't actually do what I think it's doing, because here I'm modifying a
list as I'm iterating over it. And behind the scenes, Python keeps this-- keeps track of the index
and doesn't update the index as you're changing the list. So it figures out the length of the list
to begin with and how many indices it has. It doesn't update it as you're removing items from
the list.
So the solution to that is to make a copy of the list first, iterate over the copy, which will remain"
Lecture5_Chunk88,"intact, and modify the list that you want to modify inside the loop. So please run both of these
in the Python Tutor, and you'll see that what ends up happening is on the left, you're going to
skip over one element. So your code-- so that's going to be the wrong code. All right."
Lecture6_Chunk1,"MITOCW | watch?v=WPSeyjX1-4s
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
ERIC GRIMSON:
Ladies and gentlemen, I'd like to get started. My name's Eric Grimson. I have the privilege of"
Lecture6_Chunk2,"Ladies and gentlemen, I'd like to get started. My name's Eric Grimson. I have the privilege of
serving as MIT'S chancellor for academic advancement, you can go look up what that means,
and like John I'm a former head of course six. This term, with Ana and John, I'm going to be
splitting the lectures, so I'm up to date.
OK last time Ana introduced the first of the compound data types, tuples and lists. She showed"
Lecture6_Chunk3,"OK last time Ana introduced the first of the compound data types, tuples and lists. She showed
lots of ways of manipulating them, lots of built in things for manipulating those structures. And
the key difference between the two of them was that tuples were immutable, meaning you
could not change them, lists were mutable, they could be changed, or mutated. And that led to
both some nice power and some opportunities for challenges. And, in particular, she showed"
Lecture6_Chunk4,"both some nice power and some opportunities for challenges. And, in particular, she showed
you things like aliasing, where you could have two names pointing to the same list structure,
and because of that, you could change the contents of one, it would change the appearance
of the contents of the other, and that leads to some nice challenges. So the side effects of
mutability are one of the things you're going to see, both as a plus and minus, as we go
through the course."
Lecture6_Chunk5,"through the course.
Today we're going to take a different direction for a little while, we're going to talk about
recursion. It Is a powerful and wonderful tool for solving computational problems. We're then
going to look at another kind of compound data structure, a dictionary, which is also mutable.
And then we're going to put the two pieces together and show how together they actually give
you a lot of power for solving some really neat problems very effectively. But I want to start"
Lecture6_Chunk6,"you a lot of power for solving some really neat problems very effectively. But I want to start
with recursion. Perhaps one of the most mysterious, at least according to programmer's,
concepts in computer science, one that leads to lots of really bad computer science jokes,
actually all computer science jokes are bad, but these are particularly bad.
So let's start with the obvious question, what is recursion? If you go to the ultimate source of"
Lecture6_Chunk7,"So let's start with the obvious question, what is recursion? If you go to the ultimate source of
knowledge, Wikipedia, you get something that says, in essence, recursion is the process of
repeating items in a self-similar way. Well that's really helpful, right? But we're going to see
that idea because recursion, as we're going to see in a second, is the idea of taking a problem
and reducing it to a smaller version of the same problem, and using that idea to actually tackle"
Lecture6_Chunk8,"and reducing it to a smaller version of the same problem, and using that idea to actually tackle
a bunch of really interesting problems. But recursion gets used in a lot of places. So it's this
idea of using, or repeating, the idea multiple times. So wouldn't it be great if your 3D printer
printed 3D printers? And you could just keep doing that all the way along.
Or one that's a little more common, it's actually got a wonderful name, it's called mise en"
Lecture6_Chunk9,"Or one that's a little more common, it's actually got a wonderful name, it's called mise en
abyme, in art, sometimes referred to as the Droste effect, pictures that have inside them a
picture of the picture, which has inside them a picture of the picture, and you get the idea. And
of course, one of the things you want to think about in recursion is not to have it go on
infinitely. And yes there are even light bulb jokes about recursion, if you can't read it, it says,"
Lecture6_Chunk10,"infinitely. And yes there are even light bulb jokes about recursion, if you can't read it, it says,
how many twists does it take to screw in a light bulb? And it says, if it's already screwed in, the
answer is 0. Otherwise, twist it once, ask me again, add 1 to my answer. And that's actually a
nice description of recursion.
So let's look at it more seriously. What is recursion? I want to describe it both abstractly, or"
Lecture6_Chunk11,"So let's look at it more seriously. What is recursion? I want to describe it both abstractly, or
algorithmically, and semantically or, if you like, in terms of programming. Abstractly, this is a
great instance of something often called divide-and-conquer, or sometimes called decrease-
and-conquer. And the idea of recursion is, I want to take a problem I'm trying to solve and say,
how could I reduce it to a simpler version of the same problem, plus some things I know how"
Lecture6_Chunk12,"how could I reduce it to a simpler version of the same problem, plus some things I know how
to do? And then that simpler version, I'm going to reduce it again and keep doing that until I
get down to a simple case that I can solve directly. That is how we're going to think about
designing solutions to problems.
Semantically, this is typically going to lead to the case where a program, a definition of"
Lecture6_Chunk13,"Semantically, this is typically going to lead to the case where a program, a definition of
function, will refer to itself in its body. It will call itself inside its body. Now, if you remember
your high school geometry teacher, she probably would wrap your knuckles, which you're not
allowed to do, because in things like geometry you can't define something in terms of itself,
right? That's not allowed. In recursion, this is OK. Our definition of a procedure can in its body"
Lecture6_Chunk14,"right? That's not allowed. In recursion, this is OK. Our definition of a procedure can in its body
call itself, so long as I have what I call a base case, a way of stopping that unwinding of the
problems, when I get to something I can solve directly. And so what we're going to do is avoid
infinite recursion by ensuring that we have at least one or more base cases that are easy to
solve. And then the basic idea is I just want to solve the same problem on some simpler input"
Lecture6_Chunk15,"solve. And then the basic idea is I just want to solve the same problem on some simpler input
with the idea of using that solution to solve the larger problem.
OK, let's look at an example, and to set the stage I'm going to go back to something you've
been doing, iterative algorithms. For loops, while loops, they naturally lead to what we would
call iterative algorithms, and these algorithms can be described as being captured by a set of"
Lecture6_Chunk16,"call iterative algorithms, and these algorithms can be described as being captured by a set of
state variables, meaning one or more variables that tell us exactly the state of the
computation. That's a lot of words, let's look at an example. I know it's trivial, but bear with me.
Suppose I want to do integer multiplication, multiply two integers together, and all I have
available to me is addition. So a times b is the same as adding a to itself b times. If I'm thinking"
Lecture6_Chunk17,"available to me is addition. So a times b is the same as adding a to itself b times. If I'm thinking
about this iteratively, I could capture this computation with two state variables. One we'd just
call the iteration number, and it would be something, for example, that starts at b, and each
time through the loop reduces 1. One. And it will keep doing that until I've counted down b
times, and I get down to 0."
Lecture6_Chunk18,"times, and I get down to 0.
And at the same time, I would have some value of the computation, I might call it result, which
starts at 0, first time through adds an a, next time through adds an a, and it just keeps track of
how many things have I added up, until I get done. And yeah, I know you could just do mult,
but this is trying to get this idea of, how would I do this iteratively. So I might start off with i,"
Lecture6_Chunk19,"saying there are b things still to add, and the result is 1. The first time through the loop, I add
an a, reduce i by 1. Next time through the loop, I add in another a, reduce i by 1, and you get
the idea. I just walk down it until, eventually, I got to the end of this computation.
So we could write code for this, and, actually, it should be pretty straightforward. There it is.
Going to call it mult_iter, takes in two arguments a and b, and I'm going to capture exactly that"
Lecture6_Chunk20,"Going to call it mult_iter, takes in two arguments a and b, and I'm going to capture exactly that
process. So notice what I do, I set up result internally as just a little variable I'm going to use to
accumulate things. And then, there is the iteration, as long as b is greater than 0 what do I do?
Add a to result, store it away, reduce b by 1, and I'll keep doing that until b gets down to being
equal to 0, in which case I just return the result. OK, simple solution."
Lecture6_Chunk21,"equal to 0, in which case I just return the result. OK, simple solution.
Now, let's think about this a different way. A times b is just adding a to itself b times, and that's
the same as a plus adding a to a itself b minus 1 times. OK, that sounds like leisure to me, that
sounds like just playing with words. But it's really important, because what is this? Ah, that's
just a times b minus 1, by the definition of the top point. And I know you're totally impressed,"
Lecture6_Chunk22,"just a times b minus 1, by the definition of the top point. And I know you're totally impressed,
but this is actually really cool, because what have I done? I've taken one problem, this one up
here, and I've reduced it to a simpler version of the same problem, plus some things I know
how to do. And how would I solve this? Same trick, that's a times a times b minus 2, I would
just unwrap it one more time, and I would just keep doing that until I get down to something I"
Lecture6_Chunk23,"just unwrap it one more time, and I would just keep doing that until I get down to something I
can solve directly, a base case. And that's easy, when b equal to 1, the answer is just a. Or I
could do when b is equal to 0 the answer is just 0. And there's code to capture that.
Different form, wonderful compact description, what does it say? It says, if I'm at the base
case, if b is equal to 1, the answer is just a. Otherwise, I'm going to solve the same problem"
Lecture6_Chunk24,"case, if b is equal to 1, the answer is just a. Otherwise, I'm going to solve the same problem
with a smaller version and add it to a and return that result. And that's nice, crisp
characterization of a problem. Recursive definition that reduces a problem to a simpler version
of the same problem. OK, let's look at another example. Classic problem in recursion is to
compute factorial, right? n factorial, or n bang if you like, n exclamation point is n times n"
Lecture6_Chunk25,"compute factorial, right? n factorial, or n bang if you like, n exclamation point is n times n
minus 1, all the way down to 1. So it's the product of all the integers from 1 up to n assuming n
is a positive integer.
So we can ask the same question if I wanted to solve this recursively what would the base
case be? Well, when n is equal to 1, it's just 1. In the recursive case, will n times n minus 1 all"
Lecture6_Chunk26,"case be? Well, when n is equal to 1, it's just 1. In the recursive case, will n times n minus 1 all
the way down to 1, that's the same as n times n minus 1 factorial. So I can easily write out the
base case, and I've got a nice recursive solution to this problem. OK, if you're like me and this
is the first time you've seen it, it feels like I've taken your head and twisted it about 180
degrees. I'm going to take it another 180 degrees because you might be saying, well, wait a"
Lecture6_Chunk27,"degrees. I'm going to take it another 180 degrees because you might be saying, well, wait a
minute, how do you know it really stops. How do you know it really terminates the
computation? So let's look at it.
There is my definition for fact, short for factorial. Fact of 1 is, if n is equal to 1 return 1,
otherwise return n times fact of n minus 1. And let's use the tools that Ana talked about, in
terms of an environment at a scope, and think about what happens here. So when I read that"
Lecture6_Chunk28,"terms of an environment at a scope, and think about what happens here. So when I read that
in or I evaluate that in Python, it creates a definition that binds the name fact to some code,
just all of that stuff over here plus the name for the formal parameter, hasn't done anything
with it yet.
And then I'm going to evaluate print a fact of 4. Print needs a value, so it has to get the value
of fact of 4, and we know what that does. It looks up fact, there it is, it's procedure definition."
Lecture6_Chunk29,"of fact of 4, and we know what that does. It looks up fact, there it is, it's procedure definition.
So it creates a new frame, a new environment, it calls that procedure, and inside that frame
the formal parameter for fact is bound to the value passed in. So n is bound to 4. That frame is
scoped by this global frame meaning it's going to inherit things in the global frame. And what
does it do? It says, inside of this frame evaluate the body of fact. OK, so it says as n equal to"
Lecture6_Chunk30,"does it do? It says, inside of this frame evaluate the body of fact. OK, so it says as n equal to
1? Nope, it's not, it's 4. So in that case, go to the else statement and says, oh, return n times
fact of n and n as 4, fact of n minus 1 says I need to return 4 times fact of 3.
4 is easy, multiplication is easy, fact of 3, ah yes, I look up fact. Now I'm in this frame, I don't
see fact there, but I go up to that frame. There's the definition for fact, and we're going to do"
Lecture6_Chunk31,"see fact there, but I go up to that frame. There's the definition for fact, and we're going to do
the rest of this a little more quickly, what does that do? It creates a new frame called by fact.
And the argument passed in for n is n minus 1, that value, right there, of 3. So 3 is now bound
to n. Same game, evaluate the body is n equal to 1? No, so in that case, I'm going to go to the
return statement, it says return 3 times fact of 2. And notice it's only looking at this value of n"
Lecture6_Chunk32,"return statement, it says return 3 times fact of 2. And notice it's only looking at this value of n
because that's the frame in which I'm in. It never sees that value of n.
OK, aren't you glad I didn't do fact of 400? We've only got two more to go, but you get the
idea. Same thing, I need to get fact of 2 is going to call fact again with n bound to 2. Relative
that evaluates the body and is not yet equal to 1. That says I'm going to the else clause and"
Lecture6_Chunk33,"that evaluates the body and is not yet equal to 1. That says I'm going to the else clause and
return 2 times fact of 1. I call fact again, now with n bound to 1, and, fortunately, now that
clause is true, and it says return 1. Whoops, sorry, before I do, so there's the base case. And it
may seem apparent to you, but this is important, right? I'm unwinding this till I get to something
that can stop the computation. Now I'm simply going to gather the computation up, because it"
Lecture6_Chunk34,"that can stop the computation. Now I'm simply going to gather the computation up, because it
says return 1. Who asked for it? Well that call to fact of 1. So that reduces to return 2 times 1.
And who called for that? Fact of 2. That reduces to return a 3 times 2, which reduces to 4
times 6, which reduces to printing out 24. So it unwinds it down to a base case and it stops.
A couple of observations, notice how each recursive call creates its own frame, and as a"
Lecture6_Chunk35,"A couple of observations, notice how each recursive call creates its own frame, and as a
consequence, there's no confusion about which value of n I'm using. Also notice, in the other
frames, n was not changed. We did not mutate it. So we're literally creating a local scope for
that recursive call, which is exactly what we want. Also notice how there was a sense of flow of
control in computing fact of something, that reduces to returning n times fact of n minus 1, and"
Lecture6_Chunk36,"control in computing fact of something, that reduces to returning n times fact of n minus 1, and
that creates a new scope. And that will simply keep unwinding until I get to something that can
return a value and then I gather all those frames back up. So there's a natural flow of control
here. But most importantly, there's no confusion about which variable I'm using when I'm
looking for a value of n."
Lecture6_Chunk37,"looking for a value of n.
All right, because this is often a place where things get a little confusing, I want to do one more
example. But let me first show you side by side the two different versions of factorial. Actually, I
have lied slightly, we didn't show this one earlier but there's factorial if I wanted to do it
iteratively. I'd set up some initial variable to 1, and then I'd just run through a loop. For"
Lecture6_Chunk38,"iteratively. I'd set up some initial variable to 1, and then I'd just run through a loop. For
example, from 1 up to just below n minus 1, or 1 up to n, multiplying it and putting it back into
return product.
Which one do you like more? You can't say neither you have to pick one. Show of hands, how
many of you like this one? Some hesitant ones, how many prefer this one? Yeah, that's my
view. I'm biased, but I really like the recursive one. It is crisper to look at, you can see what it's"
Lecture6_Chunk39,"doing. I'm reducing this problem to a simpler version of that problem. Pick your own version
but I would argue that the recursive version is more intuitive to understand. From a
programmer's perspective, it's actually often more efficient to write, because I don't have to
think about interior variables. Depending on the machine, it may not be as efficient when you
call it because in the recursive version I've got it set up, that set of frames. And some versions"
Lecture6_Chunk40,"call it because in the recursive version I've got it set up, that set of frames. And some versions
of these languages are actually very efficient about it, some of them a little less so. But given
the speed of computers today, who cares as long as it actually just does the computation.
Right, one more example, how do we really know our recursive code works? Well, we just did
a simulation but let's look at it one more way. The iterative version, what can I say about it?"
Lecture6_Chunk41,"a simulation but let's look at it one more way. The iterative version, what can I say about it?
Well, I know it's going to terminate because b is initially positive, assuming I gave it an
appropriate value. It decreases by 1 every time around this loop, at some point it has to get
less than 1, it's going to stop. So I can conclude it's always going to terminate. What about the
recursive version? Well, if I call it with b equal to one, I'm done. If I call it with b greater than"
Lecture6_Chunk42,"one, again it's going to reduce it by one on the recursive call, which means on each recursive
call it's going to reduce and eventually it gets down to a place, assuming I gave it a positive
integer, where b is equal to one. So it'll stop, which just good.
What we just did was we used the great tool from math, second best department at MIT. Wow,
I didn't even get any hisses on that one, John, all right, and I'm now in trouble with the head of"
Lecture6_Chunk43,"I didn't even get any hisses on that one, John, all right, and I'm now in trouble with the head of
the math department. So now that I got your attention, and yes, all computer science jokes are
bad, and mine are really bad, but I'm tenured. You cannot do a damn thing about it.
Let's look at mathematical induction which turns out to be a tool that lets us think about
programs in a really nice way. You haven't seen this, here's the idea of mathematical"
Lecture6_Chunk44,"programs in a really nice way. You haven't seen this, here's the idea of mathematical
induction. If I want to prove a statement, and we refer to it as being indexed on the integers. In
other words, it's some mathematical statement that runs over integers. If I want to prove it's
true for all values of those integers, mathematically I'd do it by simply proving it's true for the
smallest value of n typically n is equal to 0 or 1, and then I do an interesting thing. I say I need"
Lecture6_Chunk45,"smallest value of n typically n is equal to 0 or 1, and then I do an interesting thing. I say I need
to prove that if it's true for an arbitrary value of n, I'm just going to prove that it's also then true
for n plus 1. And if I can do those two things I can then conclude for an infinite number of
values of n it's always true.
Then we'll relate it back to programming in a second, but let me show you a simple example of"
Lecture6_Chunk46,"Then we'll relate it back to programming in a second, but let me show you a simple example of
this, one that you may have seen. If I had the integers from 0 up to n, or even from 1 up to n, I
claim that's the same as n times n plus 1 over 2. So 1, 2, 3, that's 6, right. And that's exactly
right, 3 times 4, which is divided by 2, which gives me out 6. How would I prove this? Well, by
induction? I need to do the simple cases if n is equal to 0, well then this side is just 0. And"
Lecture6_Chunk47,"induction? I need to do the simple cases if n is equal to 0, well then this side is just 0. And
that's 0 times 1, which is 0 divided by true. So 0 equals 0, it's true.
Now the inductive step. I'm going to assume it's true for some k, I should have picked n, but
for some k, and then what I need to show is it's true for k plus 1. Well, there's the left hand
side, and I want to show that this is equal to that. And I'm going do it by using exactly this"
Lecture6_Chunk48,"side, and I want to show that this is equal to that. And I'm going do it by using exactly this
recursive idea, because what do I know, I know that this sum, in here, I'm assuming is true.
And so that says that the left hand side, the first portion of it, is just k times k plus 1 over 2,
that's the definition of the thing I'm assuming is true. To that I'm going to add k plus 1. Well,
you can do the algebra, right? That's k plus 1 all times k over 2 plus 1, which is k plus 2 over 2."
Lecture6_Chunk49,"you can do the algebra, right? That's k plus 1 all times k over 2 plus 1, which is k plus 2 over 2.
Oh cool, it's exactly that. Having done that, I can now conclude this is true for all values of n.
What does it have to do with programming? That's exactly what we're doing when we think
about recursive code, right? We're saying, show that it's true for the base case, and then what
I'm essentially assuming is that, if it works for values smaller than b, then does the code return"
Lecture6_Chunk50,"I'm essentially assuming is that, if it works for values smaller than b, then does the code return
the right answer for b? And the answer is, absolutely it does, and I'm using induction to
deduce that, in fact, my code does the right thing. Why am I torturing you with this? Because
this is the way I want you to think about recursion. When I'm going to break a problem down
into a smaller version of the same problem, I can assume that the smaller version gives the"
Lecture6_Chunk51,"into a smaller version of the same problem, I can assume that the smaller version gives the
answer. All I have to do is make sure that what I combined together gives me out the right
result.
OK, you may be wondering what I'm doing with these wonderful high tech toys down here. I
want to show you another example of recursion. So far we've seen simple things that have just
had one base case, and this is a mythical story called The towers of Hanoi and this story, as I"
Lecture6_Chunk52,"had one base case, and this is a mythical story called The towers of Hanoi and this story, as I
heard it, is there's a temporal somewhere in Hanoi with three tall spikes and 64 jewel-
encrusted golden disks all of a different size. They all started out on one spike with the
property that they were ordered from smallest down to largest.
And there are priests in this temple who are moving the disks one at a time, one per second,"
Lecture6_Chunk53,"And there are priests in this temple who are moving the disks one at a time, one per second,
and their goal is to move the entire stack from one spike to another spike. And when they do
nirvana is achieved and we all get a really great life. We'll talk separately about how long is this
going to take because there's one trick to it. They can never cover a smaller disk with a larger
disk as they're doing it, so they've got a third disk as a temporary thing. And I want to show"
Lecture6_Chunk54,"disk as they're doing it, so they've got a third disk as a temporary thing. And I want to show
you how to solve this problem because you're going to write code with my help in a second, or
I'm going to write code with your help in a second to solve it.
So let's look at it, so watch carefully, moving a disk of size one, well that's pretty easy, right?
Moving a disk of size two, we'll just put this one on the spare one while you move it over so"
Lecture6_Chunk55,"Moving a disk of size two, we'll just put this one on the spare one while you move it over so
you don't cover it up. That's easy. Moving a disk of size three, you've got be a little more
careful, you can't cover up a smaller one with a larger one, so you have to really think about
where you're putting it. It would help with these things didn't juggle and there you go, you got it
done. All right, you're watching? You've got to do four. To do four, again, you've got to be"
Lecture6_Chunk56,"done. All right, you're watching? You've got to do four. To do four, again, you've got to be
really careful not to cover things up as you do this. You want to get the bottom one eventually
exposed, and so are you going to pull that one over there. If you do the pattern really well, you
won't notice if I make a serious mistake as I'm doing this, which I just did. But I'm going to
recover from that and do it that way to put this one over here, and that one goes there, and if I"
Lecture6_Chunk57,"recover from that and do it that way to put this one over here, and that one goes there, and if I
did this in Harvard Square I could make money. There you go, right?
OK, got the solution? See how to solve it? Could you write code for this? Eh, maybe not.
That's on the quiz, thanks, John, don't tell them on the quiz, damn. All right, I want to claim
though that in fact there's a beautiful recursive solution. And here's the way to think about it"
Lecture6_Chunk58,"though that in fact there's a beautiful recursive solution. And here's the way to think about it
recursively. I want to move a tower of size n, I'm going to assume I can move smaller towers
and then it's really easy. What do I do, I take a stack of size n minus 1, I move it onto the
spare one, I move the bottom one over, and then I move a stack of size n minus 1 to there,
beautiful, recursive solution. And how do I move the smaller stack? Just the same way, I just"
Lecture6_Chunk59,"beautiful, recursive solution. And how do I move the smaller stack? Just the same way, I just
unwind it, simple, and, in fact, the code follows exactly that.
OK, I do a little [INAUDIBLE] domain up here to try and get your attention, but notice by doing
that what did I do? I asked you to think about it recursively, the recursive solution, when you
see it, is in fact very straightforward, and there's the code. Dead trivial, well, that trivial is"
Lecture6_Chunk60,"see it, is in fact very straightforward, and there's the code. Dead trivial, well, that trivial is
unfair, but it's very simple. Right? I simply write something, so let me describe it, I need to say
how big of tower am I moving and I'm going to label the three stacks a from, a to, and a spare.
I have a little procedure that just prints out the move for me, and then what's the solution? If
it's just a stack of size one, just print the move, take it to from-- from from to to. Otherwise,"
Lecture6_Chunk61,"it's just a stack of size one, just print the move, take it to from-- from from to to. Otherwise,
move a tower of size n minus 1 from the from spot to the spare spot, then move what's left of
tower size one from to two, and then take that thing are stuck on spare and move it over to
two, and I'm done.
In that code that we handed out, you'll see this code, you can run it. I'm not going to print it out"
Lecture6_Chunk62,"In that code that we handed out, you'll see this code, you can run it. I'm not going to print it out
because, if I did, you are just going to say, OK, it looks like it does the right kind of thing. Look
at the code, nice and easy, and that's what we like you to do when you're given a problem. We
asked you to think about recursively. How do I solve this with a smaller version of the same
problem? And then how do I use that to build the larger solution? This case is a little different."
Lecture6_Chunk63,"problem? And then how do I use that to build the larger solution? This case is a little different.
You could argue that this is not really a recursive call here, it's just moving the bottom one, I
could have done that directly. But I've got two recursive calls in the body here. I have to move
a smaller stack twice. We're going to come back to that in a little bit.
Let me show you one other example of recursion that runs a little bit differently. In this case it's"
Lecture6_Chunk64,"Let me show you one other example of recursion that runs a little bit differently. In this case it's
going to have multiple base cases and this is another very old problem, it's called the
Fibonacci numbers. It's based on something from several centuries ago when a gentleman,
named Leonardo of Pisa, also known as Fibonacci, asked the following challenge. He said, I'm
going to put a newborn pair of rabbits, one male and one female, into an enclosure, a pan of"
Lecture6_Chunk65,"going to put a newborn pair of rabbits, one male and one female, into an enclosure, a pan of
some sort. And the rabbits have the following properties, they mate at age one month, so they
take a month to mature. After a one month gestation period, they produce another pair of
rabbits, a male and a female, and he says I'm going to assume that the rabbits never die. So
each month mature females are going to produce another pair. And his question was, how"
Lecture6_Chunk66,"each month mature females are going to produce another pair. And his question was, how
many female rabbits are there at the end of a year, or two years, or three years?
The idea is, I start off with two immature rabbits, after one month they've matured, which
means after another month, they will have produced a new pair. After another month, that
mature pair has produced another pair, and the immature pair has matured. Which means,"
Lecture6_Chunk67,"mature pair has produced another pair, and the immature pair has matured. Which means,
after another month, those two mature pairs are going to produce offspring, and that immature
pair has matured. And you get the idea, and after several months, you get to Australia. You
can also see this is going to be interesting to think about how do you compute this, but what I
want you to see is the recursive solution to it. So how could we capture this?"
Lecture6_Chunk68,"want you to see is the recursive solution to it. So how could we capture this?
Well here's another way of thinking about it, after the first month, and I know we're going to do
this funny thing, we're going to index it 0, so call it month 0. There is 1 female which is
immature. After the second month, that female is mature and now pregnant which means after
the third month it has produced an offspring. And more generally, that the n-th month, after we"
Lecture6_Chunk69,"the third month it has produced an offspring. And more generally, that the n-th month, after we
get past the first few cases, what do we have? Any female that was there two months ago has
produced an offspring. Because it's taken at least one month to mature, if it hasn't already
been mature, and then it's going to produce an offspring. And any female that was around last
month is still around because they never die off."
Lecture6_Chunk70,"month is still around because they never die off.
So this is a little different. This is now the number of females at month n is the number of
females T month n minus 1, plus the number of females and month n minus 2. So two
recursive calls, but with different arguments. Different from towers of Hanoi, where there were
two recursive calls, but with the same sized problem. So now I need two base cases, one for"
Lecture6_Chunk71,"two recursive calls, but with the same sized problem. So now I need two base cases, one for
when n is equal to 0, one for when n is equal to 1. And then I've got that recursive case, so
there's a nice little piece of code. Fibonacci, I'm going to assume x is an integer greater than
or equal to 0. I'm going to return Fibonacci of x. And you can see now it says, if either x is
equal to 0 or x is equal to 1 I'm going to return 1, otherwise, reduce it to two simpler versions"
Lecture6_Chunk72,"equal to 0 or x is equal to 1 I'm going to return 1, otherwise, reduce it to two simpler versions
of the problem but with different arguments, and I add them up.
OK, and if we go look at this, we can actually run this, if I can find my code. Which is right
there, and I'm just going to, so we can, for example, check it by saying fib of 0. I just hit a bug
which I don't see. Let me try it again. I'll try it one more time with fib of 0. Darn, it's wrong, let"
Lecture6_Chunk73,"me try it. I've got two different versions of fib in here, that's what I've got going on. So let me
do it again, let's do fib of 1. There we go, fib of 2 which is 2, fib of 3 just three, and fib of 4
which should add the previous two, which gives me 5. There we go. Sorry about that, I had
two versions of fib in my file, which is why it complained at me. And which is why you should
always read the error instructions because it tells you what you did wrong. Let's go on and"
Lecture6_Chunk74,"always read the error instructions because it tells you what you did wrong. Let's go on and
look at one more example of doing recursion, and we're going to do dictionaries, and then
we're going to pull it all together.
So far we've been doing recursion on numerical things, we can do it on non-numerical things.
So a nice way of thinking about this is, how would I tell if a string of characters is a
palindrome? Meaning it reads the same backwards and forwards. Probably the most famous"
Lecture6_Chunk75,"palindrome? Meaning it reads the same backwards and forwards. Probably the most famous
palindrome is attributed to Napoleon ""Able was I ere I saw Elba."" Given that Napoleon was
French, I really doubt he said ""Able was I ere I saw Elba,"" but it's a great palindrome. Or
another one attributed to Anne Michaels ""Are we not drawn we few drawn onward to a new
era,"" reads the same backwards and forwards. It's fun to think about how do you create the
palindromes."
Lecture6_Chunk76,"palindromes.
I want to write code to solve this. Again, I want to think about it recursively, so here's what I'm
going to do. I'm first going to take a string of characters, reduce them all to lowercase, and
strip out spaces and punctuation. I just want the characters. And once I got that, I want to say,
is that string, that list of characters or that collection of characters as I should say, a
palindrome? And I'm going to think about it recursively, and that's actually pretty easy. If it's"
Lecture6_Chunk77,"palindrome? And I'm going to think about it recursively, and that's actually pretty easy. If it's
either 0 or 1 long, it's a palindrome. Otherwise you could think about having an index at each
end of this thing and sort of counting into the middle, but it's much easier to say take the two at
the end, if they're the same, then check to see what's left in the middle is a palindrome, and if
those two properties are true, I'm done. And notice what I just did I nicely reduced a bigger"
Lecture6_Chunk78,"those two properties are true, I'm done. And notice what I just did I nicely reduced a bigger
problem to a slightly smaller problem. It's exactly what I want to do.
OK? So it says to check is this, I'm going to reduce it to just the string of characters, and then
I'm going to check if that's a palindrome by pulling those two off and checking to see they're
the same, and then checking to see if the middle is itself a palindrome. How would I write it?"
Lecture6_Chunk79,"the same, and then checking to see if the middle is itself a palindrome. How would I write it?
I'm going to create a procedure up here, isPalindrome. I'm going to have inside of it two
internal procedures that do the work for me. The first one is simply going to reduce this to all
lowercase with no spaces. And notice what I can do because s is a string of characters. I can
use the built in string method lower, so there's that dot notation, s.lower. It says. apply the"
Lecture6_Chunk80,"use the built in string method lower, so there's that dot notation, s.lower. It says. apply the
method lower to a string. I need an open and close per end to actually call that procedure, and
that will mutate s to just be all lowercase.
And then I'm going to run a little loop, I'll set up answer or ans to be an empty string, and then,
for everything inside that mutated string, I'll simply say, if it's inside this string, if it's a letter,"
Lecture6_Chunk81,"add it into answer. If it's a space or comma or something else I'll ignore it, and when I'm done
just return answer, strips it down to lowercase. And then I'm going to pass that into isPal which
simply says, if this is either 0 or 1 long, it's a palindrome, returned true. Otherwise, check to
see that the first and last element of the string are the same, notice the indexing to get into the
last element, and similarly just slice into the string, ignoring the first and last element, and ask"
Lecture6_Chunk82,"last element, and similarly just slice into the string, ignoring the first and last element, and ask
is that a palindrome. And then just call it, and that will do it. And again there's a nice example
of that in the code I'm not going to run it, I'll let you just go look at it, but it will actually pull out
something that checks, is this a palindrome.
Notice again, what I'm doing here. I'm doing divide-and-conquer. I'm taking a problem"
Lecture6_Chunk83,"Notice again, what I'm doing here. I'm doing divide-and-conquer. I'm taking a problem
reducing it, I keep saying this, to a simpler version of the same problem. Keep unwinding it till I
get down to something I can solve directly, my base case and I'm done. And that's really the
heart of thinking about recursive solutions to problems. I would hope that one of the things I
remember, besides my really lousy patter up here, is the idea of Towers of Hanoi, because to"
Lecture6_Chunk84,"remember, besides my really lousy patter up here, is the idea of Towers of Hanoi, because to
me it's one of the nicest examples of a problem that would be hard to solve iteratively, but
when you see the recursive solution is pretty straightforward. Keep that in mind as you think
about doing recursion.
OK, let's switch gears, and let's talk very briefly about another kind of data type called a
dictionary. And the idea of a dictionary I'm going to motivate with a simple example. There's a"
Lecture6_Chunk85,"dictionary. And the idea of a dictionary I'm going to motivate with a simple example. There's a
quiz coming up on Thursday. I know you don't want to hear that, but there is, which means
we're going to be recording grades. And so imagine I wanted to build a little database just to
keep track of grades of students. So one of the ways I could do it, I could create a list with the
names of the students, I could create another list with their grades, and a third list with the"
Lecture6_Chunk86,"names of the students, I could create another list with their grades, and a third list with the
actual subject or course from which they got that great. I keep a separate list for each one of
them, keep them of the same length, and in essence, what I'm doing here is I'm storing
information at the same index in each list. So Ana, who's going to have to take the class again,
gets a B, John, who's created the class, gets an A plus, Sorry Ana, John's had a longer time at
it."
Lecture6_Chunk87,"gets a B, John, who's created the class, gets an A plus, Sorry Ana, John's had a longer time at
it.
All right, bad jokes aside, what I'm doing is I can imagine just creating lists. I could create lists
of lists, but a simple way is to do lists where basically at each index I've got associated
information. It's a simple way to deal with it. Getting a grade out takes a little bit of work
because if I want to get the grade associated with a particular student, what would I do? I"
Lecture6_Chunk88,"because if I want to get the grade associated with a particular student, what would I do? I
would go into the name list and use the method index, which you've seen before, again notice
the dot notation it says, this is a list, use the index method, call it on student, and whatever the
value of student is, it will find that in the list, return the index at that point, and then I can use
that to go in and get the grade in the course and return something out."
Lecture6_Chunk89,"that to go in and get the grade in the course and return something out.
Simple way to do it but a little ugly, right, because among other things, I've got things stored in
different places in the list. I've got to think about if I'm going to add something to the list I've
got to put them in the same spot in the list. I've got to remember to always index using
integers which is what we know how to do with lists, at least so far. It would be nice if I had a"
Lecture6_Chunk90,"integers which is what we know how to do with lists, at least so far. It would be nice if I had a
better way to do it, and that's exactly what a dictionary is going to provide for me. So rather
than indexing on integers I'd like to index directly on the item of interest. I'd like to say where's
Ana's record and find that in one data structure. And so, whereas a list is indexed by integers,
and has elements associated with it, a dictionary is going to combine a key, or if you like, a"
Lecture6_Chunk91,"and has elements associated with it, a dictionary is going to combine a key, or if you like, a
name of some sort, with an actual value. And we're going to index just by the name or the
label as we go into it. So let me show you some examples.
First of all, to create a dictionary I use curly braces, open closed curly brace, so an empty
dictionary would be simply that call. If I want to create an actual dictionary, before I insert"
Lecture6_Chunk92,"dictionary would be simply that call. If I want to create an actual dictionary, before I insert
things into it, I use a little bit of a funky notation. It is a key or a label, a colon, and then a
value, in this case the string Ana and the string b, followed by a comma which separates it
from the next pairing of a key and a label, or a key and a value, and so on. So if I do this what
it does in my dictionary is it creates pairings of those labels with the values I associated with"
Lecture6_Chunk93,"it does in my dictionary is it creates pairings of those labels with the values I associated with
them. OK, these are pretty simple, but in fact, there's lots of nice things we can do with it.
So once we've got them indexing now is similar to a list but not done by a number, it's done by
value. So if that's my key, I can say, what's John's grade, notice the call, it's grades, which is in
my dictionary, open close square brackets, with the label John. And what it does, it goes in"
Lecture6_Chunk94,"my dictionary, open close square brackets, with the label John. And what it does, it goes in
and finds that in the dictionary, returns the value associated with it. If I ask for something not in
the dictionary, it's going to give me a key error. Other things we can do with dictionaries, we
can add entries just like we would do with lists. Grades as a dictionary, in open and closed
square brackets, I put in a new label and a value, and that adds that to the dictionary."
Lecture6_Chunk95,"square brackets, I put in a new label and a value, and that adds that to the dictionary.
I can test if something's in the dictionary by simply saying, is this label in grades, and it simply
checks all of the labels or the keys for the dictionary to see if it's there, and if it's not returns
false. I can remove entries, del, something we've seen before, a very generic thing. It will
delete something, and in this case, it says, in the dictionary grades, find the entry associated"
Lecture6_Chunk96,"delete something, and in this case, it says, in the dictionary grades, find the entry associated
with that key, sorry, Ana, you're about to be flushed, remove it. She's only getting a b in the
class and she teaches it. We've got to do something about this, right? So I can add things, I
can delete things, I can test if things are there.
Let me show you a couple of other things about dictionaries. I can ask for all of the keys in the"
Lecture6_Chunk97,"Let me show you a couple of other things about dictionaries. I can ask for all of the keys in the
dictionary. Notice the format, there is that dot notation, grades as a dictionary, it says, use the
keys method associated with this data structure dictionaries. Open close actually calls it, and it
gives me back a collection of all the keys in some arbitrary order. I'm going to use a funny
term here which I'm not certain we've seen so far. It returns something we call an iterable, it's"
Lecture6_Chunk98,"term here which I'm not certain we've seen so far. It returns something we call an iterable, it's
like range. Think of it as giving us back the equivalent of a list, it's not actually a list, but it's
something we can walk down. Which is exactly why I can then say, is something in a
dictionary, because it returns this set of keys, and I can test to see something's in there. I can
similarly get all of the values if I wanted to look at them, giving us out two iterables."
Lecture6_Chunk99,"similarly get all of the values if I wanted to look at them, giving us out two iterables.
Here are the key things to keep in mind about dictionaries. The values can be anything, any
type, mutable, immutable. They could be duplicates. That'd actually makes sense, I could
have the same value associated, for example, the same grade associated with different
people, that's perfectly fine. The values could be lists, they could be other data structures, they"
Lecture6_Chunk100,"people, that's perfectly fine. The values could be lists, they could be other data structures, they
could even be other dictionaries. They can be anything, which is great.
The keys, the first part of it are a little more structure. They need to be unique. Well duh, that
make sense. If I have that same key in two places in the dictionary, when I go to look it up,
how am I going to know which one I want? So it needs to be unique, and they also need to be"
Lecture6_Chunk101,"how am I going to know which one I want? So it needs to be unique, and they also need to be
immutable, which also makes sense. If I'm storing something in a key in the dictionary, and I
can go and change the value of the key, how am I going to remember what I was looking for?
So they can only be things like ints, floats, strings, tuples, Booleans. I don't recommend using
floats because you need to make sure it's exactly the same float and that's sometimes a little"
Lecture6_Chunk102,"floats because you need to make sure it's exactly the same float and that's sometimes a little
bit challenging, but nonetheless, you can have any immutable type as your key. And notice
that there's no order to the keys or the values. They are simply stored arbitrarily by the Python
as it puts them in.
So if I compare these two, lists or ordered sequences indexed by integers, I look them up by
integer index, and the indices have to have an order as a consequence. Dictionaries are this"
Lecture6_Chunk103,"integer index, and the indices have to have an order as a consequence. Dictionaries are this
nice generalization, arbitrarily match keys to values. I simply look up one item by looking up
things under the appropriate key. All I require is that the keys have to be immutable.
OK, I want to do two last things I've got seven minutes to go here. I want to show you an
example of using dictionaries, and I'm going to do this with a little bit more interesting, I hope,"
Lecture6_Chunk104,"example of using dictionaries, and I'm going to do this with a little bit more interesting, I hope,
example. I want to analyze song lyrics. Now I'm going to show you, you can already tell the
difference between my age and Ana's age. She used Taylor Swift and Justin Bieber. I'm going
to use The Beatles. That's more my generation. Most of you have never heard of The Beatles
unless you watched 
Shining
 
Time
 
Station
 where you saw Ringo Starr, right?"
Lecture6_Chunk105,"unless you watched 
Shining
 
Time
 
Station
 where you saw Ringo Starr, right?
OK, what I'm going to do is, I want to write a little set of procedures that record the frequencies
of words in a song lyric. So I'm going to match strings, or words, to integers. How many times
did that word appear in the song lyric? And then I want to ask, can I easily figure out which
words occur most often, and how many times. Then I'm going to gather them together to see"
Lecture6_Chunk106,"words occur most often, and how many times. Then I'm going to gather them together to see
what are the most common words in here. And I'm going to do that where I'm going to let a
user say, I want every word that appears more than some number of times. It's a simple
example, but I want you to see how a mutation of the dictionary gives you a really powerful
tool for solving this problem.
So let's write the code to do that. It's also in the handout, here we go. Lyrics to frequency's,"
Lecture6_Chunk107,"So let's write the code to do that. It's also in the handout, here we go. Lyrics to frequency's,
lyrics is just a list of words, strings. So I'm going to set up an empty dictionary, there's that
open close curly brace, and here's what I want to do. I'm going to walk through all the words in
lyrics. You've seen this before, this is looping over every word in lyrics. Ah, notice what I'm
going to do. I'm going to simply say-- so the first part is, I can easily iterate over the list, --but"
Lecture6_Chunk108,"now I'm going to say, if the word is in the dictionary, and because the dictionary is iterable, it's
simply going to give me back all of the keys, it's simply going to say, in this case, if it's in the
dictionary, it's already there, I've got some value associated with it, get the value out, add 1 to
it, put it back in. If it's not already in the dictionary, this is the first time I've seen it, just store it
into the dictionary. And when I'm done just return the dictionary. OK?"
Lecture6_Chunk109,"into the dictionary. And when I'm done just return the dictionary. OK?
So I'm going to, if I can do this right with my Python, show you an example of this. I have put in
one of the great classic Beatles songs, you might recognize it right there. Mostly because it's
got a whole lot of repetitions of things. So she loves you yeah, yeah, yeah, yeah. Sorry,
actually they sing it better than I just did it sarcastically. Sorry about that, but I got she loves"
Lecture6_Chunk110,"actually they sing it better than I just did it sarcastically. Sorry about that, but I got she loves
you there, and here's my code up here, lyrics to frequency. So let's see what happens if we
call it. And we say lyrics to frequencies she loves you. And it would help if I can type, all right,
we'll try it one more time, lyrics to frequency's, she loves you. Cool, this gave me back a
dictionary, you can see the curly braces, and there are all the words that appear in there and"
Lecture6_Chunk111,"dictionary, you can see the curly braces, and there are all the words that appear in there and
the number of times that they appear.
What's the order? You don't care. You don't know. What we want to do is to think about how
can we analyze this, so let's go back and look at the last piece of this. Which is, OK, I can
convert lyrics to frequencies. So here's the next thing I want to do, how do I find the most
common words? Well, here's what I'm going to do, frequencies is the dictionary, something"
Lecture6_Chunk112,"common words? Well, here's what I'm going to do, frequencies is the dictionary, something
that I just pulled out. So I can use the values method on it which returns and iterable, as I said
earlier, again notice the open close because I got to call it.
That gives me back an iterable that has all of the frequencies inside of there, because it's an
iterable, I can use max on it, and it will take that editable and give me back the biggest value."
Lecture6_Chunk113,"iterable, I can use max on it, and it will take that editable and give me back the biggest value.
I'm going to call that best, I'm going to set up words to be an empty list, and then I'm just going
to walk through all of the entries in the dictionary saying, if the value at that entry is equal to
best add that entry into words, just append it onto the end of the list. And when I'm done all of
that loop, I'm just going to return a tuple of both the collections of words that period that many"
Lecture6_Chunk114,"that loop, I'm just going to return a tuple of both the collections of words that period that many
times and how often they appeared. I'm going to show you an example in a second, but notice
I'm simply using the properties of the dictionary.
The last thing I want to do then is say, I want to see how often the words appear. So I'm going
to give it a dictionary and a minimum number of times. And here I'm going to set result up to"
Lecture6_Chunk115,"to give it a dictionary and a minimum number of times. And here I'm going to set result up to
be an empty list, I'm going to create a flag called false, it's going to keep track of when I'm
done. And as long as I'm not yet done, I'll call that previous procedure that's going to give me
back the most common words and how often they appeared. I check and remember it was a
tuple, how often do they appear, if it's bigger than the thing I'm looking for, I'll add that into my
result."
Lecture6_Chunk116,"result.
And then the best part is, I'm now going to walk through all the words that appeared that many
times, and just delete them from the dictionary. I can mutate the dictionary. And by doing that,
I can go back around and do this again, and it will pull out how many times has this appeared
and keep doing it. When I can go all the way through that, if I can't find any more, I'll set the
flag to true which means it will drop out of here and return the result. I'm going to let you run"
Lecture6_Chunk117,"flag to true which means it will drop out of here and return the result. I'm going to let you run
this yourself, if you do that, you'll find that it comes up with, not surprisingly, I think yeah is the
most common one and she loves you, followed by loves and a few others. What I want you to
see here is how the dictionary captured the pieces we wanted to.
Very last one, there's Fibonacci, as we called it before. It's actually incredibly inefficient,"
Lecture6_Chunk118,"Very last one, there's Fibonacci, as we called it before. It's actually incredibly inefficient,
because if I call it, I have to do all the sub calls until I get down to the base case, which is OK.
But notice, every other thing I do here, I've actually computed those values. I'm wasting
measures, or wasting time, it's not so bad with fib of 5, but if this is fib of 20, almost everything
on the right hand side of this tree I've already computed once. That means fibs very inefficient."
Lecture6_Chunk119,"on the right hand side of this tree I've already computed once. That means fibs very inefficient.
I can improve it by using a dictionary, very handy tool. I'm going to call fib not only with a value
of n, but a dictionary which initially I'm going to initialized to the base cases. And notice what I
do, I'm going to say if I've already computed this, just return the value in the dictionary. If I
haven't, go ahead and do the computation, store it in the dictionary at that point, and return"
Lecture6_Chunk120,"haven't, go ahead and do the computation, store it in the dictionary at that point, and return
the answer.
Different way of thinking about it, and the reason this is really nice is a method called
memoization, is if I call fib of 34 the standard way it takes 11 million plus recursive calls to get
the answer out. It takes a long time. I've given you some code for it, you can try it and see how
long it takes. Using the dictionary to keep track of intermediate values, 65 calls. And if you try"
Lecture6_Chunk121,"long it takes. Using the dictionary to keep track of intermediate values, 65 calls. And if you try
it, you'll see the difference in speed as you run this. So dictionaries are valuable, not only for
just storing away data, they're valuable on procedure calls when those intermediate values are
not going to change. What you're going to see as we go along is we're going to use exactly
these ideas, using dictionaries to capture information, but especially using recursion to break"
Lecture6_Chunk122,"these ideas, using dictionaries to capture information, but especially using recursion to break
bigger problems down into smaller versions of the same problem, to use that as a tool for
solving what turn out to be really complex things. And with that, we'll see you next time."
Lecture7_Chunk1,"MITOCW | watch?v=9H6muyZjms0
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation, or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu
PROFESSOR:
All right, everyone. Good afternoon. Let's get started. So today's lecture will be on testing,"
Lecture7_Chunk2,"All right, everyone. Good afternoon. Let's get started. So today's lecture will be on testing,
debugging, and then exceptions and assertions. So before we begin, let's start with an
analogy to sort of come back to real life for a second.
So I've made soup before. Perhaps you've made soup before. Let's say you're making soup in
this big pot here. And it turns out that bugs keep falling into your soup from the ceiling. All"
Lecture7_Chunk3,"this big pot here. And it turns out that bugs keep falling into your soup from the ceiling. All
right. Quick question to the audience. What do you do if you encountered this issue?
AUDIENCE:
[INTERPOSING VOICES]
PROFESSOR:
All right. Hands up. One one at a time. Anyone have any idea? Yeah.
AUDIENCE:
Eat it.
PROFESSOR:
Eat it. You want to eat it Anyway OK. All right. We're going for an analogy here with computer
programming. I don't know what you'd do if you have a buggy program, I guess you just"
Lecture7_Chunk4,"programming. I don't know what you'd do if you have a buggy program, I guess you just
release it to the customer and they'd complain, but. OK. What else? Yeah.
AUDIENCE:
[INAUDIBLE] Cover the soup?
PROFESSOR:
Cover the soup. That's a good suggestion. Yeah. So you can cover the soup, so put a lid on it.
Sometimes you'd have to open up, take the lid off, right, to check to make sure it's done. To
taste it, add things. So bugs might fall in in between there. But covering the soup is a good"
Lecture7_Chunk5,"taste it, add things. So bugs might fall in in between there. But covering the soup is a good
idea. What else. Yeah.
AUDIENCE:
Debug it.
PROFESSOR:
Debug it. I wish I had something for that answer. All right. That's a good answer. Yeah.
AUDIENCE:
Take all the food out of your house so there's no-- nothing for the bugs to eat.
PROFESSOR:
So take all the food out of your house so there's nothing for the bugs to eat. That's sort of the"
Lecture7_Chunk6,"So take all the food out of your house so there's nothing for the bugs to eat. That's sort of the
equivalent of cleaning, like doing a mass cleaning of your entire house. That's a good, that's a
good one. That's sort of eliminating the source of the bugs, right? What else? Yeah, John.
AUDIENCE:
Decide it's high protein and declare it a feature.
PROFESSOR:
Decide it's high protein and declare it a feature. That's probably what a lot of people would do,"
Lecture7_Chunk7,"Decide it's high protein and declare it a feature. That's probably what a lot of people would do,
right? All right. Cool. So I wish computer debugging was as fun as taking bugs out of your
soup. So what did we decide? Well we could check the soup for bugs. Keep the lid closed, that
was a good suggestion. And cleaning your kitchen, which someone suggested. The equivalent
of cleaning their kitchen was to just throw out all the food. I would take a mop and clean the"
Lecture7_Chunk8,"of cleaning their kitchen was to just throw out all the food. I would take a mop and clean the
floor, but yeah, that works too. So we can draw some parallels for this analogy with computer
programming.
So checking the soup is really equivalent to testing, right? You have a soup you think has bugs
in it. Test it. Make sure there's no bugs. Continue on. Keeping the lid closed. It's sort of this
idea of defensive programming. So make sure that bugs don't fall in in the first place."
Lecture7_Chunk9,"idea of defensive programming. So make sure that bugs don't fall in in the first place.
Sometimes you have to open the lid to make sure that the soup is tastes good or whatever. So
that's equivalent to defensive programming. So try not to have bugs in the first place, but they
might show up anyway. Cleaning the kitchen is eliminating the source of the bugs in the first
place. This is actually really hard to do in programming. But you can still try to do it. OK."
Lecture7_Chunk10,"place. This is actually really hard to do in programming. But you can still try to do it. OK.
So let's talk a little bit about programming so far in 60001 600. So you expect, really, that you
write a program, you maybe do a little debugging, and you run the program and it's perfect.
Right? You just nailed it. But in reality you write this really complex piece of code and you go to
run it and it crashes. Right? It's happened to me many times. It's happened to you many"
Lecture7_Chunk11,"run it and it crashes. Right? It's happened to me many times. It's happened to you many
times. That's the reality. OK. So today's lecture will go over some tips and tricks and
debugging and how you can help make your life easier when you're writing programs so you
don't end up like this little girl here. Disappointed beyond belief. All right.
So at the heart of it all is really starting with a defensive programming attitude. OK. And this"
Lecture7_Chunk12,"So at the heart of it all is really starting with a defensive programming attitude. OK. And this
comes back to the idea of decomposition and abstraction that we talked about when we
started-- when we did the lecture on functions. Right? So try to start out with two modularize
your code, right? If you write your code in different blocks, documenting each different block,
you're more likely to understand what's happening in your code later on and you'll be able to"
Lecture7_Chunk13,"you're more likely to understand what's happening in your code later on and you'll be able to
test it and debug it a lot easier.
Speaking of testing and debugging, once you've written a program that's modular, you still
have to test it. And the process of testing is really just coming up with inputs. Figuring out what
outputs you expect. And then running your program. Does the output that the program give"
Lecture7_Chunk14,"outputs you expect. And then running your program. Does the output that the program give
match what you expected? If it does, great, you're done. But if it doesn't, you have to go to this
debugging step. And the debugging step is the hardest part. And it's really just figuring out why
the program crashed, or why the program didn't give you the answer that you expected it to
give.
So as I mentioned, the most important thing is to do defensive programming and to that end,"
Lecture7_Chunk15,"give.
So as I mentioned, the most important thing is to do defensive programming and to that end,
you want to set yourself up for easy testing and debugging. Which really comes down to
making sure that the code you write is modular. So write as many functions as you can.
Document what the functions do. Document their constraints. And it'll make your life a little bit
easier later on when you have to debug it."
Lecture7_Chunk16,"easier later on when you have to debug it.
When do you want to start testing? Well first you have to make sure your program runs. So
eliminate syntax errors and static semantic errors which, by the way, Python can easily catch
for you. Once you've ensured that a piece of code runs, then you want to come up with some
test cases. So this is pairs of input and output for what you expect the program to do.
Once you have your test cases and a piece of code that runs, you can start doing tests. So"
Lecture7_Chunk17,"Once you have your test cases and a piece of code that runs, you can start doing tests. So
there's three general classes of tests that you can do. The first is called unit testing. And if
you've written functions, unit testings-- testing just makes sure that, for example, each function
runs according to the specifications. So you do this multiple times. As you're testing each
function, you might find a bug. At that point, you do regression testing. Come up with a test"
Lecture7_Chunk18,"function, you might find a bug. At that point, you do regression testing. Come up with a test
case that found that bug. And run all of the different pieces of your code again to make sure
that when you fix the bug, you don't re-introduce new bugs into pieces of the code that had
already run.
So you do this a bunch of times. You do a little bit of unit testing, a little bit of regression
testing, and keep doing that. At some point, you're ready to do integration testing. Which"
Lecture7_Chunk19,"testing, and keep doing that. At some point, you're ready to do integration testing. Which
means, test your program as a whole. Does the overall program work? So this is the part
where you take all of the individual pieces, put them together. And integration testing tests to
make sure that the interactions between all of the different pieces works as expected. If it
does, great, you're done. But if it doesn't, then you'll have to go back to unit testing, and"
Lecture7_Chunk20,"does, great, you're done. But if it doesn't, then you'll have to go back to unit testing, and
regression testing, and so on. So it's really a cycle of testing.
So what are some testing approaches? The first, and this is probably most common with
programs that involve numbers, is figuring out some natural boundaries for the numbers-- for
the program, sorry. So for example, if I have a function is_bigger, and it compares if x is bigger"
Lecture7_Chunk21,"the program, sorry. So for example, if I have a function is_bigger, and it compares if x is bigger
than y, then some natural boundary, given the specification, is if x is less than y, x is greater
than y, x is equal to y. Maybe throw in less than or equal to or greater or equal to, and so on.
So that's just sort of an intuition about the problem. It's possible you have some problems for
which there are no natural partitions. In which case, you might do some random testing, and"
Lecture7_Chunk22,"which there are no natural partitions. In which case, you might do some random testing, and
then the more random testing you do, the greater the likelihood that your program is correct.
But there's actually two more rigorous ways to do testing. And one is black box testing and the
other one is glass box testing.
In black box testing, you're assuming you have the specifications to a function. So that's the"
Lecture7_Chunk23,"In black box testing, you're assuming you have the specifications to a function. So that's the
docstring. All you're looking at is the docstring and coming up with some test cases based on
that. In glass box testing, you have the code itself and you're trying to come up with some test
cases that hit upon all of the possible paths through the code.
All right. Let's look at an example for black box testing. I'm finding the square root of x to some"
Lecture7_Chunk24,"All right. Let's look at an example for black box testing. I'm finding the square root of x to some
close enough value given by this epsilon. And the idea here, notice I don't actually give you
how this function's implemented. The idea is that you're just figuring out test cases based on
the specification. And the great thing about black box testing is that whoever implements this
function can implement it in whatever way they wish, they can use approximation method, that"
Lecture7_Chunk25,"function can implement it in whatever way they wish, they can use approximation method, that
can use bisection method, it doesn't matter. The test cases that you come up with for this
function are going to be exactly the same. Right? No matter what the implementation.
So for this particular function, here's a sample set. We check the boundary, we check perfect
squares, we can check some number that's less than 1, we can check maybe irrationals, and"
Lecture7_Chunk26,"squares, we can check some number that's less than 1, we can check maybe irrationals, and
then you do extreme tests. So when either epsilon is really large or epsilon is really small, or x
is really large or x is really small, and all the possible combinations of those. So the important
thing about black box testing is that you are doing you are creating the test cases based on
the specifications only."
Lecture7_Chunk27,"the specifications only.
Glass box testing, you're using the code itself to guide your test cases. So if you have a piece
of code and you come up with a test case that goes through every single possible combination
of input-- of every single possible path through the code, then that test set is called path
complete. The problem with this is when you encounter loops, for example. Every single
possible path through a loop is maybe the code not going through the loop at all, going"
Lecture7_Chunk28,"possible path through a loop is maybe the code not going through the loop at all, going
through once, going through twice, going through three times, four times, five times, and so
on. Right? Which could be a very, very big test.
So instead there are actually some guidelines for when you're dealing with loops and things
like that. So for branches, when you're doing glass box testing, it's important-- you should just"
Lecture7_Chunk29,"like that. So for branches, when you're doing glass box testing, it's important-- you should just
exercise all of the parts of the conditional. So make sure you have a test case that goes
through each part of the conditional. For for loops, make sure you have a test case where the
loop is not entered at all, where the loop is entered one time, and when the loop is entered just
some number more than once."
Lecture7_Chunk30,"some number more than once.
For while loops, similar to for loops, except that make sure you have test cases that cover all
of the possible ways to break out of the while loop. So if the while loop condition becomes
false, or if maybe there's a break inside the while loop, and so on.
So in this example, we have the absolute value of x. This is its specification and this is the
implementation that someone decided to do for this function. So a path complete test set"
Lecture7_Chunk31,"implementation that someone decided to do for this function. So a path complete test set
means that you want to have a test that goes through each one of these branches. So if x is
less than minus 1, well, minus 2 is less than minus 1. So that's good. And otherwise, which
means pick a number greater than minus 1. So 2. So 2 and minus 2 are path complete. Yield
path complete-- yields a path complete test suite."
Lecture7_Chunk32,"path complete-- yields a path complete test suite.
But notice that while we've hit upon every possible path through this code, we've actually
missed a test case. Minus 1. So this code incorrectly classifies minus 1 as returning minus 1,
which is wrong. So for glass box testing, in addition to making sure you're going through all the
possible paths through the code, you also want to make sure you hit upon any boundary
condition. So in this case, for branches, minus 1 is a boundary condition."
Lecture7_Chunk33,"condition. So in this case, for branches, minus 1 is a boundary condition.
So you've created a test suite, you've tested your program, chances are you found a bug.
What do you do now?
All right. Quick sort of detour into a little bit of history. The history of debugging. So 1947, this
computer was built. And it was a computer that was very impressive for its day. It could do
things like addition in 0.1 seconds. Things like multiplication in 0.7 seconds. And take the log of"
Lecture7_Chunk34,"things like addition in 0.1 seconds. Things like multiplication in 0.7 seconds. And take the log of
something in five seconds. So faster than a human, possibly. But pretty slow for today's
standards. And a group of engineers were working on running a program that found-- that was
supposed to find the trigonometric function. And among them being this-- one of the first
female scientists, Grace Hopper.
And they found that their program was not working correctly. So they went through all of the"
Lecture7_Chunk35,"And they found that their program was not working correctly. So they went through all of the
panels and all of the relays in the computer, and they isolated a program in panel F relay 70,
where they found this moth. Just sitting in there. I think it was dead, probably electrocuted. But
it was a moth that was impeding the calculation. And I don't know if you can read this, but this
part right here. They made a note in their logbook that says, first actual case of bug being"
Lecture7_Chunk36,"part right here. They made a note in their logbook that says, first actual case of bug being
found. Which I think is really cute. So they were literally doing debugging in this computer.
Right. All right.
So you won't be doing that sort of debugging. You'll be doing a virtual kind of debugging in
your programs. Which, again, is not that fun. But you still have to do it. So debugging, as you
might have noticed so far in your problem sets, has a bit of a steep learning curve. And"
Lecture7_Chunk37,"might have noticed so far in your problem sets, has a bit of a steep learning curve. And
obviously your goal is to have a bug free program, and in order to achieve that, you have to do
the debugging.
There are some tools which some of you have been using. There are some tools built into
Anaconda, or whatever ID you've been using to do debugging. I know some of you have been
using the Python tutor, which is awesome. The print statement can also be a good debugging"
Lecture7_Chunk38,"using the Python tutor, which is awesome. The print statement can also be a good debugging
tool. But over above everything else, it's really important to just be systematic as you're trying
to debug your program.
I want to talk a little bit about print statements and how you can use them to debug, because I
think-- Python tutor, if you don't have the internet, you might not be able to use it. If you don't
know how to use the debugger, you don't need to learn. But print statements, you'll always"
Lecture7_Chunk39,"know how to use the debugger, you don't need to learn. But print statements, you'll always
have them, and you can always put them in your program. And they're really good ways to test
hypotheses.
So good places to put print statements are inside functions. Inside loops, for example, what
are the loop parameters, what are the loop values, what function-- what functions return what
values. So you can make sure that values are being passed-- the correct values are being"
Lecture7_Chunk40,"values. So you can make sure that values are being passed-- the correct values are being
passed between parts of your code. I will mention that you can use the bisection method when
you're debugging. Which is interesting.
So if you take a print statement, find approximately the halfway point in your code. Print out
what values you-- print out some relevant values. All of the possible-- print out some values at"
Lecture7_Chunk41,"what values you-- print out some relevant values. All of the possible-- print out some values at
that point in your code. If everything is as you expect it to be at that point in your code, then
you're good. That means the code so far is bug free. That means that-- however, that means
you're good. That means the code so far is bug free. That means that-- however, that means
that the code beyond it has a bug, right?"
Lecture7_Chunk42,"that the code beyond it has a bug, right?
So since you've put a print statement halfway in your code and you think that gave good
results, then put a print statement 3/4 of the way in the code. And see if the values are as you
expect at that point. And if they are, great. Then put a print statement further down. So in this
way you could use the bisection method to pinpoint a line, or a set of lines, or maybe a
function that that's giving you the bad results."
Lecture7_Chunk43,"function that that's giving you the bad results.
So the general debugging steps is to study the program code. Don't ask what is wrong,
because that's actually part of the testing. So your test cases would have figured out what's
wrong. The debugging process is figuring out how the result took place. And since
programming is-- programming and debugging is, sort of, is a science, you can use the
scientific method as well. So look at all the data, that's your test cases. Figure out a"
Lecture7_Chunk44,"scientific method as well. So look at all the data, that's your test cases. Figure out a
hypothesis. Maybe say, oh, maybe I'm indexing from 1 instead of 0 in lists, for example. Come
up with an experiment that you can repeat. And then pick a simple test case then you can test
your hypothesis with.
So as you're debugging, you will encounter error messages. And these error messages are
actually pretty easy to figure out. And they're really easy to fix in your code. So for example,"
Lecture7_Chunk45,"actually pretty easy to figure out. And they're really easy to fix in your code. So for example,
accessing things beyond the limits of the lists give you index errors. Trying to convert, in this
case, a list to an integer gives you type errors. Accessing variables that you haven't created
before gives you name errors. And so on and so on. And syntax errors are things, for things
like, if you forget a parentheses, or forget a colon, or something like that."
Lecture7_Chunk46,"like, if you forget a parentheses, or forget a colon, or something like that.
So error messages are really easy to spot. The Python interpreter spits these out for you and
then you can pinpoint the exact line. Logic errors are actually the hard part. And logic errors
are the ones that you will be spending the most time on. For which I would recommend always
trying to take a break. Take a nap, go eat. Something. Sometimes you'd have to start all over,"
Lecture7_Chunk47,"trying to take a break. Take a nap, go eat. Something. Sometimes you'd have to start all over,
so throughout the code you have and just sit down with a piece of paper, try to figure out how
you want to solve the problem.
And if you look up the term rubber ducky-- a lot of heads went up on that one-- rubber ducky
debugging. That is an actual term in Wikipedia. And it's when a programmer explains their
code to a rubber ducky. That's me on the left explaining code to my rubber ducky. You should"
Lecture7_Chunk48,"code to a rubber ducky. That's me on the left explaining code to my rubber ducky. You should
always-- you should go buy one. Or code to anyone else, preferably someone who doesn't
really understand anything. Because that'll force you to explain everything really, really closely.
And as you're doing that, you'll figure out your problem. And I figured out my problem in both
of these cases. So just go back to the basics."
Lecture7_Chunk49,"of these cases. So just go back to the basics.
Quick summary of dos and don'ts of debugging and testing. So don't write the entire program,
test the entire program, and debug the entire program. I know this is really tempting to do, and
I do it all the time. But don't do it. Because you're going to introduce a lot of bugs and it's going
to be hard to isolate which bugs are affecting other ones. And it'll lead to a lot more stress than"
Lecture7_Chunk50,"to be hard to isolate which bugs are affecting other ones. And it'll lead to a lot more stress than
you need. Instead do unit testing. So write one function, test the function, debug the function,
make sure it works, write the other function, and so on and so on. Do a little regression testing,
a little more unit testing, a little integration testing, and it's a lot more systematic way to write
the program. And it'll cut down on your debugging time immensely."
Lecture7_Chunk51,"the program. And it'll cut down on your debugging time immensely.
If you're changing your code, and inevitably you'll be changing your code as you're doing your
problem sets, remember to back up your code. So if you have a version that almost works,
don't just modify that and maybe save a copy. [INAUDIBLE] you've got terabytes of memory
on your computer, it won't hurt to just make a quick copy of it. Document maybe what worked"
Lecture7_Chunk52,"on your computer, it won't hurt to just make a quick copy of it. Document maybe what worked
and what didn't in that copy. And then make another copy, and then you can modify your
code.
So that's sort of a high level introduction to testing and debugging. The rest of the class will be
on the error messages, or on errors that you will get in your programs. So when your
functions-- when you run functions, or when you run your program, at some point, the"
Lecture7_Chunk53,"functions-- when you run functions, or when you run your program, at some point, the
program execution is going to stop. Maybe it encountered an error because of some
unexpected condition. And when that happens you get an exception. So the error is called an
exception. And it's called an exception because it was an exception to what was expected. To
what the program expected.
So all of these errors that I've talked about in the previous slides are actually examples of"
Lecture7_Chunk54,"So all of these errors that I've talked about in the previous slides are actually examples of
exceptions. And there are actually many other types of exceptions, which you'll see as you go
on in this course and also in 60002.
So how do we deal with these exceptions? In Python, you can actually have handlers for
exceptions. So if you know that a piece of code might give you an error. For example, here I'm"
Lecture7_Chunk55,"exceptions. So if you know that a piece of code might give you an error. For example, here I'm
dealing with inputs from users. And users are really unpredictable. You tell them to give you a
number, they might give you their name. Nothing you can do about that. Or is there? Yes
there is. So in your program you can actually put any lines of code that you think might be
problematic, that might give you an error an exception, in this try block. So you say try colon,"
Lecture7_Chunk56,"problematic, that might give you an error an exception, in this try block. So you say try colon,
and you put in any lines of code that you think might give you an error.
If none of these lines of code actually produce an error, then great. Python doesn't do
anything else. It treats them as just part-- as just if they were part of a regular program. But if
an error does come up-- for example, if someone doesn't put in a number but puts their name"
Lecture7_Chunk57,"an error does come up-- for example, if someone doesn't put in a number but puts their name
in-- that's going to raise an error, specifically a value error. And at that point, Python's going to
say, is there an accept statement? And if so, this except statement is going to handle the
error.
And it's going say, OK, an error came up, but I know how to handle it. I'm going to print out this
message to the user. So if we look at code-- this is the same code as in the slides-- and"
Lecture7_Chunk58,"message to the user. So if we look at code-- this is the same code as in the slides-- and
there's no try except block around it. So if I run it and I say, three and four, it's going to run
fine. But if I run it and I say, [INAUDIBLE] a, it's going to give a value error.
Now if I run the same piece of code with try-- with a try except block. I run it, if I give it regular
numbers, it's fine. But if I'm being a cheeky user, and I say three, automatically this would"
Lecture7_Chunk59,"numbers, it's fine. But if I'm being a cheeky user, and I say three, automatically this would
have raised the value error in the previous version of the program. But in this version of the
program, the programmer handled the exception or caught the exception, and printed out this
nicer looking message. So bug in user input is nicer than this whole lot here. A lot easier to
read.
So any problematic lines of code, you can put in a try block, and then handle whatever errors"
Lecture7_Chunk60,"read.
So any problematic lines of code, you can put in a try block, and then handle whatever errors
might come up in this except block. This except block is going to catch any error that comes
up. And you can actually get a little bit more specific and catch specific types of errors. In this
case, I'm saying, if a value error comes up-- for example, if the user inputs a string instead of
an integer-- do this, which is going to print this message. If the user inputs a number for B"
Lecture7_Chunk61,"an integer-- do this, which is going to print this message. If the user inputs a number for B
such that we're doing a divided by b, so that would give a 0 division error. In that case we're
going to catch this other error here, the 0 division error, and we're going to print this other
message, can't divide by 0.
So each-- so you can think of these different except blocks as sort of if else if statements,"
Lecture7_Chunk62,"So each-- so you can think of these different except blocks as sort of if else if statements,
except for exceptions. So we're going to try this. But if there's a value error do this. Otherwise,
if there's a division error, do this. And otherwise do this. So this last except is actually going to
be for any other error that comes up. So if it's not a value error, nor a division error, then we're
going to print, something went very wrong. I couldn't even try to create-- I couldn't even try to"
Lecture7_Chunk63,"going to print, something went very wrong. I couldn't even try to create-- I couldn't even try to
make the program come up with any other error besides those two.
So a lot of the time you're just going to use try except blocks. But there's other blocks that you
can add to exceptions. And these are more rarely used, but I'll talk about them anyway. So
you could have an else block. And an else block is going to get executed when the code in the"
Lecture7_Chunk64,"you could have an else block. And an else block is going to get executed when the code in the
try block finished without raising an error. And you can also have a finally block, which is
always executed. If the code in the try block finished without an error, if you raised an
exception, if you raised a different kind of exception, if you went through the else, in any of
these cases, whatever's in the finally block is always going to get executed. And it's usually"
Lecture7_Chunk65,"these cases, whatever's in the finally block is always going to get executed. And it's usually
used to clean up code. Like if you want to print, oh, the program finished, or if you want to
close a file, or something like that.
So. We've encountered errors. We've caught them. What else can we do with errors-- with
exceptions. Three other things. So one is if we've caught an error, we can just fail silently."
Lecture7_Chunk66,"exceptions. Three other things. So one is if we've caught an error, we can just fail silently.
What this means is, you've caught an error, and you just substitute whatever erroneous value
the user gave you for some other value. That's not actually a very good idea. That's a bad
idea. Because suddenly the user thinks that they entered something, and they think
everything's great, your program accepts it, but then they get some weird value as an output,"
Lecture7_Chunk67,"everything's great, your program accepts it, but then they get some weird value as an output,
which is far from what they expected. So it's not really a good idea to just replace user's values
with anything.
In the context-- so this is in the context of a function. In the context of a function, what else can
we do? Well, if you have a function that fails, for example, let's say you're trying to do you're
trying to get the square root of an even number. And let's say the user gives you a-- sorry,"
Lecture7_Chunk68,"trying to get the square root of an even number. And let's say the user gives you a-- sorry,
you're trying to find the square root of a positive number. And let's say the user gives you a
negative number. Well, if the user gives you a negative number, your function could return an
error value, which means, well if the number inputted is less than 0, then return 0. Or minus 1.
Or minus 100. Just pick any value to return which represents some error value."
Lecture7_Chunk69,"Or minus 100. Just pick any value to return which represents some error value.
This is actually not a good idea either, because later on in your program, if you're using this
function, now you have to do a check. And the check is, well if the return from this function is
minus 1 or minus 100, do this. Otherwise, do this. So you you're complicating your code
because now you always have to have this check for this error value. Which makes the code
really messy."
Lecture7_Chunk70,"really messy.
The other thing we can do is we can signal an error condition. So this is how you create
control flow in your programs with exceptions. So in Python, signaling an error condition
means raising your own exception. So so far we've just seen the programs crashing, which
means they raise an exception and then you deal with them. But in this last case, you're
raising your own exception. As a way to use that exception later on in the code. So in Python,"
Lecture7_Chunk71,"raising your own exception. As a way to use that exception later on in the code. So in Python,
you raise your own exception using this raise keyword and then an exception. And then some
sort of description, like ""user entered a negative number"" or something like that.
A lot of the time we're going to raise a value error. So if the number is less than 0, then raise a
value error, something is wrong. The key word, the name of the error, and then some sort of
descriptive string."
Lecture7_Chunk72,"descriptive string.
So let's see an example of how we raise an exception. I have this function here called get
ratios. It takes in two lists, L1 and L2. And it's going to create a new list that's going to contain
the ratio of each element in L1 divided by each element in L2. So I have a for loop here. For
index in range length L1. So I'm going through every single element in L1. I'm going to try
here. I'm going to try to do this line. So I think that this line might give me an error. So I'm"
Lecture7_Chunk73,"here. I'm going to try to do this line. So I think that this line might give me an error. So I'm
going to put it in a try block. The error I think I'm going to get is a 0 division error, because
what happens when an element and L2 is 0?
And when an element in L2 is 0 I'm going to append this not a number as a float. So NAN, as
a string, you can convert it to a float, and it stands for not a number. So then I can continue"
Lecture7_Chunk74,"a string, you can convert it to a float, and it stands for not a number. So then I can continue
populating the list with these not a numbers. If an element and L2 is 0. And otherwise, if
there's no 0 division error, but there's another kind of error, then I'm going to raise my own
error. And say, for any other kind of error, just raise a value error. Which says, ""get ratios was
called with a bad argument."" So here I'm sort of consolidating all errors into my one value"
Lecture7_Chunk75,"called with a bad argument."" So here I'm sort of consolidating all errors into my one value
error. So later on in my program, I can catch this value error and do something with it.
Here's another example of exceptions. So let's say we're were given a class list. We have a list
of lists. Where we have the name of a student, first name and last name, and their grades in
the class. So we currently have two students. And what I want to do is create a new list which"
Lecture7_Chunk76,"the class. So we currently have two students. And what I want to do is create a new list which
is the same things, the same inputs here. But I'm adding an extra-- I'm appending an extra
value at the end of the list for each student, which is the average of all of their grades. Or all of
their-- yeah, all of their grades.
So let's look at the code. This is the function that takes the class list, which is this whole list"
Lecture7_Chunk77,"So let's look at the code. This is the function that takes the class list, which is this whole list
here. I'm creating a new list inside it, initially empty. And then I'm going for every element in
the class list. I'm appending element at 0, which is going to be this first list here. So it's going
to be the first name and the last name. Element at 1, which is the grades. And then the last
thing I'm appending is a function call. The function call being called with element 1, which is all"
Lecture7_Chunk78,"thing I'm appending is a function call. The function call being called with element 1, which is all
of the grades, and this is my function call. We're going to see three different function calls.
This is the first one. It simply takes the sum of the grades and divides it by the length of the
grades. If these students are responsible, and they've taken all of the tests, then there's no
problem. Because length of grades is going to be something greater than 0. But what if we"
Lecture7_Chunk79,"problem. Because length of grades is going to be something greater than 0. But what if we
have a student in the class who didn't show up for any tests? Then we have no record of any
of their tests. No record of grades or anything like that. So they're going to have an empty list.
So if we run this function, averages, on their data, we're actually going to get a 0 division error,
because we're trying to divide by length of grades, which is going to be 0."
Lecture7_Chunk80,"because we're trying to divide by length of grades, which is going to be 0.
So what can we do? Two things, two options here. One is we can just flag the error and print
the message. So here there's a new average function, an improved one, that's going to try to
do the exact same line as the previous one. And it's going to catch the 0 division error. And
when it catches it, it's going to print this warning. And when we run it, we're going to get,"
Lecture7_Chunk81,"when it catches it, it's going to print this warning. And when we run it, we're going to get,
""warning, no grades data,"" which is fine. And we're going to get this ""none"" here, for the
grades. So everyone else's grades was calculated correctly, and for this last one, we got a
none.
That's because, when we entered this except statement, if this is a function, remember
functions return something. This function in this particular except statement didn't return"
Lecture7_Chunk82,"functions return something. This function in this particular except statement didn't return
anything. So it returns a none. So for the averages for this particular function, the average is
going to be a ""none"" for this person who didn't have any grades associated with them. And
yeah, so that's basically what I said. So that's our first option, is to just flag the error and print a
message.
The other option is to actually change the policy. So this is where you replace the data with"
Lecture7_Chunk83,"The other option is to actually change the policy. So this is where you replace the data with
some sort of default value. And if you do something like this, then this should be documented
inside the function. So when you write the docstring for the function, you would say if the list is
empty, then it'll will a 0. So this is the exact same thing as before. We have a try and an except
for the 0 division error. We also print a warning, no grades data. And then we return the 0. So"
Lecture7_Chunk84,"for the 0 division error. We also print a warning, no grades data. And then we return the 0. So
we still flag the error, and now instead of a ""none,"" we get a 0, because we've returned 0.0
here, as opposed to just leaving it blank.
All right. So those are exceptions. Last thing we're going to talk about today are these things
called assertions. And assertions are good example of defensive programming. In that, you"
Lecture7_Chunk85,"called assertions. And assertions are good example of defensive programming. In that, you
have assert statements at the beginning of functions, typically. Or at the end of functions. And
assert statements are used to make sure that the assumptions on computations are exactly
what the function expects them to be. So if we have a function that says it's supposed to take
in an integer greater than 0, then the assert statement will assert that the function takes in an
integer that's greater than 0."
Lecture7_Chunk86,"integer that's greater than 0.
Here's an example. This is the same average function we've seen before. Here, instead of
using exceptions, we're going to use an assert statement. And the assert statement we're
putting right at the front. At the beginning of the function, sorry. And the key word is assert.
The next part of the assert is what the function expects. So we expect that the length of
grades is not equal to 0. So has to be greater than 0. And then we have a string here, which"
Lecture7_Chunk87,"grades is not equal to 0. So has to be greater than 0. And then we have a string here, which
represents what do you print out if the assertion does not hold.
So if you run the function, and you give it a list that is empty, this becomes false, so the assert
is false, and we're going to print out an assertion error, no grades data. If the assert is false,
the function does not continue. It stops right there. Why does it behave this way? Well,"
Lecture7_Chunk88,"the function does not continue. It stops right there. Why does it behave this way? Well,
assertions are great to make sure that preconditions and post-conditions on functions are
exactly as you expect. So as soon as an assert becomes false, the function's going to
immediately terminate. This is useful because it'll prevent the program from propagating bad
values.
So as soon as a precondition isn't true, for example, as you enter a function, then that means"
Lecture7_Chunk89,"So as soon as a precondition isn't true, for example, as you enter a function, then that means
something went wrong in your program. And the program is going to stop right there. So
instead of propagating a bad value throughout the program, and then you getting an output
that you didn't expect, and then you having to trace back to the function that gave this bad
value, you'll get this bad value, you'll get this assert being false a lot earlier. So it'll be a lot"
Lecture7_Chunk90,"easier to figure out where the bug came from. And you won't have to trace back so many
steps.
So this is basically what I said, you really want to spot the bugs as soon as they're introduced.
And exceptions are good if you want to raise them when the user supplies bad data input, but
assertions are used to make sure that the types and other-- the types of inputs to functions,
maybe other conditions on inputs to functions, are being held as the values are being passed"
Lecture7_Chunk91,"maybe other conditions on inputs to functions, are being held as the values are being passed
in. So the keyword here is making sure that the invariants on data structures are meant. And
that's it. Great. Thanks."
Lecture8_Chunk1,"MITOCW | watch?v=-DP1i2ZU9gk
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
PROFESSOR:
All right everyone. Let's get started. So today's lecture and Wednesday's lecture, we're going"
Lecture8_Chunk2,"All right everyone. Let's get started. So today's lecture and Wednesday's lecture, we're going
to talk about this thing called object oriented programming. And if you haven't programmed
before, I think this is a fairly tough concept to grasp. But hopefully with many, many examples
and just by looking at the code available from lectures, you'll hopefully get the hang of it
quickly. So let's talk a little bit about objects. And we've seen objects in Python so far. Objects"
Lecture8_Chunk3,"quickly. So let's talk a little bit about objects. And we've seen objects in Python so far. Objects
are basically data in Python. So every object that we've seen has a certain type. OK, that we
know.
Behind the scenes, though, every object has these two additional things. One is some data
representation. So how Python represents the object just behind the scenes and what are
different ways that you can interact with the object. So for example, every one of these is a"
Lecture8_Chunk4,"different ways that you can interact with the object. So for example, every one of these is a
different object. For example, this is the number 1,234. It's a specific object that is of type
integer. The number 5 is a different object that's of type integer and so on.
We've seen floats. We've seen strings. We've seen lists. Lists and dictionaries are more
complicated objects. Object types. Sorry. But every object has a type, some sort of way that"
Lecture8_Chunk5,"complicated objects. Object types. Sorry. But every object has a type, some sort of way that
it's represented in Python and some ways that we can interact with them.
OK. So the idea behind object oriented programming is, first of all, everything in Python is an
object. We've said that before and in this lecture I think we'll really get at what that means. So
we've seen strings, integers, dictionaries, lists. Those are all objects. When we did functions,"
Lecture8_Chunk6,"we've seen strings, integers, dictionaries, lists. Those are all objects. When we did functions,
we saw that we could pass as a parameter another function. So functions were also objects in
Python. So literally everything in Python is an object.
So what are the kinds of things we can do with objects? Well, once you have a type, you can
create a new object that is of some type. And you can create as many objects as you'd like of"
Lecture8_Chunk7,"create a new object that is of some type. And you can create as many objects as you'd like of
that particular type, right? An integer 5 and integer 7. Those all work in a program. Once
you've created these new objects, you can manipulate them. So for a list, for example, you
can append an item to the end of the list, you can delete an item, remove it, concatenate two
lists together. So that's ways that you can interact with objects."
Lecture8_Chunk8,"lists together. So that's ways that you can interact with objects.
And the last thing you can do is you can destroy them. So and with lists, we saw explicitly that
you can delete elements from a list, or you can just forget about them by reassigning a
variable to another value, and then at some point, Python will collect all of these dead objects
and reclaim the memory.
So let's continue exploring what objects are. So let's say I have these two separate objects."
Lecture8_Chunk9,"So let's continue exploring what objects are. So let's say I have these two separate objects.
One is a blue car. One is a pink car. So objects are really data abstractions. So these two cars
can be created by the same blueprint. OK? This is a blueprint for a car and if an object is a
data abstraction, there's two things that this abstraction is going to capture. The first is some
sort of representation. What is going to represent the car, what data represents a car object?"
Lecture8_Chunk10,"sort of representation. What is going to represent the car, what data represents a car object?
And the second is what are ways that we can interact with the object?
So if we think about a car blueprint, some general representation for a car could be the
number of wheels it has, the number of doors it has, maybe its length, maybe its height, so
this is all part of what data represents the car. OK? The interface for the car is what are ways"
Lecture8_Chunk11,"this is all part of what data represents the car. OK? The interface for the car is what are ways
that you can interact with it. So for example, you could paint a car, right? So you could change
its color. You could have the car make a noise and different cars might make different noises.
Or you can drive the car, right? So these are all ways that you can interact with the car.
Whereas the representation are what makes up the car. What data abstractions make up the"
Lecture8_Chunk12,"Whereas the representation are what makes up the car. What data abstractions make up the
car. Let's bring it a little closer to home by looking at a list. So we have this data type of list,
right? We've worked with lists before. The list with elements 1, 2, 3, and 4 is a very specific
object that is of type list. Again, we think about it in terms of two things. One is what is the data
representation of the list? So behind the scenes how does Python see lists?"
Lecture8_Chunk13,"representation of the list? So behind the scenes how does Python see lists?
And the second is, how do you interact with lists? So what are ways that you can manipulate a
list object once it's created? So behind the scenes you have a list, L, which is going to be
made up of essentially two things. One is going to be the value at specific index. OK? So at
index 0, it has the value 1, right, because it's the first element in the list. And the second thing"
Lecture8_Chunk14,"index 0, it has the value 1, right, because it's the first element in the list. And the second thing
that represents a list is going to be this second part, which is a pointer. And internally this
pointer is going to tell Python where is the memory location in the computer where you can
access the element index 1.
So it's just essentially going to be a chain, going from one index to the other. And at the next"
Lecture8_Chunk15,"So it's just essentially going to be a chain, going from one index to the other. And at the next
memory location you have the value at index 1, and then you have another pointer that takes
you to the location in memory where the index 2 is located. And in index 2 you have the value
and then the next pointer, and so on and so on. So this is how Python internally represents a
list. OK?
How you manipulate lists, we've done this a lot, right? You can index into a list, you can add"
Lecture8_Chunk16,"How you manipulate lists, we've done this a lot, right? You can index into a list, you can add
two lists together, you can get the length, you can append to the end of a list, you can sort a
list, reverse a list, and so many other things, right? So these are all ways that you can interact
with the list object as soon as you've created it. So notice both of these, the internal
representation and how you manipulate lists, you don't actually know internally how these are"
Lecture8_Chunk17,"representation and how you manipulate lists, you don't actually know internally how these are
represented, right? How did whoever wrote the list class decide to implement a sort. We don't
know.
You also weren't aware of how these lists were represented internally. And you didn't need to
know that. That's the beauty of object oriented programming and having these data
abstractions. The representations are private of these objects and they are only known by"
Lecture8_Chunk18,"abstractions. The representations are private of these objects and they are only known by
what you can find out how it's done, but they only should be known by whoever implemented
them. You, as someone who uses this class, doesn't really need to know how a list is
represented internally in order to be able to use it and to write cool programs with them. OK?
So just find a motivation here before we start writing our own types of objects is the"
Lecture8_Chunk19,"So just find a motivation here before we start writing our own types of objects is the
advantages of object oriented programming is really that you're able to bundle this data,
bundle some internal representation, and some ways to interact with a program into these
packages. And with these packages, you can create objects and all of these objects are going
to behave the exact same way. They're going to have the same internal representation and"
Lecture8_Chunk20,"to behave the exact same way. They're going to have the same internal representation and
the same way that you can interact with them. And ultimately, this is going to contribute to the
decomposition and abstraction ideas that we talked about when we talked about functions.
And that means that you're going to be able to write code that's a lot more reusable and a lot
easier to read in the future. OK.
So just like when we talked about functions, we're going to sort of separate the code that we"
Lecture8_Chunk21,"So just like when we talked about functions, we're going to sort of separate the code that we
talk about today into code where you implement a data type and code where you use an
object that you create. OK? So remember when we talked about functions, you were thinking
about it in terms of writing a function, so you had to worry about the details of how you
implement a function. And then you had to worry about just how to use a function, right? So it's"
Lecture8_Chunk22,"implement a function. And then you had to worry about just how to use a function, right? So it's
sort of the same idea today. So when you're thinking about implementing your own data type,
you do that with this thing called a class. And when you create a class, you're basically going
to figure out what name you want to give your class and you're going to find some attributes.
And attributes are going to be the data representation and ways that you can interact with your
object."
Lecture8_Chunk23,"object.
So you, as the programmer of this class, are going to decide how you want people to interact
with the object and what data this object is going to have. So for example, someone wrote
code that implements a list class, right, and we don't actually know how that was done. But we
can find out. So creating the class is implementing the class and figuring out data
representation and ways to interact with the class. Once that's done, you can then use your"
Lecture8_Chunk24,"representation and ways to interact with the class. Once that's done, you can then use your
class. And you use the class by creating new instances of the class.
So when you create a new instance, you essentially create a new object that has the type, the
name of your class. And you can create as many objects as you'd like. You can do all the
operations that you've defined on the class. So for example, someone wrote the code to"
Lecture8_Chunk25,"operations that you've defined on the class. So for example, someone wrote the code to
implement list class and then you can just use the list class like this. You can create a new list,
you can get the length pf the list, you can append to the end of the list, and so on and so on.
So let's start defining our own types, OK? So now you're going to define classes, you're going
to write classes which are going to define your own types of objects. So for today's lecture"
Lecture8_Chunk26,"to write classes which are going to define your own types of objects. So for today's lecture
we're going to look at code that's going to be in the context of a coordinate object. And a
coordinate object is essentially going to be an object that's going to define a point in an xy
plane. So x, y is going to be a coordinate in a 2D plane. So we're going to write code that's
going to allow us to define that kind of object."
Lecture8_Chunk27,"going to allow us to define that kind of object.
So the way we do that is we have to define a class. So we have to tell Python, hey, I'm defining
my own object type. So you do that with this class key word. So you say class, then you say
the name of your type. In this case, we're creating a type called coordinate. Just like we had
type list, type string, and so on. This is going to be a type called coordinate. And then in"
Lecture8_Chunk28,"type list, type string, and so on. This is going to be a type called coordinate. And then in
parentheses here, you put what the parents of the class are. For today's lecture, the parent of
the classes are going to be this thing called object, and object is the very basic type in Python.
It is the most basic type in Python.
And it implements things like being able to assign variables. So really, really basic operations"
Lecture8_Chunk29,"And it implements things like being able to assign variables. So really, really basic operations
that you can do with objects. So your coordinate is therefore going to be an object in Python.
All right. So we've told Python we wanted to define an object. So inside the class definition
we're going to put attributes. So what are attributes? Attributes are going to be data and
procedures that belong to the class, OK? Data are going to be the data representations and"
Lecture8_Chunk30,"procedures that belong to the class, OK? Data are going to be the data representations and
procedures are going to be ways that we can interact with the object.
The fact that they belong to the class means that the data and the procedures that we write
are only going to work with an object of this type. OK. If you try to use any of the data or the
procedures with an object of a different type, you're going to get an error because these data"
Lecture8_Chunk31,"procedures with an object of a different type, you're going to get an error because these data
and these attributes will belong to this particular class. So the data attributes is, what is the
object, right? What is the data that makes up the object? So for our coordinate example, it's
going to be the x and y values for coordinate.
We can decide that can be ints, we can decide that we can let them be floats, but it's going to"
Lecture8_Chunk32,"We can decide that can be ints, we can decide that we can let them be floats, but it's going to
have one value for the x-coordinate and one value for the y-coordinate. So those are data
attributes. And procedure attributes are better known as methods. And you can think of a
method as a function. Except that it's a function that only works with this particular type of
object. So with a coordinate object, in this case. So the methods are going to define how you
can interact with the object."
Lecture8_Chunk33,"can interact with the object.
So in a list, for example, we've said that you can append an item to the end of the list, we can
sort a list, things like that. So when you're defining methods, you're defining ways that people
can interact with your object. So for example, for a coordinate object, we can say that we can
take the distance between two coordinate points. OK? And that's going to be a way that you"
Lecture8_Chunk34,"take the distance between two coordinate points. OK? And that's going to be a way that you
can interact with two coordinate points. And just to be clear, these are going to belong to this
class, which means that if you try to use this distance method on two lists, for example, you're
going to get an error. Because this distance method was only defined to work with two
coordinate type objects.
All right, so let's carry on and continue implementing our class. So we've written this first line"
Lecture8_Chunk35,"All right, so let's carry on and continue implementing our class. So we've written this first line
so far, class coordinate object. So now let's define attributes. First thing we're going to define
are data attributes. Generally you define data attributes inside this init, and this is underscore,
underscore, init, underscore, underscore, and it's a special method or function in a class. And
the special method tells Python, when you implement the special method, it tells Python when"
Lecture8_Chunk36,"the special method tells Python, when you implement the special method, it tells Python when
you first create an object of this type, call this method or call this function.
So how do we do that? So let's implement it. So we say df because it's just a function. The
name is the special name, init. And we give it some parameters, right, just like any other
function. These last two parameters are x and y, which are going to represent how you create"
Lecture8_Chunk37,"function. These last two parameters are x and y, which are going to represent how you create
a coordinate object. So you give it a value for the x-coordinate and you give it a value for the
y-coordinate.
The self, however, is a little bit trickier. So the self is going to be a parameter when you define
this class that represents a particular instance of the class. So we're defining this coordinate
object in sort of a general way, right? We don't have a specific instance yet because we"
Lecture8_Chunk38,"object in sort of a general way, right? We don't have a specific instance yet because we
haven't created an object yet. But this self is going to be sort of a placeholder for any sort of
instance when you create the object. So in the definition of the class, whenever you want to
refer to attributes that belong to an instance, you have to use self dot. So this dot notation.
And the dot is going to say look for a data attribute x that belongs to this class."
Lecture8_Chunk39,"And the dot is going to say look for a data attribute x that belongs to this class.
So for methods that belong to the class, the first parameter is always going to be self. It can be
named anything you want, but really by convention it's always named self. So try to stick to
that. And then any other parameters beyond it are going to be just parameters as you would
put in a normal function. OK.
In this particular case, we're going to choose to initialize a coordinate object by two values,"
Lecture8_Chunk40,"In this particular case, we're going to choose to initialize a coordinate object by two values,
one for the x and one for the y. And inside this init method, we're going to have two
assignments. The first one says, the x data attribute of a coordinate object. I'm going to assign
it to whatever was passed in. And the y data attribute for a particular object is going to be
assigned whatever y was passed in.
Questions so far about how to write this init? Yeah, question.
AUDIENCE:
[INAUDIBLE]"
Lecture8_Chunk41,"Questions so far about how to write this init? Yeah, question.
AUDIENCE:
[INAUDIBLE]
PROFESSOR:
How do you make sure that x and y are inits or floats? So this is something that you could
write in the specifications, so the docstring with the triple quotes. So whoever uses the class
would then know that if they do something outside the specification, the code might not work
as expected. Or you could put in a cert statement inside the definition of the init just to sort of"
Lecture8_Chunk42,"as expected. Or you could put in a cert statement inside the definition of the init just to sort of
force that. Force that to be true. Great question.
Yeah, question.
AUDIENCE:
[INAUDIBLE]
PROFESSOR:
Does the x, does this self x and this x have to be the same name. The answer is no. And we're
going to see in class exercise that you can have it be different. OK. Great. So this defines the
way that we create an object."
Lecture8_Chunk43,"way that we create an object.
So now we have sort of a nice class. It's very simple, but we can start actually creating
coordinate objects. So when you create coordinate objects, you're creating instances of the
class. So this line here, C is equal to coordinate 3,4, is going to call the init method. It's going
to call the init method with x is equal to 3 and y is equal to 4.
I'm just going to go over here and I wrote this previously, because notice when we're creating"
Lecture8_Chunk44,"I'm just going to go over here and I wrote this previously, because notice when we're creating
an object here, we're only giving it two parameters. But in the init method, we have actually
three parameters, right? We have these three parameters here, but when we're creating an
object, we only give it two parameters. And that's OK because implicitly, Python is going to say
self is going to be this object C, so just by default, OK? So when you're creating a coordinate"
Lecture8_Chunk45,"self is going to be this object C, so just by default, OK? So when you're creating a coordinate
object, you're passing it all the variables except for self.
So this line here is going to call the init and it's going to do every line inside the init. So it's
going to create an x data attribute for C, a y data attribute for C, and it's going to assign 3 and
4 to those respectively. This next line here is origin equals coordinate 0, 0 creates another"
Lecture8_Chunk46,"4 to those respectively. This next line here is origin equals coordinate 0, 0 creates another
object. OK? It's another coordinate object whose value for x is 0 and whose value for y is 0. So
now we have two coordinate objects.
We can access the data attributes using this dot notation and we've seen that before, right?
When we've worked with lists we'd say something like, L dot append, right, when we create a
list. So the same dot notation can be used with your own objects in order to access data"
Lecture8_Chunk47,"list. So the same dot notation can be used with your own objects in order to access data
attributes. So here, this is going to print 3 because the x value for object C is 3, and the next
line, print origin x is going to print 0 because the x value for the object origin is 0. OK.
So we've created a coordinate object. We have to find the init method so we have a way to
create objects when we use the class. And then we can access the data attributes. But that's"
Lecture8_Chunk48,"create objects when we use the class. And then we can access the data attributes. But that's
kind of lame, right, because there isn't anything cool we can do with it. There isn't ways to
interact with this object. So let's add some methods. Remember methods are going to be
procedural attributes that allow us to interact with our object. Methods are like functions except
that there's a couple of differences which you'll see in a moment."
Lecture8_Chunk49,"that there's a couple of differences which you'll see in a moment.
And when you're calling methods, you're using the dot operator, like L dot append, for
example, for lists. So let's go back to defining our coordinate class and let's define a method
for it. So so far we've defined that part there, class coordinate and an init. So we have that. So
in this slide we're going to add this method here. So this method here is going to say I'm going"
Lecture8_Chunk50,"in this slide we're going to add this method here. So this method here is going to say I'm going
to define a method called distance and I'm going to pass in two parameters.
Remember self, the first parameter, is always going to be the instance of an object that you're
going to perform the operation on. So pretty much by convention it's always named self. And
then for this particular method, I'm going to give it another parameter, and I can name this"
Lecture8_Chunk51,"then for this particular method, I'm going to give it another parameter, and I can name this
whatever I want. I'm naming it other. And this is going to represent the other coordinate object
for which I want to find the distance from my self. So here I'm going to just implement the
Euclidean distance formula, which is x1 minus x2 squared, plus Y1 minus Y2 squared, and
square root of all that. So that's what I'm doing inside here."
Lecture8_Chunk52,"square root of all that. So that's what I'm doing inside here.
Self and other are coordinate objects. Inside this method, I have to refer to the x data
attributes of each object if I want to find the difference between the 2x values from them. So
that's why I'm doing self dot x here, right. If I just did x, I would be accessing just some variable
named x in a program which actually isn't even defined. So you always have to refer when as"
Lecture8_Chunk53,"named x in a program which actually isn't even defined. So you always have to refer when as
we're thinking about classes, you always have to refer to whose data attribute do you want to
access? In this case, I want to access the x data attribute of my self, and I want to subtract the
x data attribute of this other coordinate, square that, same for y, square that, and then add
those and take the square root of that."
Lecture8_Chunk54,"those and take the square root of that.
So notice this method is pretty much like a function, right? You have DF, some name, it takes
in parameters. It does some stuff and then it returns a value. The only difference is the fact
that you have a self here as the first thing and the fact that you always have to be conscious
about whose data attributes you're accessing. So you have to use the dot notation in order to"
Lecture8_Chunk55,"about whose data attributes you're accessing. So you have to use the dot notation in order to
decide whose data attributes you want access. So we've defined the method here, distance.
So this is in the class definition. Now how do we use it? So let's assume that the definition of
distance is up here. I didn't include the code. But really all you need to know is what it takes. It
takes a self and an other. So when you want to use this method to figure out a distance"
Lecture8_Chunk56,"takes a self and an other. So when you want to use this method to figure out a distance
between two coordinate objects, this is how you do it.
So the first line, I create one coordinate object. Second line, I create another coordinate
object. First one is named C, the second one is named 0. These are two separate objects.
And I'm going to find the distance. And I want to first call it on one object, so I'm going to say C"
Lecture8_Chunk57,"And I'm going to find the distance. And I want to first call it on one object, so I'm going to say C
dot, so I'm using the dot notation to call the method distance on object C. So Python says this
object C is of type coordinate. It's going to look up at the class coordinate that you defined. It's
going to find this method called distance and then it's going to say what parameters does it
take? So it takes another parameter, right, for the other and then, in the parentheses, I just"
Lecture8_Chunk58,"take? So it takes another parameter, right, for the other and then, in the parentheses, I just
have to give it this other perimeter.
An easier way to see what happens is by looking at what this line here is equivalent to. So the
third line here prints C dot distance 0 is equivalent to this one on the right. And this one on the
right essentially says, what's the name of the class, dot, dot notation, what's the method you"
Lecture8_Chunk59,"right essentially says, what's the name of the class, dot, dot notation, what's the method you
want to call, and then in parentheses you give it all of the variables including self. OK. So in
this case you're explicitly telling Python that self is C and other is 0. So this is a little bit easier
to understand, like that.
But it's a little cumbersome because you always have to write coordinate dot, coordinate dot,"
Lecture8_Chunk60,"But it's a little cumbersome because you always have to write coordinate dot, coordinate dot,
coordinate dot, for every data attribute you might want to access, for every procedural
attribute you might want to access. So by convention, it's a lot easier to do the one on the left.
And as I mentioned, Python implicitly says, if you're doing the one on the left, you can call this
method on a particular object and it's going to look up the type of the object and it's going to"
Lecture8_Chunk61,"method on a particular object and it's going to look up the type of the object and it's going to
essentially convert this on the left to the one on the right.
And this is what you've been using so far. So when you create a list, you say L is equal to 1, 2,
and then you say L.append, you know, 3 or whatever. So we've been using this notation on
the left pretty much from the beginning of class. So we have a coordinate class, we can create"
Lecture8_Chunk62,"the left pretty much from the beginning of class. So we have a coordinate class, we can create
a coordinate object, we can get the distance between two objects.
As you're using the class, if you wanted to use this coordinate class, and you were maybe
debugging at some point, a lot of you probably use print as a debug statement, right? And
maybe you want to print the value of a coordinate object. So if you create a coordinate object,"
Lecture8_Chunk63,"maybe you want to print the value of a coordinate object. So if you create a coordinate object,
C is equal to coordinate 3, 4, right? That's what we've done so far. If you print C, you get this
funny message.
Very uninformative, right? It basically says, well, C is an object of type coordinate at this
memory location in the computer. Which is not what you wanted at all, right? Maybe you
wanted to know what the values for x and y were. That would be a lot more informative. So by"
Lecture8_Chunk64,"wanted to know what the values for x and y were. That would be a lot more informative. So by
default, when you create your own type, when you print the object of that type, Python tells
you this sort of information which is not what you want. So what you need to do is you need to
define your own method that tells Python what to do when you call print on an object of this
type.
So this is going to be a special method, just like init is, because it starts and ends with double"
Lecture8_Chunk65,"So this is going to be a special method, just like init is, because it starts and ends with double
underscores. And the name of the method is underscore, underscore, str, underscore,
underscore. And if you define this method in your class, that tells Python, hey, when you see a
print statement that's on an object of type coordinate, call this method, look what it does, and
do everything that's inside it. And you can choose to make it do whatever you want inside your
definition of str."
Lecture8_Chunk66,"definition of str.
In this case, let's say when we print a coordinate object, we're going to print its x and y values
surrounded by angle brackets. That seems reasonable, right? So then from now on when you
print coordinate objects, you're going to see things like this, which is a lot more informative. So
how do we define this? So so far we've defined all that and the last part is going to be new. So
we define the init and the distance, and let's define this str."
Lecture8_Chunk67,"we define the init and the distance, and let's define this str.
So underscore, underscore, str, underscore, underscore, is a method. It's only going to take
self because you're just calling print on the object itself. There's no other parameters to it. Str
has to return a string, and in this particular case, we're going to return the string that's the
angle brackets concatenated with the x value of the object, self.x, concatenated with a comma,"
Lecture8_Chunk68,"angle brackets concatenated with the x value of the object, self.x, concatenated with a comma,
concatenated with the y value of this particular instance of an object, self.y, and then
concatenated with the angle brackets. So now any time you have print on an object of type
coordinate, you're going to call this special method str, if it's implemented in your code. Any
questions? OK.
So let's try to wrap our head around types and classes because we've seen a lot today. Let's"
Lecture8_Chunk69,"So let's try to wrap our head around types and classes because we've seen a lot today. Let's
create a coordinate object, assign it 3, 4, as we have been, and assign it to variable C. We've
implemented the str method, so when we print C, it's going to print out this nice three comma
for our angle brackets. If we print the type of C, this is actually going to give us class main
coordinate, which tells us that C is going to be an object that is of type class coordinate."
Lecture8_Chunk70,"coordinate, which tells us that C is going to be an object that is of type class coordinate.
If we look at coordinate as a class, if we print what coordinate is, coordinate is a class, right?
So this is what Python tells us, if we print coordinate, it's a class named coordinate. And if we
print the type of a coordinate, well that's just going to be a type. So class is going to be a type.
So you're defining the type of an object. If you'd like to figure out whether a particular object is"
Lecture8_Chunk71,"So you're defining the type of an object. If you'd like to figure out whether a particular object is
an instance of a particular class, you use this special function called is instance. So if you print
is instance C comma coordinate, this is going to print true because C is an object that is of
type coordinate.
Couple more words on these special operators. So these special operators allow you to
customize your classes which can add some cool functionality to them. So these special"
Lecture8_Chunk72,"customize your classes which can add some cool functionality to them. So these special
operators are going to be things like addition, subtraction, using the equal equal sign, greater
than, less than, length and so on and so on. So just like str, if you implement any of these in
your classes, this is going to tell Python. So for example, if we've implemented this
underscore, underscore, add, underscore, underscore in our class, this is going to tell Python"
Lecture8_Chunk73,"underscore, underscore, add, underscore, underscore in our class, this is going to tell Python
when you use this plus operator between two objects of type coordinate to call this method.
If you have not implemented this method and you try to add two objects of type coordinate,
you're going to get an error because Python doesn't actually know right off the bat how to add
two coordinate objects, right? You have to tell it how to do that. And you tell it how to do that"
Lecture8_Chunk74,"two coordinate objects, right? You have to tell it how to do that. And you tell it how to do that
by implementing this special method. Same with subtract. Same with equals.
So if you want to figure out whether two objects are equal. And when you implement these
methods in your own class, you can decide exactly what you want to do. So what happens
when you add two coordinate objects? Do you just add the x values, do you just add the y"
Lecture8_Chunk75,"when you add two coordinate objects? Do you just add the x values, do you just add the y
values, do you get them both together, do you do whatever you'd like to do. And then you
document what you've decided.
So let's create a fraction object. So we've looked at coordinate, we saw sort of a higher level
car object. Let's look at a fraction object. Fraction object is going to be, is going represent a
number that's going to be a numerator slash denominator. OK. So that's going to be a fraction"
Lecture8_Chunk76,"number that's going to be a numerator slash denominator. OK. So that's going to be a fraction
object. So the way I've decided to internally represent a fraction object is with two numbers.
And I've decided that I will not let them be floats. They have to be integers, hence the assert
over here. So inside the init, I've decided I'm going to represent my fracture with two numbers,
one for the numerator and one for the denominator."
Lecture8_Chunk77,"one for the numerator and one for the denominator.
So when I create a fraction object, I'm going to pass in a numerator and a denominator. And a
particular instance is going to have self dot numerator and self dot denominator as its data
attributes and I'm assigning those to be whatever's passed into my init. Since I plan on
debugging this code maybe possibly sometime in the future, I'm also including an str method"
Lecture8_Chunk78,"debugging this code maybe possibly sometime in the future, I'm also including an str method
and the str method is going to print a nice looking string that's going to represent the
numerator, and then a slash, and then the denominator. And then I've also implemented some
other special methods.
How do I add two fractions? How do I subtract two fractions? And how do I convert a fraction
to a float? The add and subtract are almost the same, so let's look at the add for the moment."
Lecture8_Chunk79,"to a float? The add and subtract are almost the same, so let's look at the add for the moment.
How do we add two fractions? We're going to take self, which is the instance of an object that I
want to do the add operation on, and we're going to take other, which is the other instance of
an object that I want to do the operation on, so the addition, and I'm going to figure out the
new top. So the new top of the resulting fraction. So it's my numerator multiplied by the other"
Lecture8_Chunk80,"new top. So the new top of the resulting fraction. So it's my numerator multiplied by the other
denominator plus my denominator multiplied by the other numerator and then divided by the
multiplication of the two denominators.
So the top is going to be that, the bottom is going to be that. Notice that we're using self dot,
right? Once again, we're trying to access the data attributes of each different instance, right, of"
Lecture8_Chunk81,"right? Once again, we're trying to access the data attributes of each different instance, right, of
myself and the other object that I'm working with. So that's why I have to use self dot here.
Once I figure out the top and the bottom of the addition, I'm going to return, and here notice
I'm returning a fraction object. It's not a number, it's not a float, it's not an integer. It's a new
object that is of the exact same type as the class that I'm implementing."
Lecture8_Chunk82,"object that is of the exact same type as the class that I'm implementing.
So as it's the same type of object, then on the return value I can do all of the exact same
operations that I can do on a regular fraction object. Sub is going to be the same. I'm returning
a fraction object. Float is just going to do the division for me, so it's going to take the
numerator and then divide it by the denominator, just divide the numbers. And then I'm"
Lecture8_Chunk83,"numerator and then divide it by the denominator, just divide the numbers. And then I'm
defining here my own method called inverse. And this is just going to take the inverse of the
instance I'm calling this method on. And so it's going to also return a new fraction object that
just has the denominator as the top part and the numerator as the bottom part. So then we
have some code here. So that's how I implement my fraction object."
Lecture8_Chunk84,"have some code here. So that's how I implement my fraction object.
So now let's use it and see what it gives us. A is equal to a fraction 1, 4. This is going to be 1
over 4 for a. And b is going to be 3 over four. When I do C, notice I'm using the plus operator
between two fraction objects, right? A and b are fraction objects so Python's going to say, OK,
is there an underscore, underscore, add, underscore, underscore, method implemented? It is"
Lecture8_Chunk85,"is there an underscore, underscore, add, underscore, underscore, method implemented? It is
and it's just going to do whatever's inside here. So it's going to say self dot numerator plus
other dot denominator. It's going to calculate the top and the bottom. It's going to turn a new
fraction object.
So this is going to be 4 plus 12 divided by 16, and 16 over 16. So C as a fraction object is
going to be 16 for the numerator and 16 for the denominator because it's a fraction object. If I"
Lecture8_Chunk86,"going to be 16 for the numerator and 16 for the denominator because it's a fraction object. If I
print C, it should print 16 over 16, so we can even run it, so print 16 over 16. If I print floats C,
so this special method float here is going to say, is there a method that converts a fraction to a
float and there is. It's this one implemented right here. So it's just going to divide the two
numbers, top and bottom, which gives me 1. So it's this one here and here."
Lecture8_Chunk87,"numbers, top and bottom, which gives me 1. So it's this one here and here.
Notice I'm doing the exact same method call, except I'm doing it the other way where you type
in the name of the class, name of the method, and then what you're calling it on, and this gives
the exact same value here, 1.0. And then here I'm calling the method inverse on object B
which is going to invert 3 over 4 to be 4 over 3. And then I'm converting it to a float and then"
Lecture8_Chunk88,"which is going to invert 3 over 4 to be 4 over 3. And then I'm converting it to a float and then
I'm printing the value. So it gives me 1.33. So take a look at this code in more detail and see if
you can trace through all of those different things and see if you can also write your own new
fraction objects. OK.
So last slide. Power of object oriented programming is that you can bundle together objects
that are of the exact same type. And all of these objects are going to have the same data"
Lecture8_Chunk89,"that are of the exact same type. And all of these objects are going to have the same data
representation and the same methods that you can do on them. And ultimately, you're going
to be building these layers of abstraction. So you're going to be building on a basic object type
in Python, you're going to have integer objects, float objects. On top of those, you can create
lists, dictionaries. And on top of those, you can even create your own object types as we saw
in this lecture today."
Lecture9_Chunk1,"MITOCW | watch?v=FlGjISF3l78
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high-quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
ANA BELL:
All right, everyone, let's get started. So today is going to be the second lecture on object-"
Lecture9_Chunk2,"All right, everyone, let's get started. So today is going to be the second lecture on object-
oriented programming. So just a quick recap of last time-- on Monday, we saw-- we were
introduced to this idea of object-oriented programming, and we saw these things called
abstract data types. And these abstract data types we implemented through Python classes.
And they allowed us to create our own data types that sort of abstracted a general object of
our choosing, right?"
Lecture9_Chunk3,"our choosing, right?
So we've used lists before, for example. But with abstract data types, we were able to create
objects that were of our own types. We saw the coordinate example. And then at the end of
the class, we saw the fraction example.
So today we're going to talk a little bit more about object-oriented programming and classes.
We're going to see a few more examples. And we're going to talk about a few other nuances"
Lecture9_Chunk4,"We're going to see a few more examples. And we're going to talk about a few other nuances
of classes, talk about information hiding and class variables. And in the second half of the
lecture, we're going to talk about the idea of inheritance. So we're going to use object-oriented
programming to simulate how real life works. So in real life, you have inheritance. And in
object-oriented programming, you can also simulate that."
Lecture9_Chunk5,"object-oriented programming, you can also simulate that.
OK, so the first few slides are going to be a little bit of recap just to make sure that everyone's
on the same page before I introduce a couple of new concepts related to classes. So recall
that when-- in the last lecture, we talked about writing code from two different perspectives,
right? The first was from someone who wanted to implement a class. So implementing the
class meant defining your own object type."
Lecture9_Chunk6,"class meant defining your own object type.
So you defined the object type when you defined the class. And then you decided what data
attributes you wanted to define in your object. So what data makes up the object? What is the
object, OK?
In addition to data attributes, we also saw these things called methods. And methods were
ways to tell someone how to use your data type. So what are ways that someone can interact"
Lecture9_Chunk7,"ways to tell someone how to use your data type. So what are ways that someone can interact
with the data type, OK? So that's from the point of view of someone who wants to write their
own object type. So you're implementing a class.
And the other perspective was to write code from the point of view of someone who wanted to
use a class that was already written, OK? So this involved creating instances of objects. So"
Lecture9_Chunk8,"use a class that was already written, OK? So this involved creating instances of objects. So
you're using the object type. Once you created instances of objects, you were able to do
operations on them. So you were able to see what methods whoever implemented the class
added. And then, you can use those methods in order to do operations with your instances.
So just looking at the coordinate example we saw last time, a little bit more in detail about what"
Lecture9_Chunk9,"So just looking at the coordinate example we saw last time, a little bit more in detail about what
that meant-- so we had a class definition of an object type, which included deciding what the
class name was. And the class name basically told Python what type of an object this was,
OK? In this case, we decided we wanted to name a coordinate-- we wanted to create a
Coordinate object. And the type of this object was therefore going to be a coordinate."
Lecture9_Chunk10,"Coordinate object. And the type of this object was therefore going to be a coordinate.
We defined the class in the sort of general way, OK? So we needed a way to be able to
access data attributes of any instance. So we use this self variable, OK? And the self variable
we used to refer to any instance-- to the data attributes of any instance in a general way
without actually having a particular instance in mind, OK?"
Lecture9_Chunk11,"without actually having a particular instance in mind, OK?
So whenever we access data attributes, we would say something like self dot to access a data
attribute. You'd access the attribute directly with self.x. Or if you wanted to access a method,
you would say self, dot, and then the method name-- for example, distance.
And really, the bottom line of the class definition is that your class defines all of the data-- so"
Lecture9_Chunk12,"And really, the bottom line of the class definition is that your class defines all of the data-- so
data attributes-- and all of the methods that are going to be common across all of the
instances. So any instance that you create of a particular object type, that instance is going to
have this exact same structure, OK? The difference is that every instance's values are going
to be different.
So when you're creating instances of classes, you can create more than one instance of the"
Lecture9_Chunk13,"So when you're creating instances of classes, you can create more than one instance of the
same class. So we can create a Coordinate object here using this syntax right here. So you
say the type, and then, whatever values it takes in. And you can create more than one
Coordinate object.
Each Coordinate object is going to have different data attributes. Sorry, it's going to have
different data attribute values, OK? Every Coordinate object is going to have an x value and a"
Lecture9_Chunk14,"different data attribute values, OK? Every Coordinate object is going to have an x value and a
y value. But the x and y values among different instances are going to vary, OK? So that's the
difference between defining a class and looking at a particular instance of a class. So
instances have the structure of the class. So for a coordinate, all instances have an x value
and a y value. But the actual values are going to vary between the different instances."
Lecture9_Chunk15,"and a y value. But the actual values are going to vary between the different instances.
OK, so ultimately, why do we want to use object-oriented programming? So, so far, the
examples that we've seen were numerical, right-- a coordinate, a fraction. But using object-
oriented programming, you can create objects that mimic real life. So if I wanted to create
objects of-- an object that defined a cat and an object that defined a rabbit, I could do that with"
Lecture9_Chunk16,"objects of-- an object that defined a cat and an object that defined a rabbit, I could do that with
object-oriented programming. I would just have to decide, as a programmer, what data and
what methods I'd want to assign to these groups of objects, OK?
So using object-oriented programming, each one of these is considered a different object. And
as a different object, I can decide that a cat is going to have a name, an age, and maybe a"
Lecture9_Chunk17,"as a different object, I can decide that a cat is going to have a name, an age, and maybe a
color associated with it. And these three here, on the right, each one of these rabbits is also an
object. And I'm going to decide that I'm going to represent a rabbit by just an age and a color,
OK? And with object-oriented programming, using these attributes, I can group these three
objects together and these three objects together, OK?"
Lecture9_Chunk18,"objects together and these three objects together, OK?
So I'm grouping sets of objects that are going to have the same attributes together. And
attributes-- this is also a recap of last time-- come in two forms, right, data attributes and
procedural attributes. So the data attributes are basically things that define what the object is.
So how do you represent a cat as an object? And it's up to you, as the programmer, to decide
how you want to do that."
Lecture9_Chunk19,"how you want to do that.
For a coordinate, it was pretty straightforward. You had an x and a y value. If we're
representing something more abstract like an animal, then maybe I would say, well, I'm going
to represent an animal by an age and a name, OK? So it's really up to you to decide how you
want to represent-- what data attributes you want to represent your object with.
Procedural attributes were also known as methods. And the methods are essentially asking,"
Lecture9_Chunk20,"Procedural attributes were also known as methods. And the methods are essentially asking,
what can your object do, OK? So how can someone who wants to use your object-- how can
someone interact with it? So for a coordinate, we saw that you could find the distance between
two coordinates. Maybe for our abstract Animal object, you might have it make a sound, OK,
by maybe printing to the screen or something like that."
Lecture9_Chunk21,"by maybe printing to the screen or something like that.
OK, this slide's also a recap of how to create a class just to make sure everyone's on the same
page before we go on. So we defined a class using this class keyword. And we said, class, the
name of the class. So now we're going to create a more abstract Animal class. We're going to
see, in the second half of the lecture, what it means to put something else in the parentheses."
Lecture9_Chunk22,"see, in the second half of the lecture, what it means to put something else in the parentheses.
But for now, we say that an animal is an object in Python. So that means it's going to have all
of the properties that any other object in Python has.
And as we're creating this animal, we're going to define how to create an instance of this class.
So we say def. And this __init__ was the special method that told Python how to create an"
Lecture9_Chunk23,"So we say def. And this __init__ was the special method that told Python how to create an
object. Inside the parentheses, remember, we have the self, which is a variable that we use to
refer to any instance of the class, OK? We don't have a particular instance in mind, we just
want to be able to refer to any instance, OK? So we use this self variable.
And then, the second parameter here is going to represent what other data we use to initialize"
Lecture9_Chunk24,"And then, the second parameter here is going to represent what other data we use to initialize
our object with. So in this case, I'm going to say, I'm going to initialize an Animal object with an
age, OK? So when I create an animal, I need to give it an age.
Inside the __init__ are any initializations that I want to make. So the first thing is, I'm going to
assign an instance variable, age-- so this is going to be the data attribute age-- to be whatever"
Lecture9_Chunk25,"assign an instance variable, age-- so this is going to be the data attribute age-- to be whatever
is passed in. And then, I'm also making another assignment here, where I'm assigning the
data attribute name to be None originally.
Later on in the code, when I want to create an Animal object, I say the class name. And then I
pass it in whatever parameters it takes-- in this case, the age. And I'm assigning it to this
instance here, OK?"
Lecture9_Chunk26,"instance here, OK?
All right, so now we have this class, Animal. We've done the first part here, which is to initialize
the class, right? So we've told Python how to create an object of this type. There's a few other
methods here that I've implemented. Next two we call getters, and the two after that we call
setters, OK? And getters and setters are very commonly used when implementing a class. So
getters essentially return the values of any of the data attributes, OK?"
Lecture9_Chunk27,"getters essentially return the values of any of the data attributes, OK?
So if you look carefully, get_age() is just returning self.age, and get_name() just returns
self.name. So they're very simple methods. Similarly, set_age() and set_name()-- we're going
to see what this funny equal sign is doing here in the next couple of slides. But setters do a
very similar thing where they're going to set the data attributes to whatever is passed in, OK?"
Lecture9_Chunk28,"very similar thing where they're going to set the data attributes to whatever is passed in, OK?
So those are getters and setters. And then, the last thing down here is this __str__ method.
And this __str__ method is used to tell Python how to print an object of this type Animal. So if
you didn't have this __str__ method, if you remember from last lecture, what ends up
happening is you're going to get some message when you print your object that says, this is"
Lecture9_Chunk29,"happening is you're going to get some message when you print your object that says, this is
an object of type Animal at this memory location, which is very uninformative, right? So you
implement this method here, which tells Python how to print an object of this type, OK?
So the big point of this slide is that you should be using getters and setters-- you should be
implementing getters and setters for your classes. And we're going to see, in the next couple"
Lecture9_Chunk30,"implementing getters and setters for your classes. And we're going to see, in the next couple
of slides, why exactly. But basically, they're going to prevent bugs from coming into play later
on if someone decides to change implementation.
So we saw how to-- so the previous slide, this slide here, shows the implementation of the
Animal class. And here we can see how we can create an instance of this object. So we can"
Lecture9_Chunk31,"Animal class. And here we can see how we can create an instance of this object. So we can
say a = Animal(3). So this is going to create a new Animal object with an age of 3. And we can
access the object through the variable a.
Dot notation, recall, is a way for you to access data attributes and methods of a class, OK? So
you can say a.age later on in your program, and that is allowed. It'll try to access the age data"
Lecture9_Chunk32,"you can say a.age later on in your program, and that is allowed. It'll try to access the age data
attribute of this particular instance of the class, a. So this is going to give you 3.
However, it's actually not recommended to access data attributes directly. So this is the
reason-- so you're going to see in the next slide, the reason-- why we're going to use getters
and setters. Instead, you should use the get_age() getter method to get the age of the animal."
Lecture9_Chunk33,"and setters. Instead, you should use the get_age() getter method to get the age of the animal.
So this is going to return, also, 3. So these are going to do the same thing.
And the reason why you'd want to use getters and setters is this idea of information hiding,
OK? So the whole reason why we're using classes in object-oriented programming is so that
you can abstract certain data from the user, OK? One of the things you should be abstracting"
Lecture9_Chunk34,"you can abstract certain data from the user, OK? One of the things you should be abstracting
is these data attributes. So users shouldn't really need to know how a class is implemented.
They should just know how to use the class, OK?
So consider the following case. Let's say whoever wrote the Animal class wants to change the
implementation. And they've decided they don't want to call the data attribute ""age"" anymore,"
Lecture9_Chunk35,"implementation. And they've decided they don't want to call the data attribute ""age"" anymore,
they want to call it ""years,"" OK? So when they initialize an animal they say self.years = age. So
an animal still gets initialized by its age. And the age gets passed into a data attribute named
""years,"" OK?
Since I'm implementing this class, I want to have a getter, which is going to return self.years.
So I'm not returning self.age anymore, because age is no longer the data attribute I'm using."
Lecture9_Chunk36,"So I'm not returning self.age anymore, because age is no longer the data attribute I'm using.
So with this new implementation, if someone was using this implementation and was
accessing age directly as-- was accessing the data attribute age directly-- with this new
implementation, they'd actually get an error, right? Because this animal that they created using
my old implementation no longer has an attribute named ""age."" And so Python's going to spit"
Lecture9_Chunk37,"my old implementation no longer has an attribute named ""age."" And so Python's going to spit
out an error saying no attribute found or something like that, OK?
If they were using the getter a.get_age()-- the person who implemented the class re-
implemented get_age() to work correctly, right, with their new data attribute, years, as
opposed to age-- so if I was using the getter get_age(), I wouldn't have run into the bug, OK?"
Lecture9_Chunk38,"opposed to age-- so if I was using the getter get_age(), I wouldn't have run into the bug, OK?
So things to remember-- write getters and setters for your classes. And later on in your code,
use getters and setters to prevent bugs and to promote easy to maintain code.
OK, so information hiding is great. But having said that, Python's actually not very great at
information hiding, OK? Python allows you to do certain things that you should never be doing."
Lecture9_Chunk39,"information hiding, OK? Python allows you to do certain things that you should never be doing.
OK. So the first, we've just seen. The first is to access data attributes from outside of the class,
OK? So if I were to say a.age, Python allows me to do that without using a getter and setter.
Python also allows you to write to data attributes from outside the class. So if I implemented
the class Animal assuming that age was a number, an integer, and all of my methods work as"
Lecture9_Chunk40,"the class Animal assuming that age was a number, an integer, and all of my methods work as
long as age is an integer, but someone decided to be smart and, outside of the class, set age
to be infinite as a string, that might cause the code to crash, OK? Python allows you to do that.
But now you're breaking the fact that age has to be an integer, right? So now the methods
should probably be checking the fact that age is an integer all the time."
Lecture9_Chunk41,"should probably be checking the fact that age is an integer all the time.
The other thing that you're allowed to do is to create data attributes outside of the class
definition, OK? So if I wanted to create a new data attribute called ""size"" for this particular
instance, Python also allows me to do that. And I can set it to whatever I want, OK? So Python
allows you to do all these things, but it's actually not good style to do any of them. So just don't
do it. All right."
Lecture9_Chunk42,"do it. All right.
So the last thing I want to mention-- the last thing about classes before we go on to
inheritance-- is this idea called default arguments. And default arguments are passed into
methods. And since methods are functions, you can also pass in different arguments to
functions.
So for example, this set_name() method had self. And then, this new name is equal to this
empty string here, OK? We haven't seen this before. But this is called a default argument. And"
Lecture9_Chunk43,"empty string here, OK? We haven't seen this before. But this is called a default argument. And
you can use the function in one of two ways.
The first way is so we can create a new instance of an Animal type object with this line here, a
= Animal(3). And then we can say a.set_name(). So this calls the setter method to set the
name. And notice, we've always said that you have to put in parameters for everything other
than self, OK? But here we have no parameters passed in."
Lecture9_Chunk44,"than self, OK? But here we have no parameters passed in.
But that's OK, because newname actually has a default argument, OK? So that tells Python, if
no parameter is passed in for this particular formal parameter, then use whatever is up here
by default. So if I haven't passed in the parameter a.get_na-- a.set_name(), sorry--
a.sett_name() is going to be setting the name to the empty string, because that's what the"
Lecture9_Chunk45,"a.sett_name() is going to be setting the name to the empty string, because that's what the
default parameter is. So in the next line, when I print a.get_name(), this is just going to print
the empty string, OK?
If you do want to pass in a parameter, you can do so as normal. So you can say a = Animal(3),
a.set_name(), and then pass in a parameter here. And then, newname is going to be assigned
to whatever parameter is passed in like that. Whatever you pass in overrides the default"
Lecture9_Chunk46,"to whatever parameter is passed in like that. Whatever you pass in overrides the default
argument, and everything is good. So when I print a.get_name(), this is going to print out the
name that you've passed in. Questions about default? Yeah.
AUDIENCE:
[INAUDIBLE]
ANA BELL:
What if you don't provide a default value for--
AUDIENCE:
For newname?
ANA BELL:
For newname? If you don't provide a default argument for newname and you do this case"
Lecture9_Chunk47,"ANA BELL:
For newname? If you don't provide a default argument for newname and you do this case
here, then that's going to give you an error. So Python's going to say something like, expected
one argument, got zero, or something like that. Great question. OK.
All right, so let's move on to this idea of hierarchies, OK? So the great thing about object-
oriented programming is that it allows us to add layers of abstraction to our code, all right? So"
Lecture9_Chunk48,"oriented programming is that it allows us to add layers of abstraction to our code, all right? So
we don't need to know how very, very low-level things are implemented in order to use them.
And we can build up our code to be more and more complex as we use up these different
abstractions.
So consider every one of these things on this slide as being a separate object, all right? Every
one of these things can be considered to be an animal, OK? According to our implementation"
Lecture9_Chunk49,"one of these things can be considered to be an animal, OK? According to our implementation
of an animal, the one thing that an animal has is an age, OK? And that's probably true, right?
Every one of these things has an age.
But now I want to build up on this and create separate groups, right? And each one of these
separate groups that I create on top of Animal is going to have its own functionality, right?
They're going to be a little bit more specific, a little more specialized."
Lecture9_Chunk50,"They're going to be a little bit more specific, a little more specialized.
So I can create these three groups now, a cat, a rabbit, and a person group. And for example-
- so they're all animals, right? They all have an age. But for example, maybe a person's going
to have a list of friends whereas a cat and a rabbit do not. Maybe a cat has a data attribute for
the number of lives they have left, right, whereas a person and a rabbit do not, OK?"
Lecture9_Chunk51,"the number of lives they have left, right, whereas a person and a rabbit do not, OK?
So you can think of adding these more specialized-- adding functionality to each one of these
subgroups, OK? So they're going to be more and more specialized, but all of them retaining
the fact that they are animals. So they all have an age, for example. So on top of these, we
can add another layer and say that a student is a person and is an animal, OK? But in addition"
Lecture9_Chunk52,"can add another layer and say that a student is a person and is an animal, OK? But in addition
to having an age and maybe also having a list of friends, a student might also have a major or-
- they're pretty, so maybe-- their favorite subject in school.
So that's the general idea of hierarchies, OK? So we can sort of abstract the previous slide
into this one and say that we have parent classes and child classes, OK? The Animal class is
like our parent class. It's the highest-level class."
Lecture9_Chunk53,"like our parent class. It's the highest-level class.
Inheriting from the Animal class, we have these child classes or subclasses, OK? Whatever an
animal can do, a person can do. Whatever an animal can do, a cat can do. And whatever an
animal can do, a rabbit can do, OK-- that is, have an age and maybe some really basic
functionality, OK? But between person, cat, and rabbit, they're going to be varying wildly as to"
Lecture9_Chunk54,"functionality, OK? But between person, cat, and rabbit, they're going to be varying wildly as to
the kinds of things that they can do, right? But they can all do whatever Animal can do.
So child classes inherit all of the data attributes and all of the methods, or behaviors, that their
parent's classes have, OK? But child classes can add more information. Like for example, a
person can have a list of friends whereas a general animal will not."
Lecture9_Chunk55,"person can have a list of friends whereas a general animal will not.
It can add more behavior. Like, maybe a cat can climb trees whereas people and rabbits
cannot. Or you can also override behavior. So in the previous one, we had animal, person,
student. So maybe we have, an animal doesn't speak at all, but a person can speak. So that's
added functionality to the person.
And maybe a person can only say hello. But then, when we talk to a student, we can override"
Lecture9_Chunk56,"And maybe a person can only say hello. But then, when we talk to a student, we can override
the fact-- override the speak() method of a person and say that a student can say, you know, I
have homework, or I need sleep, or something like that, OK? So we have the same speak()
method for both person and student, because they can both speak. But student will override
the fact that they say hello with something else."
Lecture9_Chunk57,"the fact that they say hello with something else.
OK, so let's look at some code to put this into perspective. So we have this Animal class, which
we've seen before. This is the parent class, OK? It inherits from object, which means that
everything that a basic object can do in Python, an animal can do, which is things like binding
variables, you know, very low-level things, OK? We've seen the __init__. We've seen the two"
Lecture9_Chunk58,"variables, you know, very low-level things, OK? We've seen the __init__. We've seen the two
getters, the setters, and the string method to print an object of type Animal.
All right, now, let's create a subclass of Animal. We'll call it Cat, OK? We create a class named
Cat. In parentheses, instead of putting ""object,"" we now put ""Animal."" And this tells Python that
Cat's parent class is Animal. So everything that an animal can do, a cat can do. So that"
Lecture9_Chunk59,"Cat's parent class is Animal. So everything that an animal can do, a cat can do. So that
includes all of the attributes, which was age and name, and all of the methods. So all the
getters, the setters, the __str__, the __init__, everything that the animal had, now the cat has-
- the Cat class has.
In the Cat class, we're going to add two more methods though. The first is speak(). So speak()
is going to be a method that's going to just take in the self, OK-- no other parameters. And all"
Lecture9_Chunk60,"is going to be a method that's going to just take in the self, OK-- no other parameters. And all
it's doing is printing ""meow"" to the screen-- very simple, OK? So through this speak(), we've
added new functionality to the class. So an animal couldn't speak, whereas a cat says ""meow.""
Additionally, through this __str__ method here, we're overriding the animal __str__, OK? So if
we go back to the previous slide, we can see that the animal's __str__ had animal, plus the"
Lecture9_Chunk61,"we go back to the previous slide, we can see that the animal's __str__ had animal, plus the
name, plus the age here whereas the cat's __str__ now says ""cat,"" name, and the age, OK?
So this is just how I chose to implement this, OK? So here I've overridden the __str__ method
of the Animal class.
Notice that this class doesn't have an __init__, and that's OK. Because Python's actually going
to say, well, if there's no __init__ in this particular method-- sorry, in this particular class-- then"
Lecture9_Chunk62,"look to my parents and say, do my parents have an __init__, OK? And if so, use that __init__.
So that's actually true for any other methods. So the idea here is, when you have hierarchies,
you have a parent class, you have a child class, you could have a child class to that child
class, and so on and so on. So you can have multiple levels of inheritance.
What happens when you create an object that is of type something that's been-- of a type"
Lecture9_Chunk63,"What happens when you create an object that is of type something that's been-- of a type
that's the child class of a child class of a child class, right? What happens when you call a
method on that object? Well, Python's are going to say, does a method with that name exist in
my current class definition? And if so, use that.
But if not, then, look to my parents. Do my parents know how to do that, right? Do my parents"
Lecture9_Chunk64,"But if not, then, look to my parents. Do my parents know how to do that, right? Do my parents
have a method for whatever I want to do? If so, use that. If not, look to their parents, and so
on and so on. So you're sort of tracing back up your ancestry to figure out if you can do this
method or not.
So let's look at a slightly more complicated example. We have a class named Person. It's
going to inherit from Animal. Inside this person, I'm going to create my own-- I'm going to"
Lecture9_Chunk65,"going to inherit from Animal. Inside this person, I'm going to create my own-- I'm going to
create an __init__ method. And the __init__ method is going to do something different than
what the animal's __init__ method is doing. It's going to take in self, as usual. And it's going to
take in two parameters as opposed to one, a name and an age.
First thing the __init__ method's doing is it's calling the animal's __init__ method. Why am I"
Lecture9_Chunk66,"First thing the __init__ method's doing is it's calling the animal's __init__ method. Why am I
doing that? Well, I could theoretically initialize the name and the age data attributes that
Animal initializes in this method. But I'm using the fact that I've already written code that
initializes those two data attributes. So why not just use it, OK?
So here, this says, I'm going to call the class Animal. I'm going to call its __init__ method. And"
Lecture9_Chunk67,"So here, this says, I'm going to call the class Animal. I'm going to call its __init__ method. And
I'm going to leave it up to you to-- not you as the class, but I'm talking as the programs is
running-- I'm going to leave it up to you to figure out how to initialize an animal with this
particular age and what to name it. So Python says, yep, I know how to do this, so I'm going to
go ahead and do that for you. So now it says person is an animal. And I've initialized the age
and the name for you."
Lecture9_Chunk68,"and the name for you.
The next thing I'm doing in the __init__ is I'm going to set the name to whatever name was
passed in, OK? So in the __init__, notice, I can do whatever I want, including calling methods.
And then, the last thing I'm doing here is I'm going to create a new data attribute for Person,
which is a list of friends, OK? So an animal didn't have a list of friends, but a person is going
to."
Lecture9_Chunk69,"to.
The next four methods here are-- this one's a getter, so it's going to return the list of friends.
This is going to append a friend to the end of my list. I want to make a note that I actually
didn't write a method to remove friends. So once you get a friend, they're friends for life. But
that's OK.
The next method here is speak(), which is going to print ""hello"" to the screen. And the last
method here is going to get the age difference between two people. So that just basically"
Lecture9_Chunk70,"method here is going to get the age difference between two people. So that just basically
subtracts their age and says it's a five-year age difference, or whatever it is. And down here, I
have an __str__ method, which I've overridden from the Animal, which, instead of ""animal:
name,"" it's going to say ""person: name : age,"" OK?
So we can run this code. So that's down here. I have an animal person here. So I'm going to"
Lecture9_Chunk71,"So we can run this code. So that's down here. I have an animal person here. So I'm going to
run this code. And what did I do? I created a new person. I gave it a name and an age. I
created another person, a name and an age. And here I've just run some methods on it, which
was get_name(), get_age(), get_name(), and get_age() for each of the two people. So that
printed, Jack is 30, Jill is 25.
If I print p1, this is going to use the __str__ method of Person. So it's to print ""person:"", their"
Lecture9_Chunk72,"If I print p1, this is going to use the __str__ method of Person. So it's to print ""person:"", their
name, and then, their age. p1.speak() just says ""hello."" And then, the age difference between
p1 and p2 is just 5. So that's just subtracting and then printing that out to the screen.
OK, so that's my person. Let's add another class. This class is going to be a student, and it's
going to be a subclass of Person. Since it's a subclass of Person, it's going to-- a student is"
Lecture9_Chunk73,"going to be a subclass of Person. Since it's a subclass of Person, it's going to-- a student is
going inherit all the attributes of a person, and therefore, all the attributes of an animal.
The __init__ method of a student is going to be a little different from the one of Person. We're
going to give it a name, an age, and a major. Notice we're using default arguments here. So if
I create a student without giving it a major, the major is going to be set to None originally."
Lecture9_Chunk74,"I create a student without giving it a major, the major is going to be set to None originally.
Once again, this line here, Person.__init__(self, name, age), tells Python, hey, you already
know how to initialize a person for me with this name and this age. So can you just do that?
And Python says, yes, I can do that for you. And so that saves you, maybe, like five lines of
code just by calling the __init__ method that you've already written through Person, OK?"
Lecture9_Chunk75,"code just by calling the __init__ method that you've already written through Person, OK?
So Student has been initialized to be a person. And additionally, we're going to set another
data attribute for the student to be the major. And we're going to set the major to be None.
The student is going to get this setter here, this setter method, which is going to change the
major to whatever else they want if they want to change it. And then, I'm going to override the
speak() method."
Lecture9_Chunk76,"speak() method.
So the speak method for the person, recall, just said ""hello."" A student is going to be a little bit
more complex. I'm going to use the fact that someone created this random class, OK? So this
is where we can write more interesting code by reusing code that other people have written.
So someone wrote a random class that can do cool things with random numbers.
So if I want to use random numbers in my code, I'm going to put this ""import random"" at the"
Lecture9_Chunk77,"So if I want to use random numbers in my code, I'm going to put this ""import random"" at the
top of my code, which essentially brings in all of the methods from the Random class, one of
the methods being this random() method. So random() is a random() method from the
Random class. And this essentially gives me a number between 0 and 1, including 0 but not
including 1, OK?
So this random number I get here is going to help me write my method for speak(), where it's"
Lecture9_Chunk78,"So this random number I get here is going to help me write my method for speak(), where it's
going to-- with 25% probability, it's either going to say, ""I have homework,"" ""I need sleep,"" ""I
should eat,"" or ""I'm watching TV,"" OK? So a student is going to say one of those four things.
And the last thing I'm doing down here is overwriting the __str__ method.
So let's look at the code. I'm going to comment this part out, and uncomment the student, and"
Lecture9_Chunk79,"So let's look at the code. I'm going to comment this part out, and uncomment the student, and
see what we get. OK, so here, I am creating the student. I'm creating one student whose
major is CS, name is Alice, and age is 20. s2 is going to be another student-- name-- Beth,
age-- 18. And the major is going to be None, because I didn't pass in any major here. So by
default, using the default argument, it's going to be None."
Lecture9_Chunk80,"default, using the default argument, it's going to be None.
If I print s1, s2, that's going to print out these two things over here just by whatever __str__
method does. And then I'm going to get the students to speak. And if I run it multiple times,
you can see that it's going to print different things each time. So ""I need sleep,"" ""I have
homework,"" ""I need sleep,"" ""I have homework,"" yeah. So every time, it's going to print"
Lecture9_Chunk81,"homework,"" ""I need sleep,"" ""I have homework,"" yeah. So every time, it's going to print
something different. OK, questions about inheritance in this example? OK.
Last thing we're going to talk about in this class is an idea of-- or in this lecture, is the idea of--
a class variable, OK? So to illustrate this, I'm going to create yet another subclass of my
animal called a rabbit. So class variables-- so so far, we've seen-- sorry, let me back up. So so"
Lecture9_Chunk82,"animal called a rabbit. So class variables-- so so far, we've seen-- sorry, let me back up. So so
far, we've seen instance variables, right? So things like self.name, self.age, those are all
instance variables. So they're variables that are specif-- they are common across all of the
instances of the class, right? Every instance of the class has this particular variable. But the
value of the variable is going to be different between all of the different instances."
Lecture9_Chunk83,"value of the variable is going to be different between all of the different instances.
So class variables are going to be variables whose values are shared between all of the
instances in the class. So if one instance of the class modifies this class variable, then, any
other instance of the class is going to see the modified value. So it's sort of shared among all
of the different instances. So we're going to use class variables to keep track of rabbits."
Lecture9_Chunk84,"of the different instances. So we're going to use class variables to keep track of rabbits.
OK, so we're creating this class, Rabbit. tag = 1. We haven't seen something like this before.
So tag is our class variable. Class variables are typically defined inside the class definition but
outside of the __init__. So tag is going to be a class variable, and I'm initializing it to 1.
Inside the __init__, this tells us how to create a Rabbit object. So I'm going to give it self as"
Lecture9_Chunk85,"Inside the __init__, this tells us how to create a Rabbit object. So I'm going to give it self as
usual, an age, and then two parents. Don't worry about the two parents for now. Inside the
__init__-- sorry, inside the __init__-- I'm going to call the __init__ of the animal just to do less
work. Python already knows how to initialize an animal for me, so let's do that. So that's going
to set the two data attributes, name and age."
Lecture9_Chunk86,"to set the two data attributes, name and age.
I'm going to set the data attributes for parent1, parent2 for a rabbit to be whatever's passed in.
And then, this is where I'm going to use this class variable. So I'm creating this data attribute
instance variable particular to a specific instance called rid, OK? And I'm assigning this
instance variable to the class variable. And I access class variables using not self, but the
class name-- so in this case, rabbit.tag."
Lecture9_Chunk87,"class name-- so in this case, rabbit.tag.
So initially, tag is going to be 1. And then, the __init__ is going to increment the tag by 1 here,
OK? So that means that, from now on, if I create any other instances, the other instances are
going to be accessing the updated value of tag instead of being 1.
So let's do a quick drawing to show you what I mean. So let's say I have Rabbit.tag here, OK?
So initially, tag is going to be 1, OK? And then I'm going to create a new Rabbit object. So this"
Lecture9_Chunk88,"So initially, tag is going to be 1, OK? And then I'm going to create a new Rabbit object. So this
is as I'm calling the code, OK? So let's say this is a rabbit object-- oh boy, OK-- r1.
You know, I actually googled how to draw a rabbit, but that didn't help at all. OK, so r1 is going
to be a new rabbit that we create. Initially, what happens is, when I first create this new rabbit,
it's going to access the class variable, which, it's current value is 1. So when I create the rabbit"
Lecture9_Chunk89,"it's going to access the class variable, which, it's current value is 1. So when I create the rabbit
ID-- the rabbit ID, r1.rid-- this is going to get the value 1. And according to the code, after I set
the rabbit ID to whatever tag is, I'm going to increment the tag. So this is going to say, OK,
now that I've said it, I'm going to go back up here and increment the tag to be 2. OK.
So let's say I create another Rabbit object, OK? All right, there-- that's a sad rabbit, r2. The ID"
Lecture9_Chunk90,"So let's say I create another Rabbit object, OK? All right, there-- that's a sad rabbit, r2. The ID
of r2 is going to be what? Well, according to the way we create a new Rabbit object is it's
going to access whatever the value of tag is, which is a class variable. It was changed by the
previous creation of my rabbit, so now I'm going to access that, right? So the value is going to
be 2.
And according to the code, the next thing I do after I create the instance rid is I'm going to"
Lecture9_Chunk91,"be 2.
And according to the code, the next thing I do after I create the instance rid is I'm going to
increment tag. So I'm incrementing the class variable to be 3, OK? So notice that all of my
instances are accessing this shared resource, this shared variable called tag.
So as I'm creating more and more rabbits, they're all going to be incrementing the value of
tag, because it's shared among all of the instances. And so this value, this tag class variable,"
Lecture9_Chunk92,"tag, because it's shared among all of the instances. And so this value, this tag class variable,
keeps track of how many different instances of a rab-- of how many different instances of
rabbits I've created throughout my entire program, OK? So the big idea here is that class
variables are shared across all the instances. So they can all modify them. But these rids,
right, these instance variables, are only for that particular instance. So r2 can't have access to"
Lecture9_Chunk93,"right, these instance variables, are only for that particular instance. So r2 can't have access to
r1's ID value, nor could change it. But it won't change it across all of the different instances,
OK?
So that's how the __init__ method works of Rabbit, OK? So we have these tags that keep
track of how many rabbits we've created. We have a couple of getter-- we have some getters
here to get all the parents. So now let's add a somewhat more interesting function. Oh, I just"
Lecture9_Chunk94,"here to get all the parents. So now let's add a somewhat more interesting function. Oh, I just
want to mention, when I'm getting the rid, I'm actually using this cool zfill() function here, or
method, which actually pads the beginning of any number with however many zeros in order
to get to that number here. So the number 1 becomes 001 and so on. So it ensures that I
have this nice-looking ID type thing that's always three digits long."
Lecture9_Chunk95,"have this nice-looking ID type thing that's always three digits long.
So let's try to work with this Rabbit object. Let's define what happens when you add two rabbits
together, OK-- in this class, not in the real world. OK. So if I want to use the plus operator
between two rabbit instances, I have to implement this __add__ method, OK? So all I'm doing
here is I'm returning a new Rabbit object, OK? Whoops, sorry about that."
Lecture9_Chunk96,"here is I'm returning a new Rabbit object, OK? Whoops, sorry about that.
And let's recall the __init__ method of the rabbit, OK? So when I'm returning a new Rabbit
object, I'm returning a new Rabbit object that's going to have an age of 0. Self-- so the Rabbit
object I'm calling this method on is going to be the parent of the new rabbit. And other is going
to be the other parent of the new rabbit, OK?"
Lecture9_Chunk97,"to be the other parent of the new rabbit, OK?
So if we look at the code, and I run it, this part here, I'm creating three rabbits, r1, r2, and r3.
Notice this class variable is working as expected, because the IDs of each of my rabbits
increments as I create more rabbits. So we have 001, 002, 003. If I print r1, and r2, and r3--
that was these three lines over here-- the parents of r1 and r2 are None, because that's just
the default-- yes, the default arguments for creating a rabbit."
Lecture9_Chunk98,"the default-- yes, the default arguments for creating a rabbit.
To add two rabbits together, I use the plus operator between two Rabbit objects. And on the
right here, I'm testing rabbit addition. And I can print out the IDs of all my rabbits. And notice
that, when I've created this new rabbit, r4, the ID of it still kept incrementing. So now, the ID of
the fourth rabbit is 004. And then, when I get r4's parents, they are as we want them to be, so
r1 and r2."
Lecture9_Chunk99,"r1 and r2.
The other thing I want to do is to compare two rabbits. So if I want to compare two rabbits, I
want to make sure that their parents are the same. So I can compare the first parent of the
first rabbit with the first parent of the second rabbit and the second parent of the first rabbit to
the second parent of second rabbit or getting the combinations of those two. So that's what
these two Booleans are doing."
Lecture9_Chunk100,"these two Booleans are doing.
So these are going to tell me-- these are going to be Boolean values, either True or False.
And I'm going to return either they have the same parents of that type or the same parents
criss-crossed, OK? So here, notice that I'm actually comparing the IDs of the rabbits as
opposed to the Rabbit objects directly, OK? So if, instead of comparing the IDs in here, I was
comparing the parents themselves, directly, what would end up happening is this function, this"
Lecture9_Chunk101,"comparing the parents themselves, directly, what would end up happening is this function, this
method, eq(), would get called over and over again. Because here, we have parents that are
rabbits.
And at some point, the parents of the very, very first rabbits ever created by this program are
None. And so when I try to call-- when I try to call the parent one of None, that's going to give
me an error, OK, something like an attribute error where None doesn't have this parent"
Lecture9_Chunk102,"me an error, OK, something like an attribute error where None doesn't have this parent
attribute, OK? So that's why I'm comparing IDs here, OK? And the code in the lecture here
shows you some tests about whether rabbits have the same parents. And I've created new
rabbits here, r3 and r4, the addition of those two. And r5 and r6 are going to have the same
parents down here-- True-- but r4 and r6 don't, OK?"
Lecture9_Chunk103,"parents down here-- True-- but r4 and r6 don't, OK?
So just to wrap it up, object-oriented programming is the idea of creating your own collections
of data where you can organize the information in a very consistent manner. So every single
of data where you can organize the information in a very consistent manner. So every single
type of object that you create of this particular type that you create-- sorry, every object"
Lecture9_Chunk104,"type of object that you create of this particular type that you create-- sorry, every object
instance of a particular type is going to have the exact same data attributes and the exact
same methods, OK? So this really comes back to the idea of decomposition and abstraction in
programming. All right, thanks, everyone."
Lecture10_Chunk1,"MITOCW | watch?v=o9nW0uBqvEo
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit
MITOpenCourseWare@ocw.mit.edu.
PROFESSOR:
OK, folks. Welcome back. Hope you had a nice long weekend with no classes. You got caught"
Lecture10_Chunk2,"PROFESSOR:
OK, folks. Welcome back. Hope you had a nice long weekend with no classes. You got caught
up on all those problem sets that have been sneaking up on you. You enjoyed watching the
Patriots and Tom Brady come back. Oh, sorry, I'm showing my local bias.
Before we talk about today's topic, I want to take a second to set the stage. And I want you to
stop and think about what you've seen so far in this course. We're coming up on the end of the"
Lecture10_Chunk3,"stop and think about what you've seen so far in this course. We're coming up on the end of the
first section of the course. And you've already seen a lot. You've certainly learned about
fundamentals of computation. You've seen different kinds of data structures, both mutable and
immutable, so tuples and lists, dictionaries, different ways of pulling things together.
You've seen a range of algorithms from simple linear code to loops, fors and whiles. You've"
Lecture10_Chunk4,"You've seen a range of algorithms from simple linear code to loops, fors and whiles. You've
seen iterative algorithms. You've seen recursive algorithms. You've seen classes of
algorithms. Divide and conquer. Greedy algorithms. Bisection search. A range of things. And
then most recently, you start pulling things together with classes-- a way to group together
data that belongs together along with methods or procedures that are designed to manipulate
that data."
Lecture10_Chunk5,"that data.
So you've had actually a fairly good coverage already of a lot of the fundamentals of
computation. And you're starting to get geared up to be able to tackle a pretty interesting
range of problems. Today and Monday, we're going to take a little bit of a different look at
computation. Because now that you've got the tools to start building up your own personal
armamentarium of tools, we'd like to ask a couple of important questions. The primary one of"
Lecture10_Chunk6,"armamentarium of tools, we'd like to ask a couple of important questions. The primary one of
which is how efficient are my algorithms?
And by efficiency, we'll see it refers both to space and time, but primarily to time. And we'd like
to know both how fast are my algorithms going to run and how could I reason about past
performance. And that's what we're going to do with today's topics. We're going to talk about"
Lecture10_Chunk7,"performance. And that's what we're going to do with today's topics. We're going to talk about
orders of growth. We'll define what that means in a few minutes. We're going to talk about
what's called the big O notation. And we're going to begin to explore different classes of
algorithms.
Before we do that though, let's talk about why. And I want to suggest to you there are two
reasons this is important to be considering. First question is how could we reason about an"
Lecture10_Chunk8,"reasons this is important to be considering. First question is how could we reason about an
algorithm something you write in order to predict how much time is it going to need to solve a
problem of a particular size? I might be testing my code on small scale examples.
And I want to know if I'd run it on a really big one, how long is it going to take? Can I predict
that? Can I make guesses about how much time I'm going to need to solve this problem?"
Lecture10_Chunk9,"that? Can I make guesses about how much time I'm going to need to solve this problem?
Especially if it's in a real world circumstance where time is going to be crucial.
Equally important is going the other direction. We want you to begin to reason about the
algorithms you write to be able to say how do certain choices in a design of an algorithm
influence how much time it's going to take. If I choose to do this recursively, is that going to be"
Lecture10_Chunk10,"influence how much time it's going to take. If I choose to do this recursively, is that going to be
different than iteratively? If I choose to do this with a particular kind of structure in my
algorithm, what does that say about the amount of time I'm going to need?
And you're going to see there's a nice association between classes of algorithms and the
interior structure of them. And in particular, we want to ask some fundamental questions. Are"
Lecture10_Chunk11,"interior structure of them. And in particular, we want to ask some fundamental questions. Are
there fundamental limits to how much time it's going to take to solve a particular problem, no
matter what kind of algorithm I design around this? And we'll see that there are some nice
challenges about that.
So that's what we're going to do over the next two days. Before we do though, let's maybe ask
the obvious question-- why should we care? Could be on a quiz, might matter to you. Better"
Lecture10_Chunk12,"the obvious question-- why should we care? Could be on a quiz, might matter to you. Better
choice is because it actually makes a difference. And I say that because it may not be as
obvious to you as it was in an earlier generation.
So people with my gray hair or what's left of my gray hair like to tell stories. I'll make it short.
But I started programming 41 years ago-- no, sorry, 45 years ago-- on punch cards. You don't"
Lecture10_Chunk13,"But I started programming 41 years ago-- no, sorry, 45 years ago-- on punch cards. You don't
know what those are unless you've been to a museum on a machine that filled a half a room
and that took about five minutes to execute what you can do in a fraction of a second on your
phone. Right. This is to tell you're living in a great time, not independent of what's going to
happen on November 8th.
All right. We'll stay away from those topics as well, won't we? My point is yeah, I tell old stories."
Lecture10_Chunk14,"I'm an old guy. But you might argue look, computers are getting so much faster. Does it really
matter? And I want to say to you-- maybe it's obvious to you-- yes, absolutely it does. Because
in conjunction with us getting faster computers, we're increasing the sizes of the problems.
The data sets we want to analyze are getting massive.
And I'll give you an example. I just pulled this off of Google, of course. In 2014-- I don't have"
Lecture10_Chunk15,"And I'll give you an example. I just pulled this off of Google, of course. In 2014-- I don't have
more recent numbers-- Google served-- I think I have that number right-- 30 trillion pages on
the web. It's either 30 trillionaire or 30 quadrillion. I can't count that many zeros there. It
covered 100 million gigabytes of data. And I suggest to you if you want to find a piece of
information on the web, can you write a simple little search algorithm that's going to"
Lecture10_Chunk16,"information on the web, can you write a simple little search algorithm that's going to
sequentially go through all the pages and find anything in any reasonable amount of time?
Probably not. Right? It's just growing way too fast.
This, by the way, is of course, why Google makes a lot of money off of their map reduced
algorithm for searching the web, written by the way, or co-written by an MIT grad and the
parent of a current MIT student. So there's a nice hook in there, not that Google pays MIT"
Lecture10_Chunk17,"parent of a current MIT student. So there's a nice hook in there, not that Google pays MIT
royalties for that wonderful thing, by the way. All right. Bad jokes aside, searching Google-- ton
of time. Searching a genomics data set-- ton of time. The data sets are growing so fast.
You're working for the US government. You want to track terrorists using image surveillance
from around the world, growing incredibly rapidly. Pick a problem. The data sets grow so"
Lecture10_Chunk18,"from around the world, growing incredibly rapidly. Pick a problem. The data sets grow so
quickly that even if the computers speed up, you still need to think about how to come up with
efficient ways to solve those problems. So I want to suggest to you while sometimes simple
solutions are great, they are the easy ones to rate-- too write. Sorry.
At times, you need to be more sophisticated. Therefore, we want to reason about how do we"
Lecture10_Chunk19,"At times, you need to be more sophisticated. Therefore, we want to reason about how do we
measure efficiency and how do we relate algorithm design choices to the cost that's going to
be associated with it? OK. Even when we do that, we've got a choice to make. Because we
could talk about both efficiency in terms of time or in terms of space, meaning how much
storage do I have inside the computer?
And the reason that's relevant is there's actually in many cases a trade-off between those two."
Lecture10_Chunk20,"And the reason that's relevant is there's actually in many cases a trade-off between those two.
And you've actually seen an example, which you may or may not remember. You may recall
when we introduced dictionaries, I showed you a variation where you could compute Fibonacci
using the dictionary to keep track of intermediate values. And we'll see in next week that it
actually tremendously reduces the time complexity."
Lecture10_Chunk21,"actually tremendously reduces the time complexity.
That's called a trade-off, in the sense that sometimes I can pre-compute portions of the
answer, store them away, so that when I've tried to a bigger version of the answer I can just
look up those portions. So there's going to be a trade-off here. We're going to focus, for
purposes of this lecture and the next one, on time efficiency. How much time is it going to take
our algorithms to solve a problem?"
Lecture10_Chunk22,"our algorithms to solve a problem?
OK. What are the challenges in doing that before we look at the actual tools? And in fact, this
is going to lead into the tools. The first one is even if I've decided on an algorithm, there are
lots of ways to implement that. A while loop and a for loop might have slightly different
behavior. I could choose to do it with temporary variables or using direct substitution. There's"
Lecture10_Chunk23,"behavior. I could choose to do it with temporary variables or using direct substitution. There's
lots of little choices. So an algorithm could be implemented many different ways. How do I
measure the actual efficiency of the algorithm?
Second one is I might, for a given problem, have different choices of algorithm. A recursive
solution versus an iterative one. Using divide and conquer versus straightforward search."
Lecture10_Chunk24,"solution versus an iterative one. Using divide and conquer versus straightforward search.
We're going to see some examples of that. So I've got to somehow separate those pieces out.
And in particular, I'd like to separate out the choice of implementation from the choice of
algorithm. I want to measure how hard is the algorithm, not can I come up with a slightly more
efficient way of coming up with an implementation."
Lecture10_Chunk25,"efficient way of coming up with an implementation.
So here are three ways I might do it. And we're going to look at each one of them very briefly.
The obvious one is we could be scientists-- time it. Write the code, run a bunch of test case,
run a timer, use that to try and come up with a way of estimating efficiency. We'll see some
challenges with that.
Slightly more abstractly, we could count operations. We could say here are the set of"
Lecture10_Chunk26,"Slightly more abstractly, we could count operations. We could say here are the set of
fundamental operations-- mathematical operations, comparisons, setting values, retrieving
values. And simply say how many of those operations do I use in my algorithm as a function of
the size of the input? And that could be used to give us a sense of efficiency.
We're going to see both of those are flawed somewhat more in the first case than the second"
Lecture10_Chunk27,"We're going to see both of those are flawed somewhat more in the first case than the second
one. And so we're going to abstract that second one to a more abstract notion of something
we call an order of growth. And I'll come back to that in a couple of minutes. This is the one
we're going to focus on. It's one that computer scientists use. It leads to what we call
complexity classes. So order of growth or big O notation is a way of abstractly describing the"
Lecture10_Chunk28,"complexity classes. So order of growth or big O notation is a way of abstractly describing the
behavior of an algorithm, and especially the equivalences of different algorithms.
But let's look at those. Timing. Python provides a timer for you. You could import the time
But let's look at those. Timing. Python provides a timer for you. You could import the time
module. And then you can call, as you can see right down here. I might have defined a really"
Lecture10_Chunk29,"module. And then you can call, as you can see right down here. I might have defined a really
simple little function-- convert Celsius to Fahrenheit. And in particular, I could invoke the clock
method from the time module. And what that does is it gives me a number as the number of
some fractions of a second currently there.
Having done that I could call the function. And then I could call the clock again, and take the"
Lecture10_Chunk30,"Having done that I could call the function. And then I could call the clock again, and take the
difference to tell me how much time it took to execute this. It's going to be a tiny amount of
time. And then I could certainly print out some statistics. I could do that over a large number of
runs-- different sizes of the input-- and come up with a sense of how much time does it take.
Here's the problem with that. Not a bad idea. But again, my goal is to evaluate algorithms. Do"
Lecture10_Chunk31,"Here's the problem with that. Not a bad idea. But again, my goal is to evaluate algorithms. Do
different algorithms have different amounts of time associated with them? The good news is is
that if I measure running time, it will certainly vary as the algorithm changes. Just what I want
to measure. Sorry.
But one of the problems is that it will also vary as a function of the implementation. Right? If I
use a loop that's got a couple of more steps inside of it in one algorithm than another, it's"
Lecture10_Chunk32,"use a loop that's got a couple of more steps inside of it in one algorithm than another, it's
going to change the time. And I don't really care about that difference. So I'm confounding or
conflating implementation influence on time with algorithm influence on time. Not so good.
Worse, timing will depend on the computer. My Mac here is pretty old. Well, at least for
computer versions. It's about five years old. I'm sure some of you have much more recent"
Lecture10_Chunk33,"computer versions. It's about five years old. I'm sure some of you have much more recent
Macs or other kinds of machines. Your speeds may be different from mine. That's not going to
help me in trying to measure this.
And even if I could measure it on small sized problems, it doesn't necessarily predict what
happens when I go to a really large sized problems, because of issues like the time it takes to
get things out of memory and bring them back in to the computer. So what it says is that timing"
Lecture10_Chunk34,"get things out of memory and bring them back in to the computer. So what it says is that timing
does vary based on what I'd like to measure, but it varies on a lot of other factors. And it's
really not all that valuable.
OK. Got rid of the first one. Let's abstract that. By abstract, I'm going to make the following
assumption. I'm going to identify a set of primitive operations. Kind of get to say what they are,"
Lecture10_Chunk35,"assumption. I'm going to identify a set of primitive operations. Kind of get to say what they are,
but the obvious one is to say what does the machine do for me automatically. That would be
things like arithmetic or mathematical operations, multiplication, division, subtraction,
comparisons, something equal to another thing, something greater than, something less than,
assignments, set a name to a value, and retrieval from memory. I'm going to assume that all"
Lecture10_Chunk36,"assignments, set a name to a value, and retrieval from memory. I'm going to assume that all
of these operations take about the same amount of time inside my machine.
Nice thing here is then it doesn't matter which machine I'm using. I'm measuring how long
does the algorithm take by counting how many operations of this type are done inside of the
algorithm. And I'm going to use that count to come up with a number of operations executed"
Lecture10_Chunk37,"algorithm. And I'm going to use that count to come up with a number of operations executed
as a function of the size of the input. And if I'm lucky, that'll give me a sense of what's the
efficiency of the algorithm.
So this one's pretty boring. It's got three steps. Right? A multiplication, a division, and an
addition-- four, if you count the return. But if I had a little thing here that added up the integers
from 0 up to x, I've got a little loop inside here. And I could count operations."
Lecture10_Chunk38,"from 0 up to x, I've got a little loop inside here. And I could count operations.
So in this case, it's just, as I said, three operations. Here, I've got one operation. I'm doing an
assignment. And then inside here, in essence, there's one operation to set i to a value from
that iterator. Initially, it's going to be 0. And then it's going to be 1. And you get the idea.
And here, that's actually two operations. It's nice Python shorthand. But what is that operation?"
Lecture10_Chunk39,"And here, that's actually two operations. It's nice Python shorthand. But what is that operation?
It says take the value of total and the value of i, add them together-- it's one operation-- and
then set that value, or rather, set the name total to that new value. So a second operation. So
you can see in here, I've got three operations. And what else do I have?
Well, I'm going to go through this loop x times. Right? I do it for i equals 0. And therefore, i"
Lecture10_Chunk40,"Well, I'm going to go through this loop x times. Right? I do it for i equals 0. And therefore, i
equal 1, and so on. So I'm going to run through that loop x times. And if I put that together, I
get a nice little expression. 1 plus 3x. Actually, I probably cheated here. I shouldn't say
cheated. I probably should have counted the return as one more operation, so that would be 1
plus 3x plus 1, or 3x plus 2 operations."
Lecture10_Chunk41,"plus 3x plus 1, or 3x plus 2 operations.
Why should you care? It's a little closer to what I'd like. Because now I've got an expression
that tells me something about how much time is this going to take as I change the size of the
problem. If x is equal to 10, it's going to take me 32 operations. If x is equal to 100, 302
operations. If x is equal to 1,000, 3,002 operations. And if I wanted the actual time, I'd just"
Lecture10_Chunk42,"operations. If x is equal to 1,000, 3,002 operations. And if I wanted the actual time, I'd just
multiply that by whatever that constant amount of time is for each operation. I've got a good
estimate of that.
Sounds pretty good. Not quite what we want, but it's close. So if I was counting operations,
what could I say about it? First of all, it certainly depends on the algorithm. That's great.
Number of operations is going to directly relate to the algorithm I'm trying to measure, which is"
Lecture10_Chunk43,"Number of operations is going to directly relate to the algorithm I'm trying to measure, which is
what I'm after.
Unfortunately, it still depends a little bit on the implementation. Let me show you what I mean
by that by backing up for a second. Suppose I were to change this for loop to a while loop. I'll
set i equal to 0 outside of the loop. And then while i is less than x plus 1, I'll do the things inside"
Lecture10_Chunk44,"of that. That would actually add one more operation inside the loop, because I both have to
set the value of i and I have to test the value of i, as well as doing the other operations down
here.
And so rather than getting 3x plus 1, I would get 4x plus 1. Eh. As the government says, what's
the difference between three and for when you're talking about really big numbers? Problem is
in terms of counting, it does depend. And I want to get rid of that in a second, so it still"
Lecture10_Chunk45,"in terms of counting, it does depend. And I want to get rid of that in a second, so it still
depends a little bit on the implementation. I remind you, I wanted to measure impact of the
algorithm.
But the other good news is the count is independent of which computer I run on. As long as all
my computers come with the same set of basic operations, I don't care what the time of my
computer is versus yours to do those operations on measuring how much time it would take."
Lecture10_Chunk46,"computer is versus yours to do those operations on measuring how much time it would take.
And I should say, by the way, one of the reasons I want to do it is last to know is it going to
take 37.42 femtoseconds or not, but rather to say if this algorithm has a particular behavior, if I
double the size of the input, does that double the amount of time I need? Does that quadruple
the amount of time I need? Does it increase it by a factor of 10?"
Lecture10_Chunk47,"the amount of time I need? Does it increase it by a factor of 10?
And here, what matters isn't the speed of the computer. It's the number of operations. The last
one I'm not going to really worry about. But we'd have to really think about what are the
operations we want to count.
I made an assumption that the amount of time it takes to retrieve something from memory is
the same as the amount of time it takes to do a numerical computation. That may not be"
Lecture10_Chunk48,"the same as the amount of time it takes to do a numerical computation. That may not be
accurate. But this one could probably be dealt with by just agreeing on what are the common
operations and then doing the measurement. So this is closer. Excuse me.
And certainly, that count varies for different inputs. And we can use it to come up with a
relationship between the inputs and the count. And for the most part, it reflects the algorithm,"
Lecture10_Chunk49,"relationship between the inputs and the count. And for the most part, it reflects the algorithm,
not the implementation. But it's still got that last piece left there, so I need to get rid of the last
piece.
So what can we say here? Timing and counting do evaluate or reflect implementations? I don't
want that. Timing also evaluates the machines. What I want to do is just evaluate the
algorithm. And especially, I want to understand how does it scale?"
Lecture10_Chunk50,"algorithm. And especially, I want to understand how does it scale?
I'm going to say what I said a few minutes ago again. If I were to take an algorithm, and I say I
know what its complexity is, my question is if I double the size of the input, what does that say
to the speed? Because that's going to tell me something about the algorithm. I want to say
what happens when I scale it? And in particular, I want to relate that to the size of the input."
Lecture10_Chunk51,"what happens when I scale it? And in particular, I want to relate that to the size of the input.
So here's what we're going to do. We're going to introduce orders of growth. It's a wonderful
tool in computer science. And what we're going to focus on is that idea of counting operations.
But we're not going to worry about small variations, whether it's three or four steps inside of
the loop. We're going to show that that doesn't matter. And if you think about my statement of"
Lecture10_Chunk52,"the loop. We're going to show that that doesn't matter. And if you think about my statement of
does it double in terms of size or speed or not-- or I'm sorry-- time or not, whether it goes from
three to six or four to eight, it's still a doubling. So I don't care about those pieces inside.
I'm going to focus on what happens when the size of the problem gets arbitrarily large. I don't
care about counting things from 0 up to x when x is 10 or 20. What happens when it's a"
Lecture10_Chunk53,"care about counting things from 0 up to x when x is 10 or 20. What happens when it's a
million? 100 million? What's the asymptotic behavior of this? And I want to relate that time
needed against the size of the input, so I can make that comparison I suggested.
OK. So to do that, we've got to do a couple of things. We have to decide what are we going to
measure? And then we have to think about how do we count without worrying about"
Lecture10_Chunk54,"measure? And then we have to think about how do we count without worrying about
implementation details. So we're going to express efficiency in terms of size of input. And
usually, this is going to be obvious. If I've got a procedure that takes one argument that's an
integer, the size of the integer is the thing I'm going to measure things in. If I double the size of
that integer, what happens to the computation?"
Lecture10_Chunk55,"that integer, what happens to the computation?
If I'm computing something over a list, typically the length of the list is going to be the thing I'm
going to use to characterize the size of the problem. If I've got-- and we'll see this in a second-
- a function that takes more than one argument, I get to decide what's the parameter I want to
use. If I'm searching to see is this element in that list, typically, I'm going to worry about what's"
Lecture10_Chunk56,"the size of the list, not what's the size of the element. But we have to specify what is that we're
measuring. And we're going to see examples of that in just a second.
OK. So now, we start thinking about that sounds great. Certainly fun computing something
numeric. Sum of integers from 0 up to x. It's kind of obvious x is the size of my problem. How
many steps does it take? I can count that. But in some cases, the amount of time the code
takes is going to depend on the input."
Lecture10_Chunk57,"takes is going to depend on the input.
So let's take this little piece of code here. And I do hope by now, even though we flash up
code, you're already beginning to recognize what does it do. Not the least of which, by the
clever name that we chose. But this is obviously just a little function. It runs through a loop--
sorry, a for loop that takes i for each element in a list L. And it's checking to see is i equal to"
Lecture10_Chunk58,"sorry, a for loop that takes i for each element in a list L. And it's checking to see is i equal to
the element I've provided. And when it is, I'm going to return true. If I get all the way through
the loop and I didn't find it, I'm going to return false. It's just saying is e in my input list L?
How many steps is this going to take? Well, we can certainly count the number of steps in the
loop. Right? We've got a set i. We've got to compare i and potentially we've got to return. So"
Lecture10_Chunk59,"loop. Right? We've got a set i. We've got to compare i and potentially we've got to return. So
there's at most three steps inside the loop. But depends on how lucky I'm feeling. Right?
If e happens to be the first element in the list-- it goes through the loop once-- I'm done. Great.
I'm not always that lucky. If e is not in the list, then it will go through this entire loop until it gets
all the way through the elements of L before saying false. So this-- sort of a best case"
Lecture10_Chunk60,"all the way through the elements of L before saying false. So this-- sort of a best case
scenario. This is the worst case scenario.
Again, if I'm assigned and say well, let's run some trials. Let's do a bunch of examples and see
how many steps does it go through. And that would be the average case. On average, I'm
likely to look at half the elements in the list before I find it. Right? If I'm lucky, it's early on. If I'm
not so lucky, it's later on."
Lecture10_Chunk61,"not so lucky, it's later on.
Which one do I use? Well, we're going to focus on this one. Because that gives you an upper
bound on the amount of time it's going to take. What happens in the worst case scenario? We
will find at times it's valuable to look at the average case to give us a rough sense of what's
going to happen on average. But usually, when we talk about complexity, we're going to focus
on the worst case behavior."
Lecture10_Chunk62,"on the worst case behavior.
So to say it in a little bit different way, let's go back to my example. Suppose you gave it a list L
of some length. Length of L, you can call that len if you like. Then my best case would be the
minimum running type. And in this case, it will be for the first element in the list. And notice in
that case, the number of steps I take would be independent of the length of L. That's great. It"
Lecture10_Chunk63,"that case, the number of steps I take would be independent of the length of L. That's great. It
doesn't matter how long the list is. If I'm always going to find the first element, I'm done.
The average case would be the average over the number of steps I take, depending on the
length of the list. It's going to grow linearly with the length of the list. It's a good practical
measure. But the one I want to focus on will be the worst case. And here, the amount of time"
Lecture10_Chunk64,"measure. But the one I want to focus on will be the worst case. And here, the amount of time
as we're going to see in a couple of slides, is linear in the size of the problem. Meaning if I
double the length of the list in the worst case, it's going to take me twice as much time to find
that it's not there. If I increase the length in the list by a factor of 10, in the worst case, it's
going to take me 10 times as much time as it did in the earlier case to find out that the"
Lecture10_Chunk65,"going to take me 10 times as much time as it did in the earlier case to find out that the
problem's not there. And that linear relationship is what I want to capture.
So I'm going to focus on that. What's the worst case behavior? And we're about ready to start
talking about orders of growth, but here then is what orders of growth are going to provide for
me. I want to evaluate efficiency, particularly when the input is very large. What happens when"
Lecture10_Chunk66,"me. I want to evaluate efficiency, particularly when the input is very large. What happens when
I really scale this up? I want to express the growth of the program's runtime as that input
grows. Not the exact runtime, but that notion of if I doubled it, how much longer does it take?
What's the relationship between increasing the size of the input and the increase in the
amount of time it takes to solve it?
We're going to put an upper bound on that growth. And if you haven't seen this in math, it"
Lecture10_Chunk67,"We're going to put an upper bound on that growth. And if you haven't seen this in math, it
basically says I want to come up with a description that is at least as big as-- sorry-- as big as
or bigger than the actual amount of time it's going to take. And I'm going to not worry about
being precise. We're going to talk about the order of rather than exact. I don't need to know to
the femtosecond how long this is going to take, or to exactly one operation how long this is
going to take."
Lecture10_Chunk68,"going to take.
But I want to say things like this is going to grow linearly. I double the size of the input, it
doubles the amount of time. Or this is going to grow quadratically. I double the size of the
input, it's going to take four times as much time to solve it. Or if I'm really lucky, this is going to
have constant growth. No matter how I change the input, it's not going to take any more time.
To do that, we're going to look at the largest factors in the runtime. Which piece of the"
Lecture10_Chunk69,"To do that, we're going to look at the largest factors in the runtime. Which piece of the
program takes the most time? And so in orders of growth, we are going to look for as tight as
possible an upper bound on the growth as a function of the size of the input in the worst case.
Nice long definition. Almost ready to look at some examples. So here's the notation we're
going to use. It's called Big O notation. I have to admit-- and John's not here today to remind"
Lecture10_Chunk70,"going to use. It's called Big O notation. I have to admit-- and John's not here today to remind
me the history-- I think it comes because we used Omicron-- God knows why. Sounds like
something from Futurama. But we used Omicron as our symbol to define this.
I'm having such good luck with bad jokes today. You're not even wincing when I throw those
things out. But that's OK. It's called Big O notation. We're going to use it. We're going to"
Lecture10_Chunk71,"things out. But that's OK. It's called Big O notation. We're going to use it. We're going to
describe the rules of it. Is this the tradition of it? It describes the worst case, because it's often
the bottleneck we're after. And as we said, it's going to express the growth of the program
relative to the input size.
OK. Let's see how we go from counting operations to getting to orders of growth. Then we're
going to define some examples of ordered growth. And we're going to start looking at"
Lecture10_Chunk72,"going to define some examples of ordered growth. And we're going to start looking at
algorithms. Here's a piece of code you've seen before. Again, hopefully, you recognize or can
see fairly quickly what it's doing. Computing factorials the iterative way. Basically, remember n
factorial is n times n minus 1 times n minus 2 all the way down to 1. Hopefully, assuming n is a
non-negative integer.
Here, we're going to set up an internal variable called answer. And then we're just going to run"
Lecture10_Chunk73,"Here, we're going to set up an internal variable called answer. And then we're just going to run
over a loop. As long as n is bigger than 1, we're going to multiply answer by n, store it back
into answer, decrease n by 1. We'll keep doing that until we get out of the loop. And we're
going to return answer. We'll start by counting steps. And that's, by the way, just to remind you
that in fact, there are two steps here."
Lecture10_Chunk74,"that in fact, there are two steps here.
So what do I have? I've got one step up there. Set answer to one. I'm setting up n-- sorry, I'm
not setting up n. I'm going to test n. And then I'm going to do two steps here, because I got a
multiply answer by n and then set it to answer. And now similarly, we've got two steps there
because I'm subtracting 1 from n and then setting it to n.
So I've got 2 plus 4 plus the test, which is 5. I've got 1 outside here. I got 1 outside there. And"
Lecture10_Chunk75,"So I've got 2 plus 4 plus the test, which is 5. I've got 1 outside here. I got 1 outside there. And
I'm going to go through this loop n times. So I would suggest that if I count the number of
steps, it's 1 plus 5n plus 1. Sort of what we did before. 5n plus 2 is the total number of steps
that I use here.
But now, I'm interested in what's the worst case behavior? Well, in this case, it is the worst
case behavior because it doesn't have decisions anywhere in here. But I just want to know"
Lecture10_Chunk76,"case behavior because it doesn't have decisions anywhere in here. But I just want to know
what's the asymptotic complexity? And I'm going to say-- oh, sorry-- that is to say I could do
this different ways. I could have done this with two steps like that. That would have made it not
just 1 plus 5n plus 1. It would have made it 1 plus 6n plus 1 because I've got an extra step.
I put that up because I want to remind you I don't care about implementation differences. And"
Lecture10_Chunk77,"I put that up because I want to remind you I don't care about implementation differences. And
so I want to know what captures both of those behaviors. And in Big O notation, I say that's
order n. Grows linearly. So I'm going to keep doing this to you until you really do wince at me.
If I were to double the size of n, whether I use this version or that version, the amount of time
the number of steps is basically going to double."
Lecture10_Chunk78,"the number of steps is basically going to double.
Now you say, wait a minute. 5n plus 2-- if n is 10 that's 52. And if n is 20, that's 102. That's not
quite doubling it. And you're right. But remember, we really care about this in the asymptotic
case. When n gets really big, those extra little pieces don't matter. And so what we're going to
do is we're going to ignore the additive constants and we're going to ignore the multiplicative
constants when we talk about orders of growth."
Lecture10_Chunk79,"constants when we talk about orders of growth.
So what does o of n measure? Well, we're just summarizing here. We want to describe how
much time is needed to compute or how does the amount of time, rather, needed to computer
problem growth as the size of the problem itself grows. So we want an expression that counts
that asymptotic behavior. And we're going to focus as a consequence on the term that grows
most rapidly."
Lecture10_Chunk80,"most rapidly.
So here are some examples. And I know if you're following along, you can already see the
answers here. But we're going to do this to simply give you a sense of that. If I'm counting
operations and I come up with an expression that has n squared plus 2n plus 2 operations,
that expression I say is order n squared. The 2 and the 2n don't matter. And think about what
happens if you make n really big. n squared is much more dominant than the other terms. We
say that's order n squared."
Lecture10_Chunk81,"say that's order n squared.
Even this expression we say is order n squared. So in this case, for lower values of n, this term
is going to be the big one in terms of number of steps. I have no idea how I wrote such an
inefficient algorithm that it took 100,000 steps to do something. But if I had that expression for
smaller values of n, this matters a lot. This is a really big number.
But when I'm interested in the growth, then that's the term that dominates. And you see the"
Lecture10_Chunk82,"But when I'm interested in the growth, then that's the term that dominates. And you see the
idea or begin to see the idea here that when I have-- sorry, let me go back there-- when I have
expressions, if it's a polynomial expression, it's the highest order term. It's the term that
captures the complexity. Both of these are quadratic. This term is order n, because n grows
faster than log of n.
This funky looking term, even though that looks like the big number there and it is a big"
Lecture10_Chunk83,"This funky looking term, even though that looks like the big number there and it is a big
number, that expression we see is order n log n. Because again, if I plot out as how this
changes as I make n really large, this term eventually takes over as the dominant term. What
about that one? What's the big term there?
How many people think it's n to the 30th? Show of hands. How many people think it's 3 to the
n? Show of hands. Thank you. You're following along. You're also paying attention. How many"
Lecture10_Chunk84,"n? Show of hands. Thank you. You're following along. You're also paying attention. How many
people think I should stop asking questions? No show of hands. All right. But you're right.
Exponentials are much worse than powers.
Even something like this-- again, it's going to take a big value of n before it gets there, but it
does get there. And that, by the way, is important, because we're going to see later on in the"
Lecture10_Chunk85,"does get there. And that, by the way, is important, because we're going to see later on in the
term that there are some problems where it's believed that all of the solutions are exponential.
And that's a pain, because it says it's always going to be expensive to compute. So that's how
we're going to reason about these things.
And to see it visually, here are the differences between those different classes. Something"
Lecture10_Chunk86,"And to see it visually, here are the differences between those different classes. Something
that's constant-- the amount of time doesn't change as I change the size of the input.
Something that linear grows as a straight line, as you would expect. Nice behavior. Quadratic
starts to grow more quickly. The log is always better than linear because it slows down as we
increase the size. n log n or log linear is a funky term, but we're going to see it's a very"
Lecture10_Chunk87,"increase the size. n log n or log linear is a funky term, but we're going to see it's a very
common complexity for really valuable algorithms in computer science. And it has a nice
behavior, sort of between the linear and the quadratic. And exponential blows up.
Just to remind you of that-- well, sorry-- let me show you how we're going to do the reasoning
about this. So here's how we're going to reason about it. We've already seen some code"
Lecture10_Chunk88,"about this. So here's how we're going to reason about it. We've already seen some code
where I started working through this process of counting operations. Here are the tools I want
you to use. Given a piece of code, you're going to reason about each chunk of code
separately. If you've got sequential pieces of code, then the rules are called the law of addition
for order of growth is that the order of growth of the combination is the combination of the"
Lecture10_Chunk89,"for order of growth is that the order of growth of the combination is the combination of the
order of the growth. Say that quickly 10 times.
But let's look at an example of that. Here are two loops. You've already seen examples of how
to reason about those loops. For this one, it's linear in the size of n. I'm going to go through
the loop n times doing a constant amount of things each time around. But what I just showed,"
Lecture10_Chunk90,"the loop n times doing a constant amount of things each time around. But what I just showed,
that's order n. This one-- again, I'm doing just a constant number of things inside the loop--
but notice, that it's n squared. So that's order n squared. n times n.
The combination is I have to do this work and then that work. So I write that as saying that is
The combination is I have to do this work and then that work. So I write that as saying that is"
Lecture10_Chunk91,"The combination is I have to do this work and then that work. So I write that as saying that is
order of n plus order of n squared. But by this up here, that is the same as saying what's the
order of growth of n plus n squared. Oh yeah. We just saw that. Says it's n squared. So
addition or the law of addition let's be reasonable about the fact that this will be an order n
squared algorithm.
Second one I'm going to use is called the law of multiplication. And this says when I have"
Lecture10_Chunk92,"Second one I'm going to use is called the law of multiplication. And this says when I have
nested statements or nested loops, I need to reason about those. And in that case, what I
want to argue-- or not argue-- state is that the order of growth here is a multiplication. That is,
when I have nested things, I figure out what's the order of growth of the inner part, what's the
order growth of the outer part, and I'm going to multiply-- bleh, try again-- I'm going to multiply"
Lecture10_Chunk93,"order growth of the outer part, and I'm going to multiply-- bleh, try again-- I'm going to multiply
together those orders of growth, get the overall order of growth. If you think about it, it makes
sense.
Look at my little example here. It's a trivial little example. But I'm looping for i from 0 up to n.
For every value of i, I'm looping for j from 0 up to n. And then I'm printing out A. I'm the Fonz.
I'm saying heyyy a lot. Oh, come on. At least throw something, I mean, when it's that bad."
Lecture10_Chunk94,"I'm saying heyyy a lot. Oh, come on. At least throw something, I mean, when it's that bad.
Right? Want to make sure you're still awake. OK. You get the idea.
But what I want to show you here is notice the order of growth. That's order n. Right? I'm
doing that n times. But I'm doing that for each value of i. The outer piece here loops also n
times. For each value of i, I'm doing order n things. So I'm doing order of n times order of n"
Lecture10_Chunk95,"times. For each value of i, I'm doing order n things. So I'm doing order of n times order of n
steps. And by that law, that is the same order of n times n or n squared. So this is a quadratic
expression.
You're going to see that a lot. Nested loops typically have that kind of behavior. Not always,
but typically have that kind of behavior. So what you're going to see is there's a set of
complexity classes. And we're about to start filling these in."
Lecture10_Chunk96,"complexity classes. And we're about to start filling these in.
Order one is constant. Says amount of time it takes doesn't depend on the size of the
problem. These are really rare that you get. They tend to be trivial pieces of code, but they're
valuable. Log n reflects logarithmic runtime. You can sort of read the rest of them. These are
the kinds of things that we're going to deal with. We are going to see examples here, here,"
Lecture10_Chunk97,"the kinds of things that we're going to deal with. We are going to see examples here, here,
and here. And later on, we're going to come back and see these, which are really nice
examples to have.
Just to remind you why these orders of growth matter-- sorry, that's just reminding you what
they look like. We've already done that. Here is the difference between constant log, linear, log
linear squared, and exponential. When n is equal to 10, 100, 1,000 or a million. I know you"
Lecture10_Chunk98,"linear squared, and exponential. When n is equal to 10, 100, 1,000 or a million. I know you
know this, but I want to drive home the difference. Something that's constant is wonderful, no
matter how big the problem is. Takes the same amount of time.
Something that is log is pretty nice. Increase the size of the problem by 10, it increases by a
factor of 2. From another 10, it only increases by a factor of another 50%. It only increases a"
Lecture10_Chunk99,"factor of 2. From another 10, it only increases by a factor of another 50%. It only increases a
little bit. That's a gorgeous kind of problem to have. Linear-- not so bad. I go from 10 to 100 to
1,000 to a million.
You can see log linear is not bad either. Right? A factor of 10 increase here is only a factor of
20 increase there. A factor of 10 increase there is only a factor of 30 increase there. So log"
Lecture10_Chunk100,"20 increase there. A factor of 10 increase there is only a factor of 30 increase there. So log
linear doesn't grow that badly. But look at the difference between n squared and 2 to the n. I
actually did think of printing this out. By the way, Python will compute this. But it was taken
pages and pages and pages. I didn't want to do it. You get the point. Exponential-- always
much worse. Always much worse than a quadratic or a power expression. And you really see
the difference here."
Lecture10_Chunk101,"the difference here.
All right. The reason I put this up is as you design algorithms, your goal is to be as high up in
this listing as you can. The closer you are to the top of this list, the better off you are. If you
have a solution that's down here, bring a sleeping bag and some coffee. You're going to be
there for a while. Right? You really want to try and avoid that if you can.
So now what we want to do, both for the rest of today in the last 15 minutes and then next"
Lecture10_Chunk102,"So now what we want to do, both for the rest of today in the last 15 minutes and then next
week, is start identifying common algorithms and what is their complexity. As I said to you way
back at the beginning of this lecture, which I'm sure you remember, it's not just to be able to
identify the complexity. I want you to see how choices algorithm design are going to lead to
particular kinds of consequences in terms of what this is going to cost you. That's your goal
here."
Lecture10_Chunk103,"particular kinds of consequences in terms of what this is going to cost you. That's your goal
here.
All right. We've already seen some examples. I'm going to do one more here. But simple
iterative loop algorithms are typically linear. Here's another version of searching. Imagine I'll
have an unsorted list. Arbitrary order. Here's another way of doing the linear search. Looks a
little bit faster."
Lecture10_Chunk104,"little bit faster.
I'm going to set a flag initially to false. And then I'm going to loop for i from 0 up to the length of
L. I'm going to use that to index into the list, pull out each element of the list in turn, and check
to see is it the thing I'm looking for. As soon as I find it, I'm going to send-- sorry-- set the flag
to true. OK? So that when I return out of the loop, I can just return found. And if I found it to be"
Lecture10_Chunk105,"to true. OK? So that when I return out of the loop, I can just return found. And if I found it to be
true, if I never found it, found will still be false and I'll return it.
We could count the operations here, but you've already seen examples of doing that. This is
linear, because I'm looping n times if n is the length of the list over there. And the number of
things I do inside the loop is constant. Now, you might say, wait a minute. This is really brain"
Lecture10_Chunk106,"things I do inside the loop is constant. Now, you might say, wait a minute. This is really brain
damaged, or if you're being more politically correct, computationally challenged. OK? In the
sense of once I've found it, why bother looking at the rest of the list?
So in fact, I could just return true right here. Does that change the order of growth of this
algorithm? No. Changes the average time. I'm going to stop faster. But remember the order of"
Lecture10_Chunk107,"algorithm? No. Changes the average time. I'm going to stop faster. But remember the order of
growth captures what's the worst case behavior. And the worst case behavior is the elements
not in the list I got to look at everything. So this will be an example of a linear algorithm. And
you can see, I'm looping length of L times over the loop inside of there. It's taking the order
one to test it. So it's order n."
Lecture10_Chunk108,"one to test it. So it's order n.
And if I were to actually count it, there's the expression. It's 1 plus 4n plus 1, which is 4n plus
2, which by my rule says I don't care about the additive constant. I only care about the
dominant term. And I don't care about that multiplicative constant. It's order n. An example of a
template you're going to see a lot.
Now, order n where n is the length of the list and I need to specify that. That's the thing I'm"
Lecture10_Chunk109,"Now, order n where n is the length of the list and I need to specify that. That's the thing I'm
after. If you think about it, I cheated. Sorry-- I never cheat. I'm tenure. I never cheat. I just
mislead you badly. Not a chance. How do I know that accessing an element of the list takes
constant time? I made an assumption about that. And this is a reasonable thing to ask about--
both what am I assuming about the constant operations and how do I know that's actually
true?"
Lecture10_Chunk110,"both what am I assuming about the constant operations and how do I know that's actually
true?
Well, it gives me a chance to point out something that Python does very effectively. Not all
languages do. But think about a list. Suppose I've got a list that's all integers. I'm going to need
some amount of memory to represent each integer. So if a byte is 8 bits, I might reserve 4
bytes or 32 bits to cover any reasonable sized integer. When I represent a list, I could simply"
Lecture10_Chunk111,"bytes or 32 bits to cover any reasonable sized integer. When I represent a list, I could simply
have each of them in turn. So what do I need to know?
I'm going to allocate out a particular length-- say 4 bytes, 32 bits, 32 sequential elements of
memory to represent each integer. And then I just need to know where's the first part of the
memory to represent each integer. And then I just need to know where's the first part of the"
Lecture10_Chunk112,"memory to represent each integer. And then I just need to know where's the first part of the
list, what's the address and memory of the first part of the list. And to get to the i-th element, I
take that base plus 4 bytes times i. And I can go straight to this point without having to walk
down the list. That's nice. OK? It says, in fact, I can get to any element of memory-- I'm sorry--
any element of the list in constant time."
Lecture10_Chunk113,"any element of the list in constant time.
OK. Now, what if the things I'm representing aren't integers? They're arbitrary things and they
take up a big chunk of space. Well, if the list is heterogeneous, we use a nice technique called
indirection. And that simply says we, again, have a list. We know the address of this point. We
know the address there for the i-th element of this list.
But inside of here, we don't store the actual value. We store a pointer to where it is in memory."
Lecture10_Chunk114,"But inside of here, we don't store the actual value. We store a pointer to where it is in memory.
Just what these things are indicating. So they can be arbitrary size. But again, I can get to any
element in constant time, which is exactly what I want. So that's great.
OK. Now, suppose I tell you that the list is sorted. It's in increasing order. I can be more clever
about my algorithm. Because now, as I loop through it, I can say if it's the thing I'm looking for,"
Lecture10_Chunk115,"about my algorithm. Because now, as I loop through it, I can say if it's the thing I'm looking for,
just return true. If the element of the list is bigger than the thing I'm looking for, I'm done. I
don't need to look at the rest of the list, because I know it can't be there because it's ordered
or sorted. I can just return false. If I get all the way through the loop, I can return false.
So I only have to look until I get to a point where the thing in the list is bigger than what I'm"
Lecture10_Chunk116,"So I only have to look until I get to a point where the thing in the list is bigger than what I'm
looking for. It's the order of growth here. Again, the average time behavior will be faster. But
the order of growth is I've got to do order of length of the list to go through the loop, order of
one to do the test, and in the worst case, again, I still have to go through the entire list. So the
order of growth here is the same. It is, again, linear in the length of the list, even though the"
Lecture10_Chunk117,"order of growth here is the same. It is, again, linear in the length of the list, even though the
runtime will be different depending whether it's sorted or not.
I want you to hold on to that idea, because we're going to come back to the sorted list next
week to see that there actually are much more efficient ways to use the fact that a list is sorted
to do the search. But both of these versions same order growth, order n. OK. So lurching"
Lecture10_Chunk118,"to do the search. But both of these versions same order growth, order n. OK. So lurching
through a list-- right, sorry-- searching through a list in sequence is linear because of that loop.
There are other things that have a similar flavor. And I'm going to do these quickly to get to the
last example.
Imagine I give you a string of characters that are all soon to be composed of decimal digits. I
just want to add them all up. This is also linear, because there's the loop. I'm going to loop"
Lecture10_Chunk119,"just want to add them all up. This is also linear, because there's the loop. I'm going to loop
over the characters in the string. I'm going to cast them into integers, add them in, and return
the value. This is linear in the length of the input s. Notice the pattern. That loop-- that in-
iterative loop-- it's got that linear behavior, because inside of the loop constant number of
things that I'm executing."
Lecture10_Chunk120,"things that I'm executing.
We already looked at fact iter. Same idea. There's the loop I'm going to do that n times inside
the loop a constant amount of things. So looping around it is order n. There's the actual
expression. But again, the pattern I want you to see here is that this is order n. OK.
Last example for today. I know you're all secretly looking at your watches. Standard loops,
typically linear. What about nested loops? What about loops that have loops inside of them?"
Lecture10_Chunk121,"typically linear. What about nested loops? What about loops that have loops inside of them?
How long do they take? I want to show you a couple of examples. And mostly, I want to show
you how to reason about them. Suppose I gave you two lists composed of integers, and I want
to know is the first list a subset of the second list. Codes in the handbook, by the way, if you
want to go run it.
But basically, the simple idea would be I'm going to loop over every element in the first list."
Lecture10_Chunk122,"But basically, the simple idea would be I'm going to loop over every element in the first list.
And for each one of those, I want to say is it in the second list? So I'll use the same kind of
trick. I'll set up a flag that's initially false. And then I'm going to loop over everything in the
second list. And if that thing is equal to the thing I'm looking for, I'll set match to true and break
out of the loop-- the inner loop. If I get all the way through the second list and I haven't found"
Lecture10_Chunk123,"out of the loop-- the inner loop. If I get all the way through the second list and I haven't found
the thing I'm looking for, when I break out or come out of this loop, matched in that case, will
still be false and all return false.
But if up here, I found something that matched, match would be true. I break out of it. It's not
false. Therefore, a return true. I want you look at the code. You should be able to look at this"
Lecture10_Chunk124,"false. Therefore, a return true. I want you look at the code. You should be able to look at this
and realize what it's doing. For each element in the first list, I walk through the second list to
say is that element there. And if it is, I return true. If that's true for all of the elements in the first
list, I return true overall.
OK. Order of growth. Outer loop-- this loop I'm going to execute the length of L1 times. Right?"
Lecture10_Chunk125,"OK. Order of growth. Outer loop-- this loop I'm going to execute the length of L1 times. Right?
I've got to walk down that first list. If I call that n, it's going to take that n times over the outer
loop. But what about n here? All of the earlier examples, we had a constant number of
operations inside of the loop. Here, we don't. We've got another loop that's looping over in
principle all the elements of the second list."
Lecture10_Chunk126,"principle all the elements of the second list.
So in each iteration is going to execute the inner loop up to length of L2 times, where inside of
this inner loop there is a constant number of operations. Ah, nice. That's the multiplicative law
of orders of growth. It says if this is order length L1. And we're going to do that then order
length of L2 times, the order of growth is a product. And the most common or the worst case"
Lecture10_Chunk127,"length of L2 times, the order of growth is a product. And the most common or the worst case
behavior is going to be when the lists are of the same length and none of the elements of L1
are in L2. And in that case, we're going to get something that's order n squared quadratic,
where n is the length of the list in terms of number of operations.
I don't really care about subsets. I've got one more example. We could similarly do"
Lecture10_Chunk128,"I don't really care about subsets. I've got one more example. We could similarly do
intersection. If I wanted to say what is the intersection of two lists? What elements are on both
list 1 and list 2? Same basic idea. Here, I've got a pair of nested loops. I'm looping over
everything in L1. For that, I'm looping over everything in L2. And if they are the same, I'm
going to put that into a temporary variable."
Lecture10_Chunk129,"going to put that into a temporary variable.
Once I've done that, I need to clean things up. So I'm going to write another loop that sets up
an internal variable and then runs through everything in the list I accumulated, making sure
that it's not already there. And as long as it isn't, I'm going to put it in the result and return it. I
did it quickly. You can look through it. You'll see it does the right thing."
Lecture10_Chunk130,"did it quickly. You can look through it. You'll see it does the right thing.
What I want it to see is what's the order of growth. I need to look at this piece. Then I need to
look at that piece. This piece-- well, it's order length L1 to do the outer loop. For each version
of e1, I've got to do order of length L2 things inside to accumulate them. So that's quadratic.
What about the second loop? Well, this one is a little more subtle. I'm only looping over temp,"
Lecture10_Chunk131,"What about the second loop? Well, this one is a little more subtle. I'm only looping over temp,
which is at most going to be length L1 long. But I'm checking to see is that element in a list?
And it depends on the implementation. But typically, that's going to take up to the length of the
list to do it. I got to look to see is it there or not. And so that inner loop if we assume the lists
are the same size is also going to take potentially up to length L1 steps. And so this is, again,"
Lecture10_Chunk132,"are the same size is also going to take potentially up to length L1 steps. And so this is, again,
quadratic. It's actually two quadratics-- one for the first nested loop, one for the second one,
because there's an implicit second loop right there. But overall, it's quadratic.
So what you see in general-- this is a really dumb way to compute n squared. When you have
nested loops, typically, it's going to be quadratic behavior. And so what we've done then is"
Lecture10_Chunk133,"nested loops, typically, it's going to be quadratic behavior. And so what we've done then is
we've started to build up examples. We've now seen simple looping mechanisms, simple
iterative mechanisms, nested loops. They tend to naturally give rise to linear and quadratic
complexity. And next time, we're going to start looking at more interesting classes. And we'll
see you next time."
Lecture11_Chunk1,"MITOCW | watch?v=7lQXYl_L28w
The following content is provided under a Creative Commons license. Your support will help
MIT OpenCourseWare continue to offer high-quality educational resources for free. To make a
donation or view additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
ERIC GRIMSON:
Last time, we started talking about complexity. And I want to quickly remind you of what we're"
Lecture11_Chunk2,"Last time, we started talking about complexity. And I want to quickly remind you of what we're
doing, because we're going to talk some more about that today. And when I say ""complexity,""
it was the question of, can we estimate the amount of resources-- typically time-- that we're
going to need to get an algorithm to solve a problem of a particular size? And we talked about
that both in terms of estimating, how much time is it going to take and using it to go the other"
Lecture11_Chunk3,"that both in terms of estimating, how much time is it going to take and using it to go the other
direction and think about how design choices in an algorithm have implications for the cost
that's going to be associated with that.
So we introduced the idea of what we call big O notation, orders of growth, a way of
measuring complexity. And we started talking about different classes of algorithms. So today,"
Lecture11_Chunk4,"measuring complexity. And we started talking about different classes of algorithms. So today,
I'm going to quickly recap those basic ideas. And what we're going to do is we're going to see
examples of standard classes of algorithms with the idea that you're going to want to begin to
recognize when an algorithm is in that class.
So very quick recap-- I've already said part of this. We want to have a mechanism, a method"
Lecture11_Chunk5,"So very quick recap-- I've already said part of this. We want to have a mechanism, a method
for being able to estimate or reason about, how much time do we think an algorithm's going to
take to solve a problem of a particular size. And especially as we increase the size of the input
to the algorithm, what does that do in terms of the increase in the amount of time that we
need?
Some ways, we don't care about exact versions. In a second, we're going to see the definition"
Lecture11_Chunk6,"need?
Some ways, we don't care about exact versions. In a second, we're going to see the definition
of this. But what we care about is that notion of, how does it grow as we increase the problem
size. And what we're going to focus in going, if you like, in the forward direction-- as I said, a
lot of the interest is actually thinking about what you might think of as the backwards or
reverse direction. How does a choice in algorithm design impact efficiency of the algorithm?"
Lecture11_Chunk7,"reverse direction. How does a choice in algorithm design impact efficiency of the algorithm?
And really, what we want you to do is to begin to recognize standard patterns, that, if you
make a particular choice, this fits in a class of algorithms you've seen before. And I know, in
essence, how much time-- what the cost is going to be as I do that.
All right, so just to recap, as it says on the top, we talked about orders of growth. And the idea"
Lecture11_Chunk8,"All right, so just to recap, as it says on the top, we talked about orders of growth. And the idea
is, we want to be able to evaluate a program's efficiency when the input is very big. We talked
about timing things just with a timer. We suggested that, unfortunately, conflates the algorithm
with the implementation with the particular machine. We want to get rid of those latter two and
just focus on the algorithm. So we're going to talk about counting operations, but in a very"
Lecture11_Chunk9,"just focus on the algorithm. So we're going to talk about counting operations, but in a very
general sense. So we're going to express what we call the growth of the program's runtime as
the input size grows very large.
And because we're only interested not in the exact number, but in, if you like, the growth of
that, we're going to focus on putting an upper bound on the growth, an expression that grows"
Lecture11_Chunk10,"that, we're going to focus on putting an upper bound on the growth, an expression that grows
at least as fast as what the cost of the algorithm is. Now, you could just cheat and pick a really
big upper bound. That doesn't help us very much. So in general, we're going to try and use as
tight an upper bound as we can. What's the class of algorithm it falls in?
But as we've seen before, we care about the order of growth, not being exact. So if something"
Lecture11_Chunk11,"But as we've seen before, we care about the order of growth, not being exact. So if something
grows as 2 to the n plus 5n, I don't care about the 5n. Because when n gets big, that 2 to the n
is the really big factor. And therefore we're going to look at the largest factors when we think
about that.
We've seen some examples. We're going to do a bunch more examples today to fill those in.
One of the things that we want to now do is say, with that idea in mind, there are classes of"
Lecture11_Chunk12,"One of the things that we want to now do is say, with that idea in mind, there are classes of
complexity of algorithms. So in some sense, the best ones are way up here, O of 1, order 1,
constant. It says cost doesn't change as I change the size of the input. That's great. It's always
going to be the same cost.
Order log n says the cost grows logarithmically with the size of the input. It's a slow growth,
and I'm going to remind you of that in a second. We saw lots of examples of linear running"
Lecture11_Chunk13,"and I'm going to remind you of that in a second. We saw lots of examples of linear running
time-- we're going to see a few more today-- what we call log-linear, polynomial, and
exponential.
And the thing I want to remind you is that, ideally-- whoops, sorry-- we'd like our algorithms to
be as close to the top of this categorization as we can. This is actually described in increasing
order of complexity. Something that takes the same amount of time no matter how big the"
Lecture11_Chunk14,"order of complexity. Something that takes the same amount of time no matter how big the
input is, unless that amount of time is a couple of centuries, seems like a really good algorithm
to have. Something that grows linearly is not bad. Something that grows, as we've seen down
here, exponentially tends to say, this is going to be painful.
And in fact, you can see that graphically. I'll just remind you here. Something that's constant"
Lecture11_Chunk15,"And in fact, you can see that graphically. I'll just remind you here. Something that's constant
says, if I draw out the amount of time it takes as a function of the size of the input, it doesn't
change. Logarithmic glows-- gah, sorry-- grows very slowly. Linear will grow, obviously, in a
linear way.
And I actually misspoke last time. I know it's rare for a professor to ever admit they misspeak,
but I did. Because I said linear is, if you double the size of the input, it's going to double the"
Lecture11_Chunk16,"but I did. Because I said linear is, if you double the size of the input, it's going to double the
amount of time it takes. Actually, that's an incorrect statement. Really, what I should have said
was, the increment-- if I go from, say, 10 to 100, the increase in time-- is going to be the same
as the increment if I go from 100 to 1,000. Might be more than double depending on what the
constant is. But that growth is linear."
Lecture11_Chunk17,"constant is. But that growth is linear.
If you want to think of it, take the derivative of time with respect to input size. It's just going to
be a constant. It's not going to change within. And of course, when we get down to here,
things like exponential, it grows really fast.
And just as a last recap, again, I want to be towards the top of that. There was my little chart
just showing you things that grow constant, log, linear, log-linear, quadratic, and exponential. If"
Lecture11_Chunk18,"just showing you things that grow constant, log, linear, log-linear, quadratic, and exponential. If
I go from n of 10, to 100, to 1,000, to a million, you see why I want to be at the top of that
chart.
Something up here that grows logarithmically, the amount of time grows very slowly as I
increase the input. Down here, well, like it says, good luck. It's going to grow up really quickly
as I move up in that scale. I want to be at the top of this chart if I can."
Lecture11_Chunk19,"as I move up in that scale. I want to be at the top of this chart if I can.
OK, with that in mind, when I'm going to do today is show you examples filling in most of this
chart. We've already seen some examples. We've seen examples of linear. We've seen
examples of quadratic. I'm going to just remind you of those. What I want to do is show you
how you can begin to recognize a choice of an algorithm in terms of where it lies."
Lecture11_Chunk20,"how you can begin to recognize a choice of an algorithm in terms of where it lies.
So algorithms that are constant complexity, they're kind of boring. They tend to be pretty
simple. Because this says, this code is going to run in, basically, the same amount of time
independent of the size of the input. Now, notice the bottom thing here. It doesn't say you
can't-- blah, try again. It doesn't say you couldn't have a loop or a recursive call. You could, it's"
Lecture11_Chunk21,"just that that loop cannot depend on the size of the input.
So there aren't many interesting algorithms here. We're going to see pieces of code that fit
into this when we do our analysis. But something that's constant in complexity says,
independent of the size of the input.
All right, a little more interesting-- not a little, a lot more interesting-- are algorithms that are
logarithmic in their complexity. So they're going to grow with the logarithm of the size of the"
Lecture11_Chunk22,"logarithmic in their complexity. So they're going to grow with the logarithm of the size of the
input. You saw an example much earlier in the term when Ana showed you bisection search. It
was searching for a number with a particular property.
I want to show you another example, both to let you recognize the form of the algorithm, but
especially, to show you how we can reason about the growth. And that's another trick called"
Lecture11_Chunk23,"especially, to show you how we can reason about the growth. And that's another trick called
binary search or, again, it's a version of bisection search. Suppose I give you a list, a list of
numbers, integers. And I want to know if a particular element is in that list. We saw, last time,
you could just walk down the list, just iterate through the entire list looking to see if it's there. In
the worst case, which is what we worry about, it's going to be linear. You're going to have to"
Lecture11_Chunk24,"the worst case, which is what we worry about, it's going to be linear. You're going to have to
look at every element in the list till you get to the end. So complexity was linear in that case.
And then we said, suppose we know that the list is sorted. It's ordered from smallest to largest.
And we saw, a simple algorithm says, again, walk down the list checking to see if it's there. But
when you get to an element that's bigger than the thing you're looking at, you can just stop."
Lecture11_Chunk25,"when you get to an element that's bigger than the thing you're looking at, you can just stop.
There's no reason to look at the rest of the list. They've all got to be bigger than the thing
you're searching for.
Practically, in the average case, that's going to be faster than just looking at an unsorted list.
But the complexity is still linear. Because in the worst case, I've got to go all the way through"
Lecture11_Chunk26,"But the complexity is still linear. Because in the worst case, I've got to go all the way through
the list before I deduce that the thing is not there. OK, so even sequential search in an ordered
list is still linear. Can we do better? And the answer is, sure.
So here's how we do better. I'm going to take that list. I'm going to assume it's sorted. And I'm
going to pick an index that divides the list in half, just pick the midpoint in the list. And I'm going"
Lecture11_Chunk27,"to check that value. I'm going to ask, is the element in the list at that point the thing I'm looking
for? If it is, great, I'm done.
If I'm not that lucky, I'm then going to ask, is it larger or smaller than the thing I'm looking for?
And based on that, I'm either going to search the front half or the back half of the list. Ooh,
that's nice, OK? Because if you think about it, in something that was just a linear algorithm, at"
Lecture11_Chunk28,"that's nice, OK? Because if you think about it, in something that was just a linear algorithm, at
each step, I reduced the size the problem by 1. I went from a problem of size n to a problem of
size n minus 1 to a problem of size n minus 2.
Here, I'm taking a problem of size n. I'm reducing it to n/2 in one step, because I can throw
half the list away. So this is a version of divide and conquer, things we've seen before. I'm"
Lecture11_Chunk29,"half the list away. So this is a version of divide and conquer, things we've seen before. I'm
breaking it down into smaller versions of the problem. So let's look at that. And then, let's write
some code. And then, let's analyze it.
So suppose I have a list of size n, all right? There are n elements in there. I'm going to look at
the middle one, say, is it the thing I'm looking for. If it's not, is it bigger than or less than the"
Lecture11_Chunk30,"thing I'm looking for? And in this case, let's assume that, in fact, the thing I'm looking for is
smaller than that element. Great. I'm going to throw away half the list. Now I only have to look
at the lower half of the list.
I'll do the same thing. I'll look at the element in the middle here. And I'll say, is it the thing I'm
looking for? If not, is it bigger than or smaller than the thing I'm looking for? OK, and I'm down"
Lecture11_Chunk31,"looking for? If not, is it bigger than or smaller than the thing I'm looking for? OK, and I'm down
to n/2 elements. And after I do that, I throw away half the list again. In this case, I'm assuming
that the thing I'm looking for is bigger than that middle point. Until I find it, at each step, I'm
looking at the middle element. And I'm either throwing away the left half or the right half of that
list.
So after i steps, I'm down to a list of size n over 2 to the i. Now, what's the worst case? The"
Lecture11_Chunk32,"So after i steps, I'm down to a list of size n over 2 to the i. Now, what's the worst case? The
worst case is the element's not in the list. I'm going to have to keep doing this until I get down
to just a list of one element. And at that point, if it's not the thing I'm looking for, I know I'm
done, and I can stop.
Different pattern-- notice how I'm cutting down the size of the problem by 2. So I can ask,
before we look at the code, what's the complexity of this? How many steps do I have to go"
Lecture11_Chunk33,"before we look at the code, what's the complexity of this? How many steps do I have to go
through in the worst case? And I know I'm going to be done looking at the list when n over 2 to
the i is equal to 1, meaning there's only one element left that I'm still looking at. And I can
solve that. It says I'm going to have to take, at most, i equal to log n steps, all right? So
logarithmically, I'm cutting this down."
Lecture11_Chunk34,"logarithmically, I'm cutting this down.
And so the complexity of the recursion-- we haven't talked about the code yet, but in terms of
the number of steps I have to do in the worst case-- is just logarithmic in the length of the list.
That's nice. It's a lot better than looking at everything inside the list. And in fact, you can see it,
right? I don't look at everything inside the list here. I'm throwing half the things away at a time."
Lecture11_Chunk35,"right? I don't look at everything inside the list here. I'm throwing half the things away at a time.
OK, so let's look at some code to do that. Bisection search-- I'm going to give it a list of
numbers. I'm going to give it something I'm looking for. We can walk through this code.
Hopefully it's something that you're going to be able to recognize pretty clearly.
It says if the list is empty, there's nothing there, the thing I'm looking for can't be there, I return"
Lecture11_Chunk36,"False. If there's exactly one element in the list, then I just check it. If that thing's the thing I'm
looking for, return True. Otherwise, return False. So I'm just going to return the value there.
Otherwise, find the midpoint-- notice the integer division here-- find the midpoint in that list and
check it. In particular, say, if the thing at the midpoint is bigger than the thing I'm looking for,"
Lecture11_Chunk37,"check it. In particular, say, if the thing at the midpoint is bigger than the thing I'm looking for,
then I'm going to return a recursive call to this function only looking at the first half of the list.
I'm just slicing into it. Otherwise, I'll do the same thing on the second half of the list.
Nice, this is implementing exactly what I said. We could actually try it. I'll do that in a second if I
remember. But let's think about complexity here. That's constant, right? Doesn't depend on"
Lecture11_Chunk38,"remember. But let's think about complexity here. That's constant, right? Doesn't depend on
the size of the list. That's constant, doesn't depend on the size of the list. That's consonant.
Sounds good. And what about that?
Well, it looks like it should be constant, right, other than the number of times I have to go
through there. Remember, I know I'm going to have order log n recursive calls. I'm looking at"
Lecture11_Chunk39,"through there. Remember, I know I'm going to have order log n recursive calls. I'm looking at
what's the cost to set it up. It looks like it should be constant. So does that. But I'm going to
claim it's not. Anybody see why it's not? You can look at the slides you've already printed out.
Right there-- I'm actually copying the list, all right? When I slice into the list like that, it makes a
copy of the list. Oh, crud. I was about to say something different, but I won't, because this is"
Lecture11_Chunk40,"copy of the list. Oh, crud. I was about to say something different, but I won't, because this is
going to cost me a little bit as I think about the work. So let's look at that a little more carefully.
I've got order log n search calls. We just deduced that. I've just repeated it here, right? On
each call, I'm reducing the size of the list in half. So it goes from n, to n/2, to n/4, to n/8, to
n/16. I'll be done, in the worst case, when I get down to having only a list of size 1. That takes"
Lecture11_Chunk41,"n/16. I'll be done, in the worst case, when I get down to having only a list of size 1. That takes
a log n steps, because n over 2 to the log n is n/n, which is 1.
But to set up the search for each cell, I've got to copy the list. And the list starts out n long, so
in principle, I've got order n work to do to set up the recursive call. And so by the things we
saw last time, I got order log n for the number of recursive calls times order n work inside of"
Lecture11_Chunk42,"saw last time, I got order log n for the number of recursive calls times order n work inside of
each call. And that's order n log n. So it's not what I wanted.
Now, if you're thinking about this carefully, you'll realize, on each step, I'm not actually copying
the whole list. I'm copying half the list, and then, a quarter of the list, and then, an eighth of the
list. So if I was actually really careful-- I'm not going to do the math here-- and in fact, what"
Lecture11_Chunk43,"list. So if I was actually really careful-- I'm not going to do the math here-- and in fact, what
we'll see-- and if you like, in your copious spare time, you can go off and work this through--
what you'll discover is that you're actually doing order n work to do the copying. But that's still
a problem, because then, I've got something that's order n plus log n. And the n is going to
dominate, so this is still linear."
Lecture11_Chunk44,"dominate, so this is still linear.
Sounds like I led you down a primrose path here. Can we fix this? Sure. Because we could do
the following.
We could say, when I want to look at that list, do I need to copy everything? What about if,
instead, I said, here's the beginning and the end of the list. When I test the middle, I'll move
one of the pointers to the middle of the list. When I test the middle again, I'll move another"
Lecture11_Chunk45,"one of the pointers to the middle of the list. When I test the middle again, I'll move another
pointer in. So in other words, I can test the middle. And based on that, I could say, I only need
to search this part of the list. Just keep track of that point and that point in the list. And when I
test the middle again, same idea.
Now I'm not actually copying the list, I am simply keeping track of, where are the pieces of the"
Lecture11_Chunk46,"Now I'm not actually copying the list, I am simply keeping track of, where are the pieces of the
list that bound my search. Ha, all right? I'm still reducing the size of the problem by a factor of
2 at each step. That's great. All I'd need to do now, though, is just keep track of which portion
of the list I'm searching. I'm going to avoid copying the list. So the number of recursive calls,
again, will be logarithmic. Let's see if that actually fixes my problem."
Lecture11_Chunk47,"again, will be logarithmic. Let's see if that actually fixes my problem.
A little bit of code, not as bad as it looks-- I've got an internal function here that I'm going to
come back to. But let's look at what happens in this case. I'm going to say, again, if there's
nothing in the list, just return False. Element can't possibly be there. Otherwise, call this
function with the list, the element for whom I'm searching, and the beginning and end of the"
Lecture11_Chunk48,"function with the list, the element for whom I'm searching, and the beginning and end of the
list-- so 0 at one end, length of n l minus 1 at the other end. It's just that idea of, I'm keeping
track of the two pieces, OK?
Now let's look at what this does. It says, here's the low part of the list, the high part of the list.
Initially, it's 0 and length of list minus 1. It says, if they are the same, oh cool, then I've got a list"
Lecture11_Chunk49,"of length 1. Just test to see if it's the thing I'm looking for. If they're not, find the midpoint. And
the midpoint's just the average of low plus high, integer division by 2. Think about it. If it's 0
and n, midpoint is n/2.
But if it's, for example, n/2 and n, midpoint is 3/4 n. So that mid picks the middle point. If it's the
thing I'm looking for, great, I'm done. Otherwise, check to see, is the thing at the middle bigger"
Lecture11_Chunk50,"thing I'm looking for, great, I'm done. Otherwise, check to see, is the thing at the middle bigger
than or less than the thing I'm looking for. And based on that-- I'm going to skip this one for a
second-- I'm either going to search everything from the low point up to the middle point or
from the middle point up to the high point. And the last piece here is, if, in fact, the low point
and the middle point are the same, I've got a list of size 1. There's nothing left to do. I'm done."
Lecture11_Chunk51,"and the middle point are the same, I've got a list of size 1. There's nothing left to do. I'm done.
OK, I know it's a lot of code. I would invite you just to walk through it. But I want to take you
back again to just, simply, this point and say, here's what we're doing. We're starting off with
pointers at the beginning and end of the list. We're testing the middle point. And based on that,
we're giving a call where, now, the pointer is to the beginning and the middle of the list, simply"
Lecture11_Chunk52,"we're giving a call where, now, the pointer is to the beginning and the middle of the list, simply
passing it down, and same as I go through all of these pieces.
So that code now gives me what I'd like. Because here, in the previous case, I had a cost. The
cost was to copy the list. In this case, it's constant. Because what am I doing? I'm passing in
three values. And what does it take to compute those values? It's a constant amount of work,"
Lecture11_Chunk53,"three values. And what does it take to compute those values? It's a constant amount of work,
because I'm simply computing mid right there, just with an arithmetic operation.
And that means order log n steps, because I keep reducing the problem in half. And the cost
at each point is constant. And this is, as a consequence, a really nice example of a logarithmic
complexity function.
Now, if you think about it, I'm cheating slightly-- second time today. Because we said we really"
Lecture11_Chunk54,"Now, if you think about it, I'm cheating slightly-- second time today. Because we said we really
don't care about the implementation. We want to get a sense of the complexity of the
algorithm. And that's generally true. But here is a place in which the implementation actually
has an impact on that complexity. And I want to be conscious of that as I make these
decisions. But again, logarithmic in terms of number of steps, constant work for each step,"
Lecture11_Chunk55,"decisions. But again, logarithmic in terms of number of steps, constant work for each step,
because I'm just passing in values. And as a consequence, the overall algorithm is log.
Notice one other thing. I said I want you to see characteristics of algorithms that tell you
something about the complexity of that algorithm. Something that's iterative and reduces the
problem by size 1 each time, from n, to n minus 1, to n minus 2-- linear. Something that"
Lecture11_Chunk56,"problem by size 1 each time, from n, to n minus 1, to n minus 2-- linear. Something that
reduces the size of the problem in half, or in thirds, or in quarters each time-- logarithmic,
generally, unless I've got a hidden cost somewhere.
Here's another little example just to give you a sense of log. I want to convert an integer to a
string. I know I can just call str() on it. But how might we do that inside of the machine?"
Lecture11_Chunk57,"string. I know I can just call str() on it. But how might we do that inside of the machine?
Well, here's a nice little algorithm for it. I'm going to set up something I call digits. It's just a
string of all the digits. If the thing I'm trying to convert is 0, I just return the string ""0"".
Otherwise, let's run through a little loop where I take that integer divided by 10, the remainder
of that. What is that? Oh, that's the zeroth or the 1-order, the first order bit. And I'm going to"
Lecture11_Chunk58,"of that. What is that? Oh, that's the zeroth or the 1-order, the first order bit. And I'm going to
index into digits to find that. And I'm going to add it on to a string that I'm [INAUDIBLE]. And I'll
divide i by 10.
So this says, given an integer, I want to convert it to a string. I divide the integer by 10, take
the remainder. That gives me the zeroth, or if you like, the ones element. I index into the"
Lecture11_Chunk59,"the remainder. That gives me the zeroth, or if you like, the ones element. I index into the
string, and I record it. And then I add it to what I get by dividing i by 10 and doing the same
thing. So I'll just walk down each of the digits, converting it into a string.
What I care about is the order of growth here. This is all constant. All I want to worry about
here is, how many times do I go through the loop. And inside of the loop, this is just constant."
Lecture11_Chunk60,"here is, how many times do I go through the loop. And inside of the loop, this is just constant.
It doesn't depend on the size of the integer.
So how many times do I go through the loop? Well, how many times can I divide i by 10? And
that's log of i, right? So it's not i itself. It's not the size of the integer. It's the number of digits in
the integer. And here's another nice example of log. I'll point you, again, right here. I'm"
Lecture11_Chunk61,"the integer. And here's another nice example of log. I'll point you, again, right here. I'm
reducing the size of the problem by a constant factor-- in this case, by 10-- each time-- nice
characteristic of a logarithmic algorithm.
OK, we've got constant. We've got log. What about linear? We saw it last time, right?
Something like searching a list in sequence was an example of something that was linear. In
fact, most of the examples we saw last time were things with iterative loops."
Lecture11_Chunk62,"fact, most of the examples we saw last time were things with iterative loops.
So for example, fact, written intuitively-- factorial, right-- n times n minus 1 times n minus 2 all
the way down to 1. I set product to 1. I go for a loop where i goes from 1 up to n minus 1, or
just below n minus 1-- incrementally multiplying product by i and restoring that back away.
Again, we know that this loop here-- how many times do I go through it? I go through it n"
Lecture11_Chunk63,"Again, we know that this loop here-- how many times do I go through it? I go through it n
times. The cost inside the loop, there are three steps, changing i, I'm multiplying product times
i, I'm storing that value back in product. And as we saw, that constant doesn't matter. This is
linear. So n times around the loop, constant cost each time-- order n.
What about recursive? I could write fact recursively. I actually prefer it this way, right? If n is"
Lecture11_Chunk64,"What about recursive? I could write fact recursively. I actually prefer it this way, right? If n is
less than or equal to 1, return 1. Otherwise, multiply n by whatever I get by calling this on n
minus 1. The cost inside the loop is just constant. I'm doing one subtraction, one multiplication.
How many times I go through it? Again, n times, because I've got to go from n to n minus 1 to
n minus 2. So again, this is linear."
Lecture11_Chunk65,"n minus 2. So again, this is linear.
Now, if you were to time it, you'd probably see a difference. My guess is-- I'm sure Professor
Guttag will correct me if I get it wrong-- is that the factorial one probably takes a little more
time, because you've got to set up the frame for the recursive call. But in terms of what we
care about, they're the same. They're both linear. They're order n. And so interestingly, both
iterative and recursive factorial have same order of growth."
Lecture11_Chunk66,"iterative and recursive factorial have same order of growth.
Again, I want you to notice, what's the key here. Reducing the size of the problem by 1 is
indicative, generally, of something that's going to have linear growth. I say in general. If it's a
loop inside of a loop, as we saw, it might be a little bigger. But this is generally linear.
Constant, log, linear, log-linear-- that is, n log n-- we're going to see this next time. I'm"
Lecture11_Chunk67,"Constant, log, linear, log-linear-- that is, n log n-- we're going to see this next time. I'm
certainly going to push it ahead. It invites you to come back on Wednesday and see this. It's
actually something that's a really powerful algorithm. It's going to be really useful. We're going
to look at something called merge sort, which is a very common sorting algorithm and has that
property of being log-linear. So we'll come back to this next time."
Lecture11_Chunk68,"property of being log-linear. So we'll come back to this next time.
How about polynomial? Well, we saw this last time as well. This commonly occurs when we
have nested loops or where we have nested recursive function calls-- nested loop meaning I'm
looping over some variable, and inside of there, I've got another loop. And what we saw is the
outer loop, if it's a standard iterative thing, will be linear. But inside of the loop, I'm doing a"
Lecture11_Chunk69,"outer loop, if it's a standard iterative thing, will be linear. But inside of the loop, I'm doing a
linear amount of work each time. So it becomes n times n, so order n squared.
OK, exponential-- these are things-- sorry, yes, I did that right. I'm going to go back to it.
Exponential-- these are things that we'd like to stay away from, but sometimes, we can't. And a
common characteristic here is when we've got a recursive function where there's more than
one recursive call inside the problem."
Lecture11_Chunk70,"one recursive call inside the problem.
Remember Towers of Hanoi, that wonderful demonstration I did. I was tempted to bring it
back, because it's always fun to get a little bit of applause when I do it. But I won't do it this
time. But remember, we looked at that problem of solving the Towers of Hanoi. How do I move
a stack of size n of different-sized disks from one peg to another where I can only move the
top disk onto another one and I can't cover up a smaller disk?"
Lecture11_Chunk71,"top disk onto another one and I can't cover up a smaller disk?
Want to remind you, we saw, there was a wonderful recursive solution to that. It said, move a
stack of size n minus 1 onto the spare peg. Move the bottom one. And then, move that stack
over onto the thing you were headed towards, OK? What's the complexity of that?
Well, I'm going to show you a trick for figuring that out. It's called a recurrence relation for a"
Lecture11_Chunk72,"Well, I'm going to show you a trick for figuring that out. It's called a recurrence relation for a
very deliberate reason. But it'll give us a little, handy way to think about, what's the order of
growth here.
So I'm going to let t sub n denote the time it takes to move a tower of size n. And I want to get
an expression for, how much time is that going to take. What do I know? I know that's 2 times t
to the n minus 1, right? I've got to move a stack of size 1 less onto the spare peg, and then, 1"
Lecture11_Chunk73,"to the n minus 1, right? I've got to move a stack of size 1 less onto the spare peg, and then, 1
to move that bottom thing over, and then, whatever it takes me to move a stack of size n
minus 1 over to that peg. OK, so how does that help me?
Well, let's play the same game. What's t of n minus 1? Oh, that's 2t of n minus 2 plus 1. I'm
just substituting in. I'm using exactly the same relationship here. All right, let's just do a little"
Lecture11_Chunk74,"math on that. That's 4t to the n minus 2 plus 2 plus 1. And you're still going, OK, who cares.
Well, let's do the same thing one more time. t of n minus 2-- that's 2t of n minus 3 plus 1. Oh,
see the pattern? You can start to see it emerge here, right?
Each time I reduce this, I'm adding another power of 2, and I'm increasing the coefficient out
front. And so, in fact, after k steps, I'll have 1 plus 2 plus 4 all the way up to 2 to the k minus 1"
Lecture11_Chunk75,"plus 2 to the k times t sub n minus k. Hopefully you can see it if you just look. This expression
is capturing all of those up there. I'm just pulling it out each time.
When am I done? When this is size 0, when k is equal to n. And so that's when I get that
expression. If this is going by too fast, just walk it through yourself later on. But I'm literally just
using this expression to do the reduction until I see the pattern. All right, what's that?"
Lecture11_Chunk76,"using this expression to do the reduction until I see the pattern. All right, what's that?
Well, if your Course 18 major, you've seen it before. If you haven't, here's a nice, little trick. Let
me let a equal that sum, 2 to the n minus 1 plus 2 to the n minus 2 all the way down to 1. Let
me multiply both the left and the right side by 2. That gives me, 2a is equal to 2 to the n plus 2
to the n minus 1 all the way down to 2. I'm just taking each of the terms and multiplying them
by 2."
Lecture11_Chunk77,"to the n minus 1 all the way down to 2. I'm just taking each of the terms and multiplying them
by 2.
Now subtract this from that. And then on the left side, you get a. And on the right side, you get
that term. These all cancel out minus 1-- geometric series, cool. So that sum is just 2 to the n
minus 1. And if I plug that back in there, ah, I've got my order of growth, exponential, 2 to the
n.
OK, I was a math/physics undergrad. I like these kinds of things. But I wanted you to see how"
Lecture11_Chunk78,"n.
OK, I was a math/physics undergrad. I like these kinds of things. But I wanted you to see how
we can reason through it, because this is letting us see the growth. What I want you to pull
away from this is, notice the characteristic. In Towers of Hanoi-- we're going to do another
example in a second-- the characteristic was, at the recursive step, I had not one, but two
recursive calls. And that is characteristic of something with exponential growth, which I just
saw here, 2 to the n."
Lecture11_Chunk79,"saw here, 2 to the n.
That, by the way, I'll remind you of the story of Towers of-- Towers of Hanoi, right? When the
priests in that temple move the entire stack from one peg to another, we all reach nirvana, and
the world ends. n is equal to 64 here. Go figure out what 2 to the 64 is. And if you're doing one
move per second, which they will, I think we're certainly going to be here a while before the
universe ends and we reach nirvana, probably several times over.
AUDIENCE:"
Lecture11_Chunk80,"universe ends and we reach nirvana, probably several times over.
AUDIENCE:
I thought we were already in nirvana.
ERIC GRIMSON:
We are in nirvana, we're at MIT. You're right, John. But we're worrying about the rest of the
world. So, OK, we'll keep moving on. Nirvana will be next week when they do the quiz, John.
So we'll keep moving quickly. All right.
I want to show you one more example. It's a cool problem from math, but mostly to see that"
Lecture11_Chunk81,"I want to show you one more example. It's a cool problem from math, but mostly to see that
characteristic of exponential growth. And then we're going to pull all of this together. This is
something called the power set. So if I have a set of things-- well, let's assume I have a set of
integers-- with no repeats-- so 1 through n, 1, 2, 3, 4, for example-- I want to generate the
collection of all possible subsets-- so subset with no elements, with one element, with two"
Lecture11_Chunk82,"collection of all possible subsets-- so subset with no elements, with one element, with two
elements, with three amounts, all the way up to n elements.
So for example, if my set is 1 through 4, then the power set would be the empty set with no
elements in it, all of the instances with one element, all of them with two, all of them with three,
and all of them with four. I'd like to write code to generate this. It's actually handy problem in"
Lecture11_Chunk83,"and all of them with four. I'd like to write code to generate this. It's actually handy problem in
number theory or in set theory. By the way, the order doesn't matter. I could do it this way, but
this would be a perfectly reasonable way of generating it as well. And I'm going to come back
to that in a second as we think about solving this. The question is, how would I go about
finding all of these.
I'm going to use-- well, we could stop and say, you could imagine writing a big iterative loop."
Lecture11_Chunk84,"I'm going to use-- well, we could stop and say, you could imagine writing a big iterative loop.
You start with n, and you decide, do I include it or not. And then you go to n minus 1. Do I
include it or not? And you could think about writing a big loop that would generate all of these--
actually, a bunch of nested loops. But there's a nice recursive solution. And I want to
encourage you to think that way.
So here's the way I'm going to do it. What did we do when we said we want to think"
Lecture11_Chunk85,"So here's the way I'm going to do it. What did we do when we said we want to think
recursively? We say, let's assume we can solve a smaller size problem. If I want to generate
the power set of all the integers from 1 to n, I'm going to assume that I can generate the
power set of integers from 1 to n minus 1.
If I have that solution, then I can construct the solution to the bigger problem really easily."
Lecture11_Chunk86,"If I have that solution, then I can construct the solution to the bigger problem really easily.
Wow. Well, all of the things that were in that solution to the smaller problem have to be part of
the solution to the bigger problem. They're all subsets of 1 to n, because they're all subsets of
1 to n minus 1.
So I'm going to add all those in. And then I'm going to say, let's take each one of those and
add n to each of those subsets. Because that gives me all the rest of the solutions. I've got all"
Lecture11_Chunk87,"add n to each of those subsets. Because that gives me all the rest of the solutions. I've got all
the ways to find solutions without n. I get all the ways to find solutions with n. That may sound
like a lot of gobbledygook, but let me show you the example.
There is the power set of the empty set. It's just the empty set. Get the power set of 1, I
include that, and I include a version of everything there with 1 added to it. There's the power"
Lecture11_Chunk88,"include that, and I include a version of everything there with 1 added to it. There's the power
set of 1. Now, given that, how do I get the power set of 2? Well, both of those are certainly
things I want. And for each one of them, let me just add 2.
And if you look at that, right, that's the set of all ways of getting nothing, 1, 2, or both of them.
And you get the idea. Now, having that solution, I can get the solution for 3, because all of"
Lecture11_Chunk89,"And you get the idea. Now, having that solution, I can get the solution for 3, because all of
those have to belong. And I simply add 3 to each one of those. Oh, that's cool, right?
All right, you don't have to be a math geek to admit it's cool. It is kind of cool. Because it says,
gee, got a solution to the smaller problem. Generating the next piece is a natural step. And
you can also see, the size of that set's doubling each time. Because you get to 4, I'm going to"
Lecture11_Chunk90,"you can also see, the size of that set's doubling each time. Because you get to 4, I'm going to
add everything in to all of those pieces-- really nice recursive description. Let's write some
code.
So I'll also hand it out to you, but here's the code. And I'm going to walk through it carefully.
And then we're going to analyze it. But it's actually, for me, a beautiful piece of code. I did not
write it, by the way, John did. But it's a beautiful piece of code."
Lecture11_Chunk91,"write it, by the way, John did. But it's a beautiful piece of code.
I want to generate all the subsets with a power set of some list of elements. Here's how I'm
going to do it. I'm going to set up some internal variable called res, OK? And then, what am I
going to do? Actually, I don't know why I put res in there. I don't need it. But we'll come back to
that.
If the list is empty, length of the list is 0, I'm going to just return that solution. And this is not a"
Lecture11_Chunk92,"typo. What is that funky thing there? It is a list of one element, which is the empty list, which I
need. Because the solution in this case is a set with nothing in it. So there is the thing I return
in the base case.
Otherwise, what do I do? I take all the elements of the list except the last one, and I call it
recursively. I generate all of the subsets of that. Perfect, so I'm going to call that smaller. I then"
Lecture11_Chunk93,"take the last element, and I make a list of just the last element. And what did I say I need to
do? I need all of these guys, plus I need all of them where I add that element in-- oh, nice.
I'll set up new as a variable here. And I'll loop over all of the elements from the smaller
problem, where I basically add that list to that list. And I put it into new. That's simply taking all
of the solutions of subsets of up to n minus 1 and creating a new set of subsets where n is"
Lecture11_Chunk94,"of the solutions of subsets of up to n minus 1 and creating a new set of subsets where n is
included in every one of them. And now I take this, and I take that. I append them-- or
concatenate them, rather. I should say ""append them""-- concatenate them together and return
them.
That's a crisp piece of code. And I'm sorry, John, I have no idea why I put res up there. I don't
think I need that anywhere in this code. And I won't blame it on John. It was my recopying of
the code.
AUDIENCE:"
Lecture11_Chunk95,"the code.
AUDIENCE:
[INAUDIBLE] .
ERIC GRIMSON:
Sorry?
AUDIENCE:
Maybe.
ERIC GRIMSON:
Maybe, right. Look, I know I'm flaming at you. I get to do it. I'm tenured, as I've said multiple
times in this course. That's a cool piece of code. Imagine trying to write it with a bunch of loops
iterating over indices. Good luck. You can do it. Maybe it'll be on the quiz. Actually, no, it won't.
That's way too hard to ask."
Lecture11_Chunk96,"That's way too hard to ask.
But it's a cool piece of code, because I can look at it and say, what's the solution, solve the
smaller problem, and then, given that, take every one of the things in that smaller problem,
add that element into it, and put the two pieces together. Wonderful. OK, with that in mind, let's
see if we can figure out the complexity of this.
Up here, that's constant. That's OK. Right there, I've got the recursive call. So I know, first of"
Lecture11_Chunk97,"Up here, that's constant. That's OK. Right there, I've got the recursive call. So I know, first of
all, that this is going to call itself n times, right? Because each stage reduces the size of the
problem by 1. So if I'm trying to get the power set of n, I'm going to have to do it to get n minus
1, and then, n minus 2. So I know the recursion of genSubsets() to genSubsets(). This is going
to go around n times."
Lecture11_Chunk98,"to go around n times.
That's not so bad. But right down here, I've got to figure out, what's the cost of this, all right?
This is constant. That's setting up as constant. That's constant. But there, I've got another
loop. And the loop depends on how big smaller is. And ""smaller's"" a bad choice of term here,
because it's going to grow on me. But let's think about it.
By the way, I'm assuming append is constant time, which, generally, it is. The time I need to"
Lecture11_Chunk99,"By the way, I'm assuming append is constant time, which, generally, it is. The time I need to
solve this problem includes the time to solve the smaller problem. That recursive call, I know
that's going to be linear. But I also need the time it takes to make the copy of all the things in
that smaller version.
So how big is that? Oh, crud number two-- number of things in the power set grows as a factor"
Lecture11_Chunk100,"So how big is that? Oh, crud number two-- number of things in the power set grows as a factor
of 2, right? If I've got something of, you know, 1 through 3, I've got all the things with nothing in
it, all the things with one in it, all the things with two things in it, all the things with three things
in it. That's 8. And each time around, I'm doubling the size of it.
So for a set of size k, there are 2 the k cases. And that says that this loop right here is going to"
Lecture11_Chunk101,"So for a set of size k, there are 2 the k cases. And that says that this loop right here is going to
be growing exponentially. Because I've got to go down that entire list to find all of the pieces.
So what's the overall complexity? I'm going to play the same game.
Let's let t sub n capture the time it takes to solve a problem of size n. Just temporarily, I'm
going to let s sub n denote the size of the solution for a problem of size n. How big is that
thing, smaller? And what do I know?"
Lecture11_Chunk102,"thing, smaller? And what do I know?
The amount of time it takes me to solve the problem of size n is the amount of time it takes me
to solve the slightly smaller problem-- that's the recursive call to genSubsets()-- plus the
amount of time it takes me to run over that loop looking at everything in smaller and adding in
a new version, plus some constant c, which is just the number of constant operations, the"
Lecture11_Chunk103,"a new version, plus some constant c, which is just the number of constant operations, the
constant steps inside that loop, OK? And if I go back to it, t sub n is the cost here. t sub n
minus 1 is the cost there. s sub n is the size of this. And then I've got, one, two, three, four,
five constant steps. So c is probably 5 in this case.
So what can I say? There's the relationship. Because I know s of n minus 1 is 2 to the n minus
1. There are 2 to the n minus 1 elements inside of that."
Lecture11_Chunk104,"1. There are 2 to the n minus 1 elements inside of that.
How do I deal with this? Let's play the same game. What's t sub n minus 1? That's t of n minus
2 plus 2 to the n minus 2 plus c. And I could keep doing this. You can see what the pattern's
going to look like. I'm going to have k times c constant steps. For each reduction, I'm going to
get another power of 2. And I'm going to reduce this overall term, after k steps, to t the n
minus k."
Lecture11_Chunk105,"minus k.
When am I done? When that's down to something of size 0. And there's the expression. And
what you can see is what I wanted you to see, order n-- or sorry, order 2 to the n-- is
exponential in the size of the problem.
What's the characteristic? Something that has a recursive call-- sorry, multiple recursive calls
at each step-- is likely to lead to exponential. But that can also be buried inside of how I grow"
Lecture11_Chunk106,"at each step-- is likely to lead to exponential. But that can also be buried inside of how I grow
the size of the problem. And that was the case here. There's only one recursive call, but that
loop grows in size each time around. So the complexity is exponential.
I'm going to pull this together. I said one of the things I'd like to start to recognize is, what are
the characteristics of a choice in algorithm that leads to a particular complexity class. And you
now have some of them."
Lecture11_Chunk107,"now have some of them.
If the code doesn't depend on the size of the problem, that's constant. And in fact, we've been
using that as we look at pieces of the code. If we can reduce the problem-- I said, in this case-
- by half each time, by some constant factor, from n, to n/2, to n/4, to n/8, that tends to be
characteristic-- unless there's a hidden cost somewhere else-- of a logarithmic algorithm.
These are really nice."
Lecture11_Chunk108,"These are really nice.
Simple things that reduce the size of the problem by 1 at each step-- an iterative call that goes
from n, to n minus 1, and then to n minus 2, and then to n minus 3-- characteristic of linear
algorithms. Log-linear we're going to see next time. Polynomial-- typically quadratic n squared
when we have nested loops or nested recursive calls. I'm looping over something. Inside of
there, I'm looping over something else on a size that depends on the size of the problem."
Lecture11_Chunk109,"there, I'm looping over something else on a size that depends on the size of the problem.
And then, we just saw this last one. Multiple recursive calls at each level tends to be
characteristic of exponential. And as I said, we'd like to be as high up in this list as we can,
because those are really nice algorithms to have.
Let me give you one more example of looking at this, and then we'll be done. Fibonacci--"
Lecture11_Chunk110,"Let me give you one more example of looking at this, and then we'll be done. Fibonacci--
standard problem, right? The nth Fibonacci number is the sum of the previous two Fibonacci
numbers. This was the example we saw of multiplying rabbits, if you like. Here's an iterative
version of Fibonacci, which says if n is 0, it's just 0. If it's 1 is just 1.
Otherwise, I'm going to set up, initially, the two previous Fibonacci numbers. And then I'm just"
Lecture11_Chunk111,"Otherwise, I'm going to set up, initially, the two previous Fibonacci numbers. And then I'm just
going to run through a loop where I temporarily keep track of that number. I move the second
previous one into the last previous one. I add those two. That becomes the second previous
number. And I just keep running through that loop.
You can go run it. You see it does the right thing. What I want to look at is the complexity."
Lecture11_Chunk112,"You can go run it. You see it does the right thing. What I want to look at is the complexity.
So that's constant. That's constant. That's linear, because the work inside the loop is constant,
but I'm doing it n times. So this is nice. [INAUDIBLE] I should say, the bottom thing is constant.
The overall algorithm, the worst case is just order n. Great.
What about the recursive version? For me, this is much nicer code. It's nice and clean. It says"
Lecture11_Chunk113,"What about the recursive version? For me, this is much nicer code. It's nice and clean. It says
if n is equal to 0, fib is 0, 0. If n is equal to 1, fib of 1-- or the first and second Fibonacci
numbers-- are 0 and 1. Otherwise, just return what I get by summing both of those pieces.
And you can probably already guess what the complexity is going to be here, right? Because
I've now got two recursive calls inside of this call. So one way to think about it is, if I'm going to"
Lecture11_Chunk114,"solve the problem up here, I've got to solve two versions of the problem below, which has got
to solve two versions of the problem below. And in general, this is going to be exponential, 2 to
the n.
Now you say, wait a minute. I was paying attention when this guy was yattering on a couple of
weeks ago. Honest, I was. And in fact, what we saw was that fib isn't balanced in terms of how
it goes, right? It's not that, on the right-hand side of the tree, I have to solve all of those"
Lecture11_Chunk115,"it goes, right? It's not that, on the right-hand side of the tree, I have to solve all of those
portions, because the problem gets smaller. Does that change the complexity?
Well, the answer is, it changes the base, but it's actually still exponential. And if you want to go
look this up, I'm sure you can find Wikipedia very quickly. This actually has a very cool
exponential growth. It's the golden ratio to the nth power. And in fact, I encourage you to go"
Lecture11_Chunk116,"exponential growth. It's the golden ratio to the nth power. And in fact, I encourage you to go
look at it in the even more copious spare time you have. It's a very cool proof to see it. But the
bottom line is, while we can do a little bit better than 2 to the n, it still grows exponentially with
n.
So what do we have? We've got big O notation as a way of talking about comparing efficiency
of algorithms. What I want you to see here is that you ought to be able to begin to reason"
Lecture11_Chunk117,"of algorithms. What I want you to see here is that you ought to be able to begin to reason
about what's the cost of an algorithm by recognizing those common patterns. I keep saying it,
but it's going to be really valuable to you.
And you should be able to therefore work the other direction. When you're given a new
problem, how do I get this into a linear algorithm if I can? Log-linear, if I can, would be really"
Lecture11_Chunk118,"problem, how do I get this into a linear algorithm if I can? Log-linear, if I can, would be really
great. But you know, if I can't, how do I stay away from exponential algorithms? And finally,
what we're going to show later on is that, in fact, there are some problems that, as far as we
know, are fundamentally exponential. And they're expensive to compute.
The very last thing is, you might have decided I was cheating in a different way. So I'm using a"
Lecture11_Chunk119,"The very last thing is, you might have decided I was cheating in a different way. So I'm using a
set of built-in Python functions. I'm not going to go through all of these. But this is just a list, for
example, for lists, of what the complexity of those built-in functions are. And if you look through
the list, they kind of make sense.
Indexing, you can go straight to that point. Computing the length, you compute it once, you've"
Lecture11_Chunk120,"Indexing, you can go straight to that point. Computing the length, you compute it once, you've
stored it. Comparison-- order n, because I've got to compare all the elements of the list.
Similarly, to remove something from the list, I've got to find where it is in the list and remove it.
Worst case, that's going to be order n. So you can see that these operations are typically
linear in the size of a list. These are constant."
Lecture11_Chunk121,"linear in the size of a list. These are constant.
For dictionaries, remember, dictionaries were this nice thing. They weren't ordered. It gave me
a power in terms of storing them. But as a consequence, some of the costs then go up.
For a list, indexing, going to a particular point, I just go to that spot and retrieve it. Indexing into
a dictionary, I have to find that point in the dictionary that has the key and get the value back."
Lecture11_Chunk122,"a dictionary, I have to find that point in the dictionary that has the key and get the value back.
So that's going to be linear, because I have to, in principle, walk all the way down it.
It's a slight misstatement, as we'll see later on. A dictionary actually uses a clever indexing
scheme called a hash. But in the worst case, this is going to be linear. So you see a trade-off.
For dictionaries, I get more power. I get more flexibility. But it comes as a cost."
Lecture11_Chunk123,"For dictionaries, I get more power. I get more flexibility. But it comes as a cost.
And so these, basically, are what let me reason on top of the things I've been doing to figure
out complexity. And next time, we'll do the last piece of this when we look at sorting. So we'll
see you all on Wednesday."
Lecture12_Chunk1,"MITOCW | watch?v=6LOwPhPDwVc
The following content is provided under a Creative Commons license.
Your support will help MIT OpenCourseWare continue to offer high
quality educational resources for free. To make a donation or view
additional materials from hundreds of MIT courses, visit MIT
OpenCourseWare at ocw.mit.edu.
PROFESSOR:
So, for the last two lectures we've been talking about analyzing
algorithms, complexity, orders of growth. How do we estimate the cost of"
Lecture12_Chunk2,"algorithms, complexity, orders of growth. How do we estimate the cost of
an algorithm as the size of the input grows? And as I've said several
times, I'll say at least once more, how do we also turn it the other
direction? How do we use thoughts about choices of pieces of algorithm
in terms of implications on the cost it's going to take us to compute?
We saw last time a set of examples-- constant algorithms, linear
algorithms, logarithmic algorithms, linear algorithms, quadratic"
Lecture12_Chunk3,"algorithms, logarithmic algorithms, linear algorithms, quadratic
algorithms, exponential algorithms. Today, what I'm going to do is fill in
one more piece, a log linear algorithm-- something that's really a nice
kind of algorithm to have-- and use it to talk about one last class of
algorithms that are really valuable, and those are searching and sorting
algorithms.
So a search algorithm. Kind of an obvious statement. You use them all"
Lecture12_Chunk4,"algorithms.
So a search algorithm. Kind of an obvious statement. You use them all
the time when you go to Google or Bing or whatever your favorite
search mechanism on the web is. It's just a way to find an item or a
group of items from a collection. If you think about it, that collection
could be either implicit or explicit. So way back at the beginning of the
term, we saw an example of a search algorithm when you were looking"
Lecture12_Chunk5,"term, we saw an example of a search algorithm when you were looking
for square roots. And we saw simple things like exhaustive enumeration.
We'd go through all the possibilities. We saw our first version of bisection
search there, where you would do approximations. Newton-Raphson--
these are all examples of a search algorithm where the collection is
implicit. So all the numbers between some point that some other point.
More common is a search algorithm where the collection is explicit. I"
Lecture12_Chunk6,"More common is a search algorithm where the collection is explicit. I
don't know. For example, I've got all the data records of students and I
want to know how do I find a particular student, so I can record that A
plus that everybody in this room is going to get next Tuesday on that
exam? That's not a promise. Sorry. But we'll work on it. So could do it
implicit, could do it explicit. Today I want to focus on doing search"
Lecture12_Chunk7,"implicit, could do it explicit. Today I want to focus on doing search
explicitly. And it could be on different kinds of collections, but I'm going
to focus-- just as an example-- on search over lists. And to make it a
little easier, let's just do search over lists of numbers. But it could
obviously be other kinds of elements.
Now you've already seen some of this, right? We did search where we
said, we can do linear search. Brute force. Just walk down the list"
Lecture12_Chunk8,"said, we can do linear search. Brute force. Just walk down the list
looking at everything till we either find the thing we're looking for or we
get to the end of the list. Sometimes also called British Museum
algorithm or exhaustive enumeration. I go through everything in the list.
Nice news is, the list doesn't have to be sorted. It could be just in
arbitrary order. What we saw is that the expected-- sorry, not expected.
The worst case behavior is linear. In the worst case, the element's not in"
Lecture12_Chunk9,"The worst case behavior is linear. In the worst case, the element's not in
the list. I got to look at everything. So it's going to be linear in terms of
complexity.
And then we looked at bisection search, where we said the list needs to
be sorted. But if it is, we can actually be much more efficient because we
can take advantage of the sorting to cut down the size of the problem.
And I'll remind you about both of those. There was our simple little linear"
Lecture12_Chunk10,"And I'll remind you about both of those. There was our simple little linear
search. Right? Set a flag that says, I haven't yet found it. And then just
loop over the indices into the list. I could have also just looped directly
over the list itself, checking to see if the ith member of the list is the thing
I'm looking for. If it is, change the flag to true so that when I come out of
all of this I'll return the flag-- either false because it was set that way
initially or true because I found it."
Lecture12_Chunk11,"initially or true because I found it.
And of course what we knew is we have to look at everything to see if it's
there or not. I could speed this up by just returning true at this point.
While that would improve the average case, doesn't improve the worst
case. And that's the thing we usually are concerned about, because in
the worst case I've got to go through everything. And just to remind you,
we said this is order length of the list. To go around this part-- the loop"
Lecture12_Chunk12,"we said this is order length of the list. To go around this part-- the loop
right here-- and inside the loop, it's constant work. I'm doing the same
number of things each time. That's order n times order 1. And by our
rules, that's just order n. So it's linear in the size of the problem.
OK. We said we could do it on sorted lists. But just again, we'll walk
down the list. Again, here I could loop over everything in the list,"
Lecture12_Chunk13,"down the list. Again, here I could loop over everything in the list,
checking to see if it's the thing I want. Return true. And if I ever get to a
point where the element of the list is bigger than the thing I'm looking
for, I know it can't be in the rest of the list because all the things to the
right are bigger yet. I could just Return false and drop out. In terms of
average behavior, this is better because it's going to stop as soon as it"
Lecture12_Chunk14,"average behavior, this is better because it's going to stop as soon as it
gets to a point where it can rule everything else out. But in terms of
complexity, it's still order n. Because I still on average have-- not
average. In the worst case, I'm still going to be looking n times through
the loop before I get to a point where I can decide to bail out of it. So
order n.
And then finally-- last piece of recap-- bisection search. Repeat again."
Lecture12_Chunk15,"order n.
And then finally-- last piece of recap-- bisection search. Repeat again.
The idea here is, take the midpoint of the list. Look at that element. If it's
the thing I'm looking for, great. I just won the lottery. If it isn't, decide is
the thing I'm looking for bigger or less than that middle point. If it's
bigger than that, I only use the upper half of the list. If it's less than that,
I only use the lower half of the list. And the characteristic here was, at"
Lecture12_Chunk16,"I only use the lower half of the list. And the characteristic here was, at
each step, I'm reducing the size of the problem in half. I'm throwing
away half of the remaining list at each step.
And I'll just remind you of that code. I know it's a lot here, but just to
remind you. It said, down here if I've got an empty list, it can't be there.
I'm going to Return false. Otherwise call this little helper function with the
list, the thing for which I'm searching, and the beginning and end point"
Lecture12_Chunk17,"list, the thing for which I'm searching, and the beginning and end point
indices into the list. Initially the start and the very end. And this code up
here basically says, if those two numbers are the same I'm down to a list
of one. Just check to see if it's the thing I'm looking for. Otherwise, pick
something halfway in between. And ignore this case for the moment.
Basically then check to see, is the thing at that point bigger than e? In"
Lecture12_Chunk18,"Basically then check to see, is the thing at that point bigger than e? In
which case, I'm in general going to call this only with from the low point
to the midpoint. Otherwise I'm going to call this with the midpoint to high.
And that was just this idea of, keep cutting down in half the size of the
list.
Last piece of the recap-- the thing we wanted you to see here-- is there
are the two recursive calls. I'm only going to do one because I'm making"
Lecture12_Chunk19,"are the two recursive calls. I'm only going to do one because I'm making
a decision. At each step, I'm cutting down the problem by half. And that
says the number of steps, the number of times I'm going to iterate
through here, will be log in the length of the list. And if that still doesn't
make sense to you, it says, I need to know when 1 over 2 to the k--
where k is the number of steps-- is equal to 1. Because in each step, I'm"
Lecture12_Chunk20,"where k is the number of steps-- is equal to 1. Because in each step, I'm
reducing by half. And that's when k is log base 2 of n. So that's why it's
log linear.
And so this just reminds you. Again, that recap. Number of calls
reduced-- or, sorry. The call gets reduced by a factor or two each time.
I'm going to have a log n work going around it. And inside it's a constant
amount of work because I'm just passing the pointers, I'm not actually
copying the list. And that's a nice state to be."
Lecture12_Chunk21,"copying the list. And that's a nice state to be.
OK, so-- sounds good. Could just use linear search. It's going to be
linear. When you use binary search or bisection search, we can do it in
log time. That's great. We assumed the list was sorted, but all right. So
that lens basically says, OK. So when does it make sense to sort the list
and then do the search? Right? Because if I can sort the list cheaply,
then the search is going to be logarithmic. That's really what I would like."
Lecture12_Chunk22,"then the search is going to be logarithmic. That's really what I would like.
This little expression basically says, let's let sort be the cost of sorting
the list. I want to know when that cost plus something that's order log n--
which is what it's going to cost me to do this search. When is that less
than something that's order n? Because then it's going to be better to do
the sort first than do the search. And so I can just rearrange it. It needs"
Lecture12_Chunk23,"the sort first than do the search. And so I can just rearrange it. It needs
to be, when does the cost of sorting-- when is it last than this
expression? Which basically says, when is sorting going to be less
expensive than the linear cost?
Crud. Actually, good news for you, right? This is a really short lecture.
Because it says it's never true. Ouch. Don't worry. We've got more to go
on the lecture. The reason it can't be true-- if you think about it just"
Lecture12_Chunk24,"on the lecture. The reason it can't be true-- if you think about it just
informally-- is, if I've got a collection of n elements and I want to sort it,
I've got to look at each one of those elements at least once. Right? I
have to look at them to decide where they go. Oh, that's n elements. So
sorting must be at least order n, because I got to look at everything. And
in fact as it says there, I'm going to have to use at least linear time to do
the sort."
Lecture12_Chunk25,"in fact as it says there, I'm going to have to use at least linear time to do
the sort.
Sounds like we're stuck, but we're not. And the reason is, often when I
want to search something I'm going to do multiple searches, but I may
only want to sort the list once. In fact, I probably only want to sort the list
once. So in that case, I'm spreading out the cost. I'm amortizing the
expense of the sort.
And now what I want to know is, if I'm going to do k searches, the cost of"
Lecture12_Chunk26,"expense of the sort.
And now what I want to know is, if I'm going to do k searches, the cost of
those k searches I know is going to be k log n-- because it's log to do
the search. And I simply need to know, is the cost of sorting plus this--
can I have something where it's less than k searches just using linear
search? And the answer is, yes. There are going to be, for large k's,
ways in which we can do the sort where the sort time becomes"
Lecture12_Chunk27,"ways in which we can do the sort where the sort time becomes
irrelevant, that the cost is really dominated by this search.
And so what I want to do now is look at-- all right. How could we do the
sort reasonably efficiently? It's going to have to be at least linear. We're
going to see it's going to be a little more than linear. But if I could do it
reasonably, I'm going to be in good shape here. So what I want to do is
show you a number of ways in which we can do sorting-- take a list of"
Lecture12_Chunk28,"show you a number of ways in which we can do sorting-- take a list of
elements and sort them from, in this case, smaller to higher or
increasing order. So here's my goal. I want to efficiently sort a list. I want
to see if we can do this as efficiently as possible.
I'm going to start, you might say, with a humorous version of sort. You're
all convinced that my humor is non-existent. You're right. But it sets the
stage for it. This is a sort. You can look it up. It's called monkey sort,"
Lecture12_Chunk29,"stage for it. This is a sort. You can look it up. It's called monkey sort,
BOGO sort, stupid sort, slow sort, permutation sort, shotgun sort. And
here's how it works. Anna has nicely given me a set of numbers on
cards here. Here's how you do BOGO sort. I got to do that better. I got
to spread them out randomly, like this. Oh good. I'm going to have to--
sorry, Tom. I'm not walking. And now I pick them up, saying, is that less"
Lecture12_Chunk30,"sorry, Tom. I'm not walking. And now I pick them up, saying, is that less
than this? Which is less than-- oh, crud. They're not sorted. All right. I
pick them all up and I do it again. A little brain damage, right?
Now it's intended to get your attention. I did. I heard a couple of
chuckles. Those are A students, by the way. I heard a couple of
chuckles here. We could actually do this exhaustively. Basically it's
called permutation sort because you could search through all possible"
Lecture12_Chunk31,"called permutation sort because you could search through all possible
permutations to see if you find something that's sorted. That, by the
way-- the complexity of that is something like n factorial, which for large
n is n to the nth power. And if n's anything bigger than about 2, don't do
it. Right? But it would be a way to think about doing this.
All right. Now, having caught the humorous version of this, how could we
do this a little bit better? Oh sorry. I should say, what's the complexity?"
Lecture12_Chunk32,"do this a little bit better? Oh sorry. I should say, what's the complexity?
There's a nice crisp definition of BOGO sort. Its best case is order n,
because I just need to check it's sorted. Its average case is n factorial
and its worst case, if I'm just doing it randomly, is God knows. Because I
could be doing it here forever. So we're going to move on.
Here's a second way to do it called bubble sort. I'm going to do this with"
Lecture12_Chunk33,"Here's a second way to do it called bubble sort. I'm going to do this with
a small version of this. I'm going to put out a set. I'll turn these up so you
can see them in a second. The idea of bubble sort is, I'm going to start
at-- I'm going to call this the front end of the list. And I'm going to walk
down, comparing elements pairwise. And I'm always going to move the
larger one over. So I start here and I say, 1 is less than 11. I'm OK. 11's"
Lecture12_Chunk34,"larger one over. So I start here and I say, 1 is less than 11. I'm OK. 11's
bigger than five. I'm going to bubble that up. 11's bigger than 6. I'm
going to bubble that up. 11's bigger than 2. I've basically bubbled 11 to
the end.
Now I go back here. I say, 1 is less than 5. That's good. 5 is less than 6.
That's good. Ah, 6 is bigger than 2. Bubble that. 6 is less than 11. You
get the idea-- comparison, comparison, and swap. Comparison,"
Lecture12_Chunk35,"get the idea-- comparison, comparison, and swap. Comparison,
comparison. And now if I go back to this part and do it, you'll notice
that's in the right order. That's in the right order. That's in the right order.
That's in the right order. I'm done. Small round of applause, please. I
was able to sort five elements. Thank you.
The little video is showing the same thing. You can see the idea here.
It's called bubble sort because you're literally bubbling things up to the"
Lecture12_Chunk36,"It's called bubble sort because you're literally bubbling things up to the
end of the list. It's pretty simple to do. You're just swapping pairs. And as
you saw, when I get to the end of the list I go back and do it until I have
a pass where I go all the way through the list and I don't do any swaps.
And in that case I know I'm done because everything's in order, and I
can stop. One of the properties of it is that the largest unsorted element"
Lecture12_Chunk37,"can stop. One of the properties of it is that the largest unsorted element
is always at the end after the pass. In other words, after the first one I
know that the largest element's at the end. After the second one, the
largest thing left is going to be in the next place. And that tells me,
among other things, that this is going to take no more than n times
through the list to succeed. It might actually take fewer than that."
Lecture12_Chunk38,"through the list to succeed. It might actually take fewer than that.
OK. Again let's look at some code for it. Let's look at its complexity and
let's actually run this. So here is a little simple version of bubble sort. I'm
going to set a flag up here. I'm going to call its swap initially to false.
That's going to let me tell when I'm done, when I've gone through
everything in the list without doing a swap. And then I'm going to loop."
Lecture12_Chunk39,"everything in the list without doing a swap. And then I'm going to loop.
As long as swap is false-- so the first time through it's going to do that
loop. I set swap initially to true, and notice what I then do. I let j range
from 1 up to the length of the list, and I look at the jth element and the
previous element. If the previous element is bigger, I'm going to flip
them. Right there. And that's just doing that swap, what I just did down
here."
Lecture12_Chunk40,"them. Right there. And that's just doing that swap, what I just did down
here.
And if that's the case, I'm going to set the flag to false. Which says, I've
done at least one bubble as part of this. Which means when I come out
of here and go back around to the loop, it's going to do it again. And it
will do it until all of this succeeds without this ever being true, in which
case that's true, which makes that false. And it will drop out. OK?"
Lecture12_Chunk41,"case that's true, which makes that false. And it will drop out. OK?
Let's look at an example of this running. It's just to give you a sense of
that, assuming I can find the right place here. So there is, again, a
version of bubble sort on the side. And I'm going to bring this down to
the bottom I've got a little test list there. And I've put a print statement in
it. So you can see each time through the loop, what's the form of the list"
Lecture12_Chunk42,"it. So you can see each time through the loop, what's the form of the list
as it starts. And assuming I've done this right-- here you go.
There's the list the first time through. Notice after one pass, 25's at the
end of the list-- the biggest element. Exactly what I like. But you can also
see a few other things have flipped. Right? Right in there, there have
been some other swaps as it bubbled through. And in fact, you can see"
Lecture12_Chunk43,"been some other swaps as it bubbled through. And in fact, you can see
it's-- well, you can see that idea. You can see 25 moving through. Notice
on the next step, a whole bunch of the list is actually in the right order.
It's just because I got lucky. All I can guarantee is that the second
largest element is the second from the end of the list. But you can see
here. Even though the list is, I think, nine long, it only took us four"
Lecture12_Chunk44,"here. Even though the list is, I think, nine long, it only took us four
passes through. So this is nice. It says, at most, n times through the list.
And at the end, we actually get out something that's in the right form.
OK. So let's go back to this and basically say, what's the complexity?
Well that's length n, right? Has to be. I'm going through the entire list.
And inside of there is just constant work. Four operations. I'm doing a"
Lecture12_Chunk45,"And inside of there is just constant work. Four operations. I'm doing a
test. Sorry, five. I'm doing a test. And then depending whether that test
is true or not, I'm setting a flag and doing some movement of things
around. But it's just constant. I don't care about the five. And there, how
many times do I go around the loop? In the worst case, n. All I can
guarantee is, after the first pass the biggest thing is here. After the"
Lecture12_Chunk46,"guarantee is, after the first pass the biggest thing is here. After the
second pass, the second biggest thing is there. After the third pass-- you
get the idea.
So I've got order and things inside the loop, and I'm doing that loop n
times. And I hope that looks familiar. We've talked about this. Right?
This is nested loops. What's this? Quadratic. So it's order n squared,
where n is the length of the list. Now as you also saw, on average, it"
Lecture12_Chunk47,"where n is the length of the list. Now as you also saw, on average, it
could be less than that. But it's going to be order n squared.
OK. That's one possibility. Here's a second nice, simple, sort algorithm.
It's called selection sort. You can kind of think of this as going the other
way. Not completely, but going the other way. And when I say going the
other way, the idea here is that I'm going to find the smallest element in"
Lecture12_Chunk48,"other way, the idea here is that I'm going to find the smallest element in
the list. And I'm going to stick it at the front of the list when I'm done, and
simply swap that place with whatever was there. Flip them. I might do a
few other flips along the way, depending how I implement this.
Next, pass. I'm just going to look at everything but the first element,
because I know that one's done. I'm going to do the same thing. Find"
Lecture12_Chunk49,"because I know that one's done. I'm going to do the same thing. Find
the smallest element remaining in the list, put it in the second spot, and
keep doing that. What I know is, if I implement this correctly, after i steps
the first i elements of the list will be sorted. And everything in the rest of
the list has to be bigger than the largest thing in the first part of the list.
OK. So we could build that. Before we do it, I'm going to show you a little"
Lecture12_Chunk50,"OK. So we could build that. Before we do it, I'm going to show you a little
video starring Professor Guttag. This is his cameo performance here.
But I want to just show you an example of this using not numbers, but
people.
[VIDEO PLAYBACK]
- All right. So now we're going to do
selection sort. The idea here is that each
step we're going to select the shortest
person and put them next in line of the
sorted group. So we'll bring the leftmost
person forward, and we will compare her"
Lecture12_Chunk51,"sorted group. So we'll bring the leftmost
person forward, and we will compare her
to everybody else. So one at a time, step
forward. You're still the winner. You go
back. Please step forward.
PROFESSOR:
And watch the number of comparisons that go on, by the way. We're
going to come back to that.
- Next. Still the winner. Next. Ah. A new
winner. All right. So you can take her
place.
PROFESSOR:
So here, we're choosing to actually insert into the spot in the Line We"
Lecture12_Chunk52,"place.
PROFESSOR:
So here, we're choosing to actually insert into the spot in the Line We
could have put her back at the front, but either one will work.
- Now we'll compare. Same old winner.
Same winner. No change. It's getting kind
of boring. Don't fall, that-- same winner.
Please.
PROFESSOR:
This is a tough one.
- Oh. Close, but I think you're still shorter.
All right. Next. No change, which means
you are the first in line. Congratulations.
PROFESSOR:"
Lecture12_Chunk53,"All right. Next. No change, which means
you are the first in line. Congratulations.
PROFESSOR:
So, smallest element now going to be the first slot.
- Now you step forward, and we'll
compare you.
PROFESSOR:
I would invite you to watch the left hand of the list. Notice how it is slowly
building up at each stage to have that portion sorted. And we
deliberately admit students to be of different heights, so John can do this
demo.
- You are the winner. Take your place in"
Lecture12_Chunk54,"demo.
- You are the winner. Take your place in
line. Next. It's you. And once again, we
have a lovely group of students sorted in
height order.
[END PLAYBACK]
[APPLAUSE]
PROFESSOR:
And check out-- I want you to remember number of comparisons-- 55.
Not that the [INAUDIBLE], but I want you to see a comparison as we go
on in a second.
So again, selection sort. This is this idea of, find the smallest element.
Put it at the front. I might do a little number of flips, as you can see, here"
Lecture12_Chunk55,"Put it at the front. I might do a little number of flips, as you can see, here
along the way. But this is the same animation of that. So let's first of all
convince ourselves it will do the right thing, and then look at some code,
and then run the code.
So to convince ourselves that this is going to do the right thing, we could
talk about something that we often refer to as a loop invariant. We're
going to write a loop, but we're going to walk through this. And the"
Lecture12_Chunk56,"going to write a loop, but we're going to walk through this. And the
invariant here-- and we want to just demonstrate if it's true at the
beginning and it's true at each step. Therefore, by induction as we did
earlier, I can conclude it's true always. Is that if I'm given the prefix or
the first part of a list from 0 up to i, and a suffix or a second part of the
list from i plus 1 up to the end of the overall list-- given that, then I want"
Lecture12_Chunk57,"list from i plus 1 up to the end of the overall list-- given that, then I want
to assert that the invariant is that the prefix is sorted and no element of
the prefix is larger than the smallest element of the suffix. Just what I
said earlier. It says, at any stage here-- if this is the amount of sort I've
done so far-- I can guarantee, I'm going to claim, this will be sorted. And
everything here is bigger than that thing there."
Lecture12_Chunk58,"everything here is bigger than that thing there.
How do I prove it? Well the base case is really easy. In the base case,
the prefix is empty. I don't have anything, so it's obviously sorted. And
everything in the suffix is bigger than anything in the prefix. So I'm fine.
And then I just want to say, as long as I write my code so that this step is
true, then I'm going to move the smallest element from the suffix-- the
second part of the list-- to the end of the prefix. Since the prefix was"
Lecture12_Chunk59,"second part of the list-- to the end of the prefix. Since the prefix was
sorted, this is now sorted. And everything in the suffix is still going to be
bigger than everything in the prefix. And as a consequence, by
induction, this is going to give me something that says it's always going
to be correct.
So here's code that would do that. Here. I'm just going to set a little thing
called the start of suffix, or soft start. Initially it's going to point to the"
Lecture12_Chunk60,"called the start of suffix, or soft start. Initially it's going to point to the
beginning of the list. And then I'm going to run a loop. And as long as I
still have things to search in the list, that that pointer doesn't point to the
end of the list, what am I going to do? I'm going to loop over everything
from that point to the end of the list, comparing it to the thing at that
point. If it's less than, I'm going to do a swap because I wanted to move"
Lecture12_Chunk61,"point. If it's less than, I'm going to do a swap because I wanted to move
it up. And you can see, by the time I get through this loop I will have
found the smallest element in the remainder of the list. And I would have
put it at that spot, whatever suffix start points to.
And when I've done all of that, I just change this by one. Having found
the smallest element, I've stuck it at spot zero. I'll do the same thing.
Having found the next smallest element, I know it's at point one. And I'll"
Lecture12_Chunk62,"Having found the next smallest element, I know it's at point one. And I'll
just continue around. One of the things you can see here is, as opposed
to bubble sort, this one is going to take n times around the loop because
I'm only moving this pointer by one So it starts at 0, and then 1, and then
2, all the way up to n minus 1.
You can also see in this particular implementation, while I'm certainly
ensuring that the smallest element goes into that spot, I may do a few"
Lecture12_Chunk63,"ensuring that the smallest element goes into that spot, I may do a few
other flips along the way. I'm going to find something I think is the
smallest element, put it there and put that element here. And then when
I find another smaller element, I may do that flip. I could have
implemented this where I literally search for the smallest element and
only move that. Doesn't make any difference in terms of the complexity.
All right. What's the complexity here? Already said this part. I will loop n"
Lecture12_Chunk64,"All right. What's the complexity here? Already said this part. I will loop n
times, because I start at 0 and then 1. You get the idea. Inside of the
loop I'm going to walk down the remainder of the list, which is initially n.
And then n minus 1, and then n minus 2 times. But we've seen that
before as well. While they get shorter, that complexity is still quadratic.
Order n times going through this process. Within the process, order n"
Lecture12_Chunk65,"Order n times going through this process. Within the process, order n
things that I have to compare. And yes, n gets smaller. But we know that
that n term, if you like to dominate. So again, this is quadratic.
OK. Before you believe that all sorting algorithms are quadratic, I want to
show you the last one, the one that actually is one of the-- I think-- the
prettiest algorithms around, and a great example of a more efficient
algorithm. It's called merge sort. Merge sort takes an approach we've"
Lecture12_Chunk66,"algorithm. It's called merge sort. Merge sort takes an approach we've
seen before. We talked about divide and conquer. Break the problem
down into smaller versions of the same problem. And once you've got
those solutions, bring the answer back together. For merge sort, that's
pretty easy. It says, if I've got a list of 0 or 1 elements, it's sorted. Duh.
OK. If I got a list of more than 1 element, here's my trick. I'm going to"
Lecture12_Chunk67,"OK. If I got a list of more than 1 element, here's my trick. I'm going to
split it into two lists. I'm going to sort them. And when I'm done, I'm just
going to merge those two lists into one list. And the merge is easy.
Because if I've got two lists that are sorted, I just need to look at the first
element of each, take the one that's smaller. Add it to my result. And
keep doing that until one of the lists is empty. And then just copy the"
Lecture12_Chunk68,"keep doing that until one of the lists is empty. And then just copy the
remainder of the other list. You can probably already get a sense of
what the cost is going to be here, because this is cutting the problem in
half.
Now I've got two pieces. So I need to think about both of them. I want to
give you a couple of visualizations of this. Here's the first one. It says,
basically, I've got a big unsorted list. I'm going to split it. And I'm going to"
Lecture12_Chunk69,"basically, I've got a big unsorted list. I'm going to split it. And I'm going to
split it. And I'm going to split it. Until I get down to just lists that are either
0 or 1, which by definition are sorted. And once I'm at that level, then I
just have to merge them into a sorted list and then merge them pairwise
into a sorted list. And you get the idea.
So it's divide and conquer. The divide is dividing it up into smaller
pieces. The conquer is merging them back together. And we have"
Lecture12_Chunk70,"pieces. The conquer is merging them back together. And we have
Professor Guttag back for an encore, together with his students. So let's
show you an example of merge sort.
[VIDEO PLAYBACK]
- So we're about to demonstrate merge
sort. And we're going to sort this rather
motley collection of MIT students by
height. So the first thing we need to do is,
we're going to ask everyone to split into a
group of two. So you split a little bit. You
two are together. You two are together."
Lecture12_Chunk71,"group of two. So you split a little bit. You
two are together. You two are together.
You two are together. You two are
together. And you are all by yourself. I'm
sorry.
PROFESSOR:
Poor Anna.
- All right. So now let's take the first
group. Take a step down. And what we
do is, we sort this group by height, with
the shortest on the left. And look at this.
We don't have to do anything. Thank you.
Feel free to go back up. We then sort the
next pair. Please. And it looks to me like"
Lecture12_Chunk72,"Feel free to go back up. We then sort the
next pair. Please. And it looks to me like
we need to switch. All right. Take a step
back. Ladies-- OK. Ladies, gentlemen--
also OK. And again, OK.
PROFESSOR:
Notice each subgroup is now sorted. Which is great.
- And I think you're in the correct order.
Now what we do is, we take these groups
and merge the groups. So let's have
these two-- going to sort these groups,
have them step forward. And now what
we're doing is, we're doing a merge of"
Lecture12_Chunk73,"have them step forward. And now what
we're doing is, we're doing a merge of
the two sorted groups. So we start by
merging them. We'll take the leftmost
person in this group and compare her to
the first person in this group, and decide.
She's still the shortest. Take a step back.
Now we're going to look at you and say,
you're actually taller than this fellow. So
you now step up there. And we're good
here. Both of you take a step back."
Lecture12_Chunk74,"you now step up there. And we're good
here. Both of you take a step back.
Now we'll take these two groups and follow the same procedure. We'll
merge them. Let's see. We'll compare you-- the first person in this group
to the first person in this group. Now it's a little tricky. So let's see, the
two of you compare. Let's see, back to back. We have a winner. Step
back. And now we need to compare the shortest person in this group to"
Lecture12_Chunk75,"back. And now we need to compare the shortest person in this group to
the shortest person in this group. We have a winner. It's you. I'm sorry.
And now we just-- we're OK. Please step back.
Now we'll have these two groups come forward. We'll compare the
shortest person in this group to the shortest person in that group. I
actually need you guys to get back to back here. You are the winner.
And it's pretty clear that the shortest person in this group is shorter than"
Lecture12_Chunk76,"And it's pretty clear that the shortest person in this group is shorter than
the shortest person in that group. So you go there and you step back.
PROFESSOR:
Notice the groups. Now all sorted.
- And now we repeat the same process.
PROFESSOR:
And notice how the whole subgroup now goes up once we know that
one group is empty.
- And you can see that we have a group
of students sorted in order by height.
[END PLAYBACK]
[APPLAUSE]
PROFESSOR:"
Lecture12_Chunk77,"of students sorted in order by height.
[END PLAYBACK]
[APPLAUSE]
PROFESSOR:
Remember the first number, right? 55, 28. Now it's just numbers but you
can see the expectation is, this is going to take less time. And it certainly
did there. So again just to demo another way visually. I'm sorting-- sorry.
did there. So again just to demo another way visually. I'm sorting-- sorry.
I am splitting down until I get small things, and then just merging them"
Lecture12_Chunk78,"I am splitting down until I get small things, and then just merging them
up. I may have to do multiple passes through here, but it's going to be
hopefully faster than the other methods we looked at.
I'm going to show you code in a second, and then we're going to run it
just to see it. But let me stress one more time just the idea of merging.
You can see the idea. I keep splitting down till I got something small
enough. And I want to merge them back. The idea of merging-- you've"
Lecture12_Chunk79,"enough. And I want to merge them back. The idea of merging-- you've
seen it from Professor Guttag. But I just want to highlight why this is
going to be efficient. If I've got two lists: list 1 and list 2, the things left
there. Process is very simple. I pull out the smallest element of each. I
compare them. And I simply put the smallest one into the result, move
on in that first list. So the 1 disappears from that left list. And now again I"
Lecture12_Chunk80,"on in that first list. So the 1 disappears from that left list. And now again I
pull up just the smallest element of each one, do the comparison.
Smallest one goes to the end of my result. And I drop that element from
its list. So I've now taken 1 from list 1 and one from list 2. You get the
idea.
The reason I want to give you this visualization-- sorry. Let me do the
last step. Once I get to a place where one of the lists is empty, just copy"
Lecture12_Chunk81,"last step. Once I get to a place where one of the lists is empty, just copy
the rest of the list onto the end. You can see already a hint of the code.
And that is, that I'm only going to ever look at each element of each
sublist once as I do the merge. And that's a nice property. Having had
them sorted, I don't need to do lots of interior comparisons. I'm only
comparing the ends of the list. I only, therefore, look at each element--"
Lecture12_Chunk82,"comparing the ends of the list. I only, therefore, look at each element--
the number of comparisons, rather, I should say. I may look at each
element more than once. The number of comparisons is going to be, at
most, the number of elements in both lists. And that's going to be a nice
Q as we think about how to solve it.
So here's the code to merge, and then we'll write Merge Sort. And I
know there's a lot of code here, but we can walk through it and get a"
Lecture12_Chunk83,"know there's a lot of code here, but we can walk through it and get a
good sense of it. I'm going to set up a variable called Result that's going
to hold my answer. And I'm going to set up two indices, i and j, that are
initially 0. They're pointing to the beginning. And remember, the input
here is two lists that we know are sorted-- or should be sorted, or we
screwed up in some way. So initially, i and j are both pointing to the"
Lecture12_Chunk84,"screwed up in some way. So initially, i and j are both pointing to the
beginning of the left and right list. And look at what we do. We say, as
long as there's still something in the left list and still something in the
right list-- i is less than the length of left, j is less than the length of right.
Do the comparison. If the left wants smaller, add it to the end of result.
To the end of result, right? I'm appending it because I want it to be in"
Lecture12_Chunk85,"To the end of result, right? I'm appending it because I want it to be in
that sorted order. And increase i. If it's not, add the right one to the end
of result and increase j. And I'll just keep doing that until I exhaust one of
the lists. And when I do I can basically say, if the right list is empty, I
know if I get out of here they can't both be true. In other words, if there's
still something in the left list, just put it on the end. Otherwise if the only"
Lecture12_Chunk86,"still something in the left list, just put it on the end. Otherwise if the only
things left are in the right list, just put them on the end. So I'm just
walking down the list, doing the comparison, adding the smallest
element to my result. And when I'm done, I just return result.
Complexity we can already begin to see here, right? This says the left
and right sublists are ordered, so I'm just moving the indices depending
on which one holds the smaller element. And when I get done, I'm just"
Lecture12_Chunk87,"on which one holds the smaller element. And when I get done, I'm just
returning the rest of the list. So what's the complexity here? I'm going to
do this a little more informally. You could actually do that kind of
relationship I did last time. But what am I doing? I'm going through the
two lists, but only one time through each of those two lists. I'm only
comparing the smallest elements. So as I already said, this says that the
number of elements I copy will be everything in the left list and"
Lecture12_Chunk88,"number of elements I copy will be everything in the left list and
everything in the right list. So that order is just the length of left plus the
length of right.
And how many comparisons do I do? The most I have to do is however
many are in the longer list. Right? That's the maximum number I need to
have. Oh, that's nice. That says, if the lists are of order n-- I'm doing
order n copies, because order n plus order n is just 2n, which is order n-"
Lecture12_Chunk89,"order n copies, because order n plus order n is just 2n, which is order n-
- then I'm doing order n comparisons. So it's linear in the length of the
lists.
OK. Sounds good. That just does the merge. How do I do merge sort?
Well we said it. Break the problem in half. Keep doing it until I get sorted
lists. And then grow them back up. So there's merge sort. It says, if the
list is either empty or of length 1, just return a copy of the list. It's sorted."
Lecture12_Chunk90,"list is either empty or of length 1, just return a copy of the list. It's sorted.
Otherwise find the middle point-- there's that integer division-- and split.
Split the list everything up to the middle point and do merge sort on that.
Split everything in the list from the middle point on. Do merge sort on
that. And when I get back those two sorted lists, just merge them.
Again, I hope you can see what the order of growth should be here."
Lecture12_Chunk91,"Again, I hope you can see what the order of growth should be here.
Cutting the problem down in half at each step. So the number of times I
should have to go through this should be to log n the size of the original
list. And you can see why we call it divide and conquer. I'm dividing it
down into small pieces until I have a simple solution and then I'm
growing that solution back up. So there is the base case, there's the
divide, and there's the nice conquer [INAUDIBLE] piece of this."
Lecture12_Chunk92,"divide, and there's the nice conquer [INAUDIBLE] piece of this.
OK. I'm going to show you an example of that. But let's actually look at
some code-- sorry about that. Let's look at some code to do this. And in
fact I meant to do this earlier and didn't. I also have a version of bubble
sort here. Sorry-- selection sort. I've already done bubble sort. There is
selection sort. Let's uncomment this. And let's run both of those and just"
Lecture12_Chunk93,"selection sort. Let's uncomment this. And let's run both of those and just
see the comparison between them. Yeah, sorry-- just make that a little
easier to read. There we go.
So we saw a bubble sort. It only went through four times, so less than n
times. There's selection sort. And as I said to you, it has to do n passes
it because it can only ever guarantee that it gets one element at the
beginning. So you can in fact see, in this case, from the first or after the"
Lecture12_Chunk94,"beginning. So you can in fact see, in this case, from the first or after the
initial input until the end of the first step, it looks like it didn't do anything
because it determined eventually that one was in the right spot. And
similarly I think there's another one right there where it doesn't do any--
or appears not to do anything. All it's guaranteeing is that the next
smallest element is in the right spot. As we get through to the end of it, it
in fact ends up in the right place."
Lecture12_Chunk95,"in fact ends up in the right place.
And then let's look at merge sort and do one more visualization of this.
Again let me remove that. If we run it-- again, I've just put some print
statements in there. Here you can see a nice behavior. I start off calling
Merge Sort with that, which splits down into doing Merge Sort of this
portion. Eventually it's going to come back down there and do the
second one. It keeps doing it until it gets down to simple lists that it"
Lecture12_Chunk96,"second one. It keeps doing it until it gets down to simple lists that it
knows are sorted. And then it merges it. Does the smaller pieces and
then merges it. And having now 2 merged things, it can do the next level
of merge. So you can see that it gets this nice reduction of problems
until it gets down to the smallest size.
So let's just look at one more visualization of that and then get the
complexity. So if I start out with this list-- sorry about that. What I need to"
Lecture12_Chunk97,"complexity. So if I start out with this list-- sorry about that. What I need to
do is split it. Take the first one, split it. Keep doing that until I get down to
a base case where I know what those are and I simply merge them.
Pass it back up. Take the second piece. Split it until I get down to base
cases. Do the merge, which is nice and linear. Pass that back up.
Having done those two pieces, I do one more merge. And I do the same
thing."
Lecture12_Chunk98,"Having done those two pieces, I do one more merge. And I do the same
thing.
I want you to see this, because again you can notice how many levels in
this tree log. Log in the size. Because at each stage here, I went from a
problem of 8 to two problems of 4. Each of those went to two problems
of 2, and each of those went to two problems of size 1.
All right. So the last piece is, what's the complexity? Here's a simple way"
Lecture12_Chunk99,"All right. So the last piece is, what's the complexity? Here's a simple way
to think about it. At the top level, I start off with n elements. I've got two
sorted lists of size n over 2. And to merge them together, I need to do
order n work. Because as I said I got to do at least n comparisons where
n is the length of the list. And then I've got to do n plus n copies, which is
just order n. So I'm doing order n work.
At the second level, it gets a little more complicated. Now I've got"
Lecture12_Chunk100,"At the second level, it gets a little more complicated. Now I've got
problems of size n over 4. But how many of them do I have? 4. Oh,
that's nice. Because what do I know about this? I know that I have to
copy each element at least once. So not at least once. I will copy each
element exactly once. And I'll do comparisons that are equal to the
length of the longer list. So I've got four sublists of length n over 4 that
says n elements. That's nice. Order n. At each step, the subproblems"
Lecture12_Chunk101,"says n elements. That's nice. Order n. At each step, the subproblems
get smaller but I have more of them. But the total size of the problem is
n. So the cost at each step is order n. How many times do I do it? Log n.
So this is log n iterations with order n work at each step. And this is a
wonderful example of a log linear algorithm. It's n log n, where n is the
length of the list.
So what you end up with, then, is-- all right, a joke version, some"
Lecture12_Chunk102,"length of the list.
So what you end up with, then, is-- all right, a joke version, some
reasonable ways of doing sort that are quick and easy to implement but
are quadratic, and then an elegant way of doing the search that's n log
n. And I'll remind you I started by saying, as long as I can make the cost
of sorting small enough I can amortize that cost. And if you go back and
look at last lecture's notes, you'll see n log n grows pretty slowly. And it's"
Lecture12_Chunk103,"look at last lecture's notes, you'll see n log n grows pretty slowly. And it's
actually a nice thing to do. It makes it reasonable to do the sort. And
then I can do the search in order n time.
And here's the last punchline. It's the fastest we can do. I'm going to
look at John again. I don't think anybody has found a faster sort
algorithm. Right? This is the best one can do. Unless you do-- sorry, the
best worst case. I'm sorry. John is absolute right. There are better"
Lecture12_Chunk104,"best worst case. I'm sorry. John is absolute right. There are better
average cases. Again, our concern is worst case. So this is as good as
we're going to do in terms of a worst case algorithm. So there you now
have sorting algorithms and searching algorithms, and you've now seen-
- excuse me, sorry-- constant, log, linear, log linear, quadratic, and
exponential algorithms. I'll remind you, we want things as high up in that
hierarchy as possible."
Lecture12_Chunk105,"exponential algorithms. I'll remind you, we want things as high up in that
hierarchy as possible.
All right. I have six minutes left. Some of you are going to leave us.
We're going to miss you, but that's OK. I'm sure we'll see later on. For
those of you hanging around, this isn't a bad time just to step back and
say, so what have we seen? And I want to do this just very quickly. I'm
sorry. And I'll remind you, we started by in some sense giving you a little"
Lecture12_Chunk106,"sorry. And I'll remind you, we started by in some sense giving you a little
bit of a contract of things we were going to show you. And I would simply
suggest to you, what have we done? We've given you a sense of how to
represent knowledge with data structures, tuples, lists, dictionaries,
more complicated structures. We've shown you some good
computational metaphors, iteration, and loops. Recursion has a great
way of breaking problems down into simpler versions of the same"
Lecture12_Chunk107,"way of breaking problems down into simpler versions of the same
problem. And there really are metaphors. There are ways of thinking
about problems.
We've given you abstraction, the idea of capture a computation, bury it
in a procedure. You now have a contract. You don't need to know what
happens inside the procedure as long as it delivers the answer it says it
would. Or another way of saying it, you can delegate it to somebody and"
Lecture12_Chunk108,"would. Or another way of saying it, you can delegate it to somebody and
trust that you're going to get what you like out of it. We've seen classes
and methods as a wonderful way to modularize systems, to capture
combinations of data and things that operate on them in a nice, elegant
way. And we just spent a week and a half talking about classes of
algorithms and their complexity.
If you step up a level, what we hope you've gotten out of this are a"
Lecture12_Chunk109,"If you step up a level, what we hope you've gotten out of this are a
couple of things. You've begun to learn computational modes of
thinking. How do I tackle a problem and divide and conquer? How do I
think about recursion as a tool in dealing with something? You've begun
to-- begun, I will use that word deliberately-- to master the art of
computational problem solving. How can you take a problem and turn it
into an algorithm? And especially, you've begun to have the ability to"
Lecture12_Chunk110,"into an algorithm? And especially, you've begun to have the ability to
make the computer do what you want it to. To say, if I've got a problem
from biology or chemistry or math or physics or chemical engineering or
mechanical engineering, how do I take that problem and say, here's how
I would design an algorithm to give me a simulation and a way of
evaluating what it does.
And so what we hope we've done is, we've started you down the path to"
Lecture12_Chunk111,"evaluating what it does.
And so what we hope we've done is, we've started you down the path to
being able to think and act like a computer scientist. All right. Don't
panic. That doesn't mean you stare at people's shoes when you talk to
them. Not all computer scientists do that, just faculty. Sorry, John. So
what do computer scientists do? And this is actually meant to be serious.
And I put up two of my famous historical figures of computer scientists."
Lecture12_Chunk112,"And I put up two of my famous historical figures of computer scientists.
They do think computationally. They think about abstractions, about
algorithms, about automated execution. So the three A's of
computational thinking. And in the same way that traditionally you had
the three R's of reading, writing, and arithmetic, computational thinking
we hope is becoming a fundamental that every well-educated person is
going to need.
And that says, you think about the right abstraction. When you have a"
Lecture12_Chunk113,"going to need.
And that says, you think about the right abstraction. When you have a
problem in your [INAUDIBLE] what's the right abstraction? How do I pull
apart the pieces? How do I think about that in terms of decomposing
things into a relationship that I can use to solve problems? How do I
automate? How do I mechanize that abstraction? How do I use what I
know happens inside of the machine to write a sequence of steps in a"
Lecture12_Chunk114,"know happens inside of the machine to write a sequence of steps in a
language I'm using to capture that process? And then finally, how do I
turn that into an algorithm? And that not only means I need a language
for describing those automated processes, and if you like allowing the
abstraction of details, but frankly also a way to communicate. If you have
to think crisply about how do I describe an algorithm, it's actually giving"
Lecture12_Chunk115,"to think crisply about how do I describe an algorithm, it's actually giving
you a way to crystallize or clarify your thinking about a problem. This is
not to say you should talk to your friends in Python. I don't recommend
it. But it does say you should use that thinking as a way of capturing
your ideas of what you're going to do.
And that leads, then, to this idea of, how difficult is a problem? How best
can I solve it? We've shown you these complexity classes and we've"
Lecture12_Chunk116,"can I solve it? We've shown you these complexity classes and we've
hinted at the idea that in fact some problems are inherently more difficult
than others. That's something I hope you come back to as you go along.
And especially we want you to start thinking recursively. We want you to
think about how do I take a hard problem, break it up into simpler
versions of the same problem, and then construct the solution. And that
shows up lots of places. Right? Recursion is in all sorts of wonderful"
Lecture12_Chunk117,"shows up lots of places. Right? Recursion is in all sorts of wonderful
places. So just to give you an example, I could say to you recursively,
""This lecture will end when I'm done talking about this lecture, which will
end when I'm done talking about this lecture, which will end when I'm
done--""
All right. You don't like infinite recursion. Good luck on the exam."
